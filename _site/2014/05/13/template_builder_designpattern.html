<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

    <title>Template_Builder_DesignPattern</title>
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
  </head>
  <body>
    <aside id="sidebar">
      <nav id="tags">
        <a href="/index.html" id="avatar"></a>

        <ul id="tags__ul">
		  <li id="js-label1" class="tags__li tags-btn active">全部文章</li>
		  <li id="js-label2" class="tags__li tags-btn">Kernel内核</li>
          <li id="js-label3" class="tags__li tags-btn">JOS</li>
          <li id="js-label4" class="tags__li tags-btn">Qt</li>
          <li id="js-label5" class="tags__li tags-btn">Grammer</li>
          <li id="js-label6" class="tags__li tags-btn">读书笔记</li>
        </ul>

        <div id="tags__bottom">
          <a href="mailto:ldm5235@gmail.com" id="icon-email" class="tags-btn fontello"></a>
          <a href="/rss.xml" id="icon-feed" class="tags-btn fontello"></a>
        </div>
      </nav> <!-- end #tags -->

      <div id="posts-list">
        <form action="" id="search-form">
          <a href="/index.html" id="mobile-avatar"></a>
          <!-- NOTE: input field is disabled by default -->
          <input id="search-input" type="text" placeholder="Search...">
        </form>

        <nav id="pl__container">
        
          <a class="designpattern pl__all" href="/2014/05/22/mediatorc.html"><span class="pl__circle"></span><span class="pl__title">Mediator模式C++实现</span><span class="pl__date">May 2014</span></a>
        
          <a class="designpattern pl__all" href="/2014/05/19/proxyc.html"><span class="pl__circle"></span><span class="pl__title">Proxy模式C++实现</span><span class="pl__date">May 2014</span></a>
        
          <a class="designpattern pl__all" href="/2014/05/19/protype_iteratorc.html"><span class="pl__circle"></span><span class="pl__title">Protype_IteratorC++实现</span><span class="pl__date">May 2014</span></a>
        
          <a class="designpattern pl__all" href="/2014/05/13/template_builder_designpattern.html"><span class="pl__circle"></span><span class="pl__title">Template_Builder_DesignPattern</span><span class="pl__date">May 2014</span></a>
        
          <a class="linux pl__all" href="/2014/05/07/unix_thread_api.html"><span class="pl__circle"></span><span class="pl__title">Unix_Thread_API备注</span><span class="pl__date">May 2014</span></a>
        
          <a class="designpattern pl__all" href="/2014/05/03/factory_designpattern.html"><span class="pl__circle"></span><span class="pl__title">Factory_DesignPattern</span><span class="pl__date">May 2014</span></a>
        
          <a class="linux pl__all" href="/2014/04/14/ram_management3.html"><span class="pl__circle"></span><span class="pl__title">RAM_Management3个层次的关系</span><span class="pl__date">Apr 2014</span></a>
        
          <a class="linux pl__all" href="/2014/04/14/linux-vm.html"><span class="pl__circle"></span><span class="pl__title">Linux VM虚拟存储器系统（读书笔记）</span><span class="pl__date">Apr 2014</span></a>
        
          <a class="jos pl__all" href="/2014/04/09/jospriorityrr_sched.html"><span class="pl__circle"></span><span class="pl__title">在JOS上实现基于Priority的RR_sched</span><span class="pl__date">Apr 2014</span></a>
        
          <a class="linux pl__all" href="/2014/04/08/systemcall.html"><span class="pl__circle"></span><span class="pl__title">Systemcall流程</span><span class="pl__date">Apr 2014</span></a>
        
          <a class="language pl__all" href="/2014/03/30/markdown-grammer.html"><span class="pl__circle"></span><span class="pl__title">Markdown grammer</span><span class="pl__date">Mar 2014</span></a>
        
          <a class="jos pl__all" href="/2014/03/26/idtmd.html"><span class="pl__circle"></span><span class="pl__title">设定IDT表以及中断处理函数编写</span><span class="pl__date">Mar 2014</span></a>
        
          <a class="linux pl__all" href="/2014/03/13/interrupt.html"><span class="pl__circle"></span><span class="pl__title">异常控制流（读书笔记）</span><span class="pl__date">Mar 2014</span></a>
        
          <a class="jos pl__all" href="/2014/03/10/jos.html"><span class="pl__circle"></span><span class="pl__title">JOS虚拟页表的实现</span><span class="pl__date">Mar 2014</span></a>
        
          <a class="jos pl__all" href="/2014/03/04/jos.html"><span class="pl__circle"></span><span class="pl__title">JOS的物理页表分配实现</span><span class="pl__date">Mar 2014</span></a>
        
          <a class="jos pl__all" href="/2014/02/24/frame-info.html"><span class="pl__circle"></span><span class="pl__title">打印Frame Info</span><span class="pl__date">Feb 2014</span></a>
        
          <a class="linux pl__all" href="/2014/01/03/linux.html"><span class="pl__circle"></span><span class="pl__title">Linux系统调用（读书笔记）</span><span class="pl__date">Jan 2014</span></a>
        
          <a class="linux pl__all" href="/2013/12/18/systemtap-kprobe.html"><span class="pl__circle"></span><span class="pl__title">SystemTap Kprobe原理</span><span class="pl__date">Dec 2013</span></a>
        
          <a class="linux pl__all" href="/2013/12/11/kernel-development.html"><span class="pl__circle"></span><span class="pl__title">内核开发特点&进程管理（读书笔记）</span><span class="pl__date">Dec 2013</span></a>
        
          <a class="arch pl__all" href="/2013/12/10/storage.html"><span class="pl__circle"></span><span class="pl__title">Storage层次结构（读书笔记）</span><span class="pl__date">Dec 2013</span></a>
        
          <a class="arch pl__all" href="/2013/12/04/cpu.html"><span class="pl__circle"></span><span class="pl__title">CPU指令并行化（读书笔记）</span><span class="pl__date">Dec 2013</span></a>
        
          <a class="linux pl__all" href="/2013/11/29/gprof-.html"><span class="pl__circle"></span><span class="pl__title">GPROF 使用</span><span class="pl__date">Nov 2013</span></a>
        
          <a class="linux pl__all" href="/2013/11/28/programme_opinion.html"><span class="pl__circle"></span><span class="pl__title">programme_opinion（读书笔记）</span><span class="pl__date">Nov 2013</span></a>
        
          <a class="linux pl__all" href="/2013/11/22/share-object-library.html"><span class="pl__circle"></span><span class="pl__title">编写Share Object Library</span><span class="pl__date">Nov 2013</span></a>
        
          <a class="linux pl__all" href="/2013/11/22/ltrace-strace-ftrace.html"><span class="pl__circle"></span><span class="pl__title">调试工具ltrace strace ftrace的使用</span><span class="pl__date">Nov 2013</span></a>
        
          <a class="linux pl__all" href="/2013/11/13/linux-kernel.html"><span class="pl__circle"></span><span class="pl__title">裁剪编译Linux Kernel</span><span class="pl__date">Nov 2013</span></a>
        
        </nav>
      </div> <!-- end #posts-list -->
    </aside> <!-- end #sidebar -->

    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="20140513">Template_Builder_DesignPattern</h1>
  <h1>模板方法模式 建造者模式 C++实现</h1>

<p>今天我继续来填坑，模板方法模式就是在模板方法中按照一定的规则顺序调用基本方法。这个比较简单。</p>

<p>比如我在父类run（）中调用类中一系列的方法。钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它。</p>

<p><strong><em>Java中，如果父类里面有些方法不允许覆写，那么为了防止子类改变模板方法中的算法，可以将模板方法声明为final。</em></strong></p>

<p><img src="/assets/pic/IMG_0432.jpg" alt="" /></p>

<pre><code>
#include <iostream>
using namespace std;
 
class CarTemplate
{
public:
    CarTemplate(void){};
    virtual ~CarTemplate(void){};
 
protected:
    virtual void Start() = 0;
    virtual void Stop() = 0;
    virtual void Alarm() = 0;
    virtual void EngineBoom() = 0;
    virtual bool IsAlarm() =0;
 
public:
        void Run()
        {
        Start();
 
        EngineBoom();
 
        if(IsAlarm())
            Alarm();
 
        Stop();
        };
};
 
class Hummer: public CarTemplate
{
public:
    Hummer(){m_isAlarm = true;}
    virtual ~Hummer(){};
 
protected:
    void Start(){   cout<< "Hummer Start" << endl;   }
    void Stop(){    cout<< "Hummer Stop" << endl;    }
    void Alarm(){   cout<< "Hummer Alarm" << endl;}
    bool IsAlarm(){ return m_isAlarm;       }
    void EngineBoom(){  cout<< "Hummer EngineBoom" << endl;  }
private:
    bool m_isAlarm;
};
 
class Benz: public CarTemplate
{
public:
    Benz(){m_isAlarm = false;}
    virtual ~Benz(){};
 
protected:
    void Start(){   cout<< "Benz Start" << endl; }
    void Stop(){    cout<< "Benz Stop" << endl;  }
    void Alarm(){   cout<< "Benz Alarm" << endl;}
    bool IsAlarm(){ return m_isAlarm;       }
    void EngineBoom(){  cout<< "Benz EngineBoom" << endl;    } 
private:     
        bool m_isAlarm; 
}; 

int main() 
{   
        CarTemplate *hummer = new Hummer();     
        hummer->Run();
    delete  hummer;
 
    CarTemplate *benz = new Benz();
    benz->Run();
    delete benz;
}
</code></pre>


<p>优点就在于可以封装不变的部分，拓展可变的部分，也就是把共性的东西抽取出来，这样可以便于维护。</p>

<p>但是缺点在于子类的执行，影响到父类的结果。有时候会有一些晦涩难懂。
———————————————————————————————-</p>

<p><strong><em>在模板方法中，我们把相同的都封装在父类中，不同都定义在子类中。但是需求的变化是无穷无尽的。</em></strong></p>

<blockquote><p>比如建造的顺序可能是变化的，所以将他放到builder类中，通过builder类获取真正的product！</p></blockquote>

<p><img src="/assets/pic/6446jgG.gif" alt="" /></p>

<pre><code>
class Builder
{
public:
    virtual void BuildHead() {}
    virtual void BuildBody() {}
    virtual void BuildLeftArm(){}
    virtual void BuildRightArm() {}
    virtual void BuildLeftLeg() {}
    virtual void BuildRightLeg() {}
};
//构造瘦人
class ThinBuilder:public Builder
{
public:
    void BuildHead() { cout<< "build thin body" << endl; }
    void BuildBody() { cout<< "build thin head" << endl; }
    void BuildLeftArm() { cout<< "build thin leftarm" << endl; }
    void BuildRightArm() { cout<< "build thin rightarm" << endl; }
    void BuildLeftLeg() { cout<< "build thin leftleg" << endl; }
    void BuildRightLeg() { cout<< "build thin rightleg" << endl; }
};
//构造胖人
class FatBuilder : public Builder
{
public:
    void BuildHead() { cout<<"build fat body"<< endl; }
    void BuildBody() { cout<<"build fat head"<< endl; }
    void BuildLeftArm() { cout<<"build fat leftarm"<< endl; }
    void BuildRightArm() { cout<<"build fat rightarm"<< endl; }
    void BuildLeftLeg() { cout<<"build fat leftleg"<< endl; }
    void BuildRightLeg() { cout<<"build fat rightleg"<< endl; }   
};   //构造的指挥官   

class Director     {   
private:       
    Builder *m_pBuilder;   
public:       
    Director(Builder *builder) { m_pBuilder = builder; }       
    void Create()
    {           
        m_pBuilder->BuildHead();
        m_pBuilder->BuildBody();
        m_pBuilder->BuildLeftArm();
        m_pBuilder->BuildRightArm();
        m_pBuilder->BuildLeftLeg();
        m_pBuilder->BuildRightLeg();
    }
};
 
int main()
{
    FatBuilder fat;
    Director director(&fat);
    director.Create();
---------------------------------------------------------------------------
    Builder *thin = new ThinBuilder();
    Director *dir = new Director(thin);
    dir->Create();
 
    return 0;
}
</code></pre>


<p><strong><em>建造者模式的优点：在于我们不用关心每个产品内部的组成细节，比如FatBuildier ThinBuilider，然后我们交给Director来构造就好了。</em></strong></p>

<p>建造者是独立的，我们可以拓展更多的builder完成不同的功能。并不对系统有任何影响。</p>

<p><strong>_特别适合产品类特别复杂，顺序不同，效能不同。顺序是区别模板模式与建造者模式最大的不同点！</strong></p>

<blockquote><p>另外同工厂模式进行比较，工厂模式适合生产零件。不能再细分了。否则就不适合工厂模式。</p></blockquote>

<h5>把模板方式和建造者模式组合起来可以产生很好的效果，可以按照model通过builder批量生产某种特定型号的产品。</h5>

<p><img src="/assets/pic/IMG_0433.jpg" alt="" /></p>

<pre><code>
#include<iostream>
#include<vector>
#include<string>
using namespace std;

class CCarModel
{
public:
    CCarModel(void) {}
    virtual ~CCarModel(void){}
    void Run()
    {
            vector::const_iterator it = m_pSequence->begin();
        for (; it < m_pSequence->end(); ++it)
        {
            string actionName = *it;
            if(actionName.compare("start") == 0)
            {
                Start();
            }
            else if(actionName.compare("stop") == 0)
            {
                Stop();
            }
            else if(actionName.compare("alarm") == 0)
            {
                Alarm();
            }
            else if(actionName.compare("engine boom") == 0)
            {
                EngineBoom();
            }
        }
    }
    void SetSequence(vector *pSeq)
    {
            m_pSequence = pSeq;
    }
protected:
    virtual void Start() = 0;
    virtual void Stop() = 0;
    virtual void Alarm() = 0;
    virtual void EngineBoom() = 0;
private:
    vector * m_pSequence;
};

class CBenzModel : public CCarModel
{
public:
    CBenzModel(void){}
    ~CBenzModel(void){}
protected:
    void Start(){cout << "Benz Start..." << endl;}
    void Stop(){cout << "Benz Stop..." << endl;}
    void Alarm(){cout << "Benz Alarm" << endl;}
    void EngineBoom(){cout << "Benz EngineBoom...." << endl;}
};

class CBMWModel : public CCarModel
{
public:
    CBMWModel(void){}
    ~CBMWModel(void){}
protected:
    void Start(){cout << "BMW Start..." << endl;}
    void Stop(){cout << "BMW Stop..." << endl;}
    void Alarm(){cout << "BMW Alarm" << endl;}
    void EngineBoom(){cout << "BMW EngineBoom...." << endl;}
};

class ICarBuilder
{
public:
    ICarBuilder(void)   { }
    virtual ~ICarBuilder(void)  { }
    virtual void SetSequence(vector *pseq) = 0;
    virtual CCarModel * GetCarModel() = 0;
};

class CBenzBuilder : public ICarBuilder
{
public:
    CBenzBuilder(void);
    ~CBenzBuilder(void);
    void SetSequence(vector *pSeq);
    CCarModel * GetCarModel();
private:
    CCarModel *m_pBenz;
};
CBenzBuilder::CBenzBuilder(void)
{
    m_pBenz = new CBenzModel();
}
CBenzBuilder::~CBenzBuilder(void)
{
    delete m_pBenz;
}
void CBenzBuilder::SetSequence(vector *pSeq)
{
    m_pBenz->SetSequence(pSeq);
}
CCarModel * CBenzBuilder::GetCarModel()
{
    return m_pBenz;
}

class CBMWBuilder :public ICarBuilder
{
public:
    CBMWBuilder(void);
    ~CBMWBuilder(void);
    void SetSequence(vector *pSeq);
    CCarModel * GetCarModel();
private:
    CCarModel *m_pBMW;
};

CBMWBuilder::CBMWBuilder(void)
{
    m_pBMW = new CBMWModel();
}
CBMWBuilder::~CBMWBuilder(void)
{
    delete m_pBMW;
}
void CBMWBuilder::SetSequence( vector *pSeq )
{
    m_pBMW->SetSequence(pSeq);
}
CCarModel * CBMWBuilder::GetCarModel()
{
    return m_pBMW;
}

class CDirector
{
public:
    CDirector(void);
    ~CDirector(void);
    CBenzModel * GetABenzModel();
    CBenzModel * GetBBenzModel();
    CBMWModel * GetCBMWModel();
    CBMWModel * GetDBMWModel();
private:
    vector * m_pSeqence;
    CBenzBuilder * m_pBenzBuilder;
    CBMWBuilder * m_pBMWBuilder;
};

CDirector::CDirector(void)
{
    m_pBenzBuilder = new CBenzBuilder();
    m_pBMWBuilder = new CBMWBuilder();
    m_pSeqence = new vector();
}
CDirector::~CDirector(void)
{
    delete m_pBenzBuilder;
    delete m_pBMWBuilder;
    delete m_pSeqence;
}
CBenzModel * CDirector::GetABenzModel()
{
    m_pSeqence->clear();
    m_pSeqence->push_back("start");
    m_pSeqence->push_back("stop");
    m_pBenzBuilder->SetSequence(m_pSeqence);
    return dynamic_cast<CBenzModel*>(m_pBenzBuilder->GetCarModel());
}
CBenzModel * CDirector::GetBBenzModel()
{
    m_pSeqence->clear();
    m_pSeqence->push_back("engine boom");
    m_pSeqence->push_back("start");
    m_pSeqence->push_back("stop");
    m_pBenzBuilder->SetSequence(m_pSeqence);
    return dynamic_cast<CBenzModel*>(m_pBenzBuilder->GetCarModel());
}
CBMWModel * CDirector::GetCBMWModel()
{
    m_pSeqence->clear();
    m_pSeqence->push_back("alarm");
    m_pSeqence->push_back("start");
    m_pSeqence->push_back("stop");
    m_pBMWBuilder->SetSequence(m_pSeqence);
    return static_cast<CBMWModel*>(m_pBMWBuilder->GetCarModel());
}
CBMWModel * CDirector::GetDBMWModel()
{
    m_pSeqence->clear();
    m_pSeqence->push_back("start");
    m_pBenzBuilder->SetSequence(m_pSeqence);
    return dynamic_cast<CBMWModel*>(m_pBMWBuilder->GetCarModel());
}
int main(int argc, char const *argv[])
{
    CDirector *dir = new CDirector();

    dir->GetBBenzModel()->Run();
    return 0;
}


</code></pre>


<p>通过上面可以看出两个模式的配合得到了很好的运用！</p>

<p>引用 http://blog.csdn.net/wuzhekai1985/article/details/6667467</p>

</article> <!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=http://lzz5235.github.com/2014/05/13/template_builder_designpattern.html&text=Template_Builder_DesignPattern" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="http://creativecommons.org/licenses/by-nc-sa/3.0" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=http://lzz5235.github.com/2014/05/13/template_builder_designpattern.html&title=Template_Builder_DesignPattern" target="_blank"></a>
</div> <!-- end #post__share -->

<div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div> <!-- end #disqus_thread -->

<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a>&nbsp;&nbsp;Fork My <a href="https://github.com/lzz5235" target="_blank">Github</a></p>

      </div> <!-- end #pjax -->

      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">Table of Contents</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div>
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>

    <script src="/assets/js/jquery-2.0.3.min.js"></script>
    <script src="/assets/js/jquery.pjax.js"></script>
    <script src="/assets/js/nprogress.js"></script>
    <script src="/assets/js/script.js"></script>
  </body>
</html>
