<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

    <title>JOS的物理页表分配实现</title>
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
  </head>
  <body>
    <aside id="sidebar">
      <nav id="tags">
        <a href="/index.html" id="avatar"></a>

        <ul id="tags__ul">
          <li id="js-label1" class="tags__li tags-btn active">全部文章</li>
          <li id="js-label2" class="tags__li tags-btn">Kernel内核</li>
          <li id="js-label3" class="tags__li tags-btn">JOS</li>
          <li id="js-label4" class="tags__li tags-btn">C/C++</li>
          <li id="js-label5" class="tags__li tags-btn">Grammer</li>
          <li id="js-label6" class="tags__li tags-btn">杂谈</li>
        </ul>

        <div id="tags__bottom">
          <a href="mailto:ldm5235@gmail.com" id="icon-email" class="tags-btn fontello"></a>
          <a href="/rss.xml" id="icon-feed" class="tags-btn fontello"></a>
        </div>
      </nav> <!-- end #tags -->

      <div id="posts-list">
        <form action="" id="search-form">
          <a href="/index.html" id="mobile-avatar"></a>
          <!-- NOTE: input field is disabled by default -->
          <input id="search-input" type="text" placeholder="Search..." disabled >
        </form>

        <nav id="pl__container">
        
          <a class="jos pl__all" href="/2014/04/09/jospriorityrr_sched.html"><span class="pl__circle"></span><span class="pl__title">在JOS上实现基于Priority的RR_sched</span><span class="pl__date">Apr 2014</span></a>
        
          <a class="linux pl__all" href="/2014/04/08/systemcall.html"><span class="pl__circle"></span><span class="pl__title">Systemcall流程</span><span class="pl__date">Apr 2014</span></a>
        
          <a class="language pl__all" href="/2014/03/30/markdown-grammer.html"><span class="pl__circle"></span><span class="pl__title">Markdown grammer</span><span class="pl__date">Mar 2014</span></a>
        
          <a class="jos pl__all" href="/2014/03/10/jos.html"><span class="pl__circle"></span><span class="pl__title">JOS虚拟页表的实现</span><span class="pl__date">Mar 2014</span></a>
        
          <a class="jos pl__all" href="/2014/03/04/jos.html"><span class="pl__circle"></span><span class="pl__title">JOS的物理页表分配实现</span><span class="pl__date">Mar 2014</span></a>
        
          <a class="jos pl__all" href="/2014/02/24/frame-info.html"><span class="pl__circle"></span><span class="pl__title">打印Frame Info</span><span class="pl__date">Feb 2014</span></a>
        
          <a class="linux pl__all" href="/2013/11/13/linux-kernel.html"><span class="pl__circle"></span><span class="pl__title">裁剪编译Linux Kernel</span><span class="pl__date">Nov 2013</span></a>
        
        </nav>
      </div> <!-- end #posts-list -->
    </aside> <!-- end #sidebar -->

    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="20140304">JOS的物理页表分配实现</h1>
  <h1>JOS的物理页表分配实现</h1>

<p>最近将JOS的启动流程学习了一遍，细化了系统从real mode到32-bit的转变。
但是在系统真正要接管内存，分配真正页表之前，要有一个简单的页表将kernel code载入到内存中。</p>

<p>我们先使用一个static void i386_detect_memory(void) 函数来探测物理内存一共有多少pages，一个page为4K.
另外我们看一下JOS的memery map就可以发现我们做的工作，写这部分一定要有好的大局观。知道每部分初始化位于内存的哪个位置。</p>

<p>我先画了一个JOS初始化的内存page分配图。
<img src="/assets/pic/235.png" alt="" /></p>

<p>下面这个函数是在没有建立系统分页机制前，一个临时简易的物理页表，直接是在物理内存上进行的，用的也是虚拟地址，比如kernel code 起始代码的虚拟内存在0xf0100000，实际位置要剪掉一个一个KERNBASE的宏（0xf0000000）.这个部分就要有初始的物理页表进行管理。</p>

<pre><code>
boot_alloc(uint32_t n)
{
    static char *nextfree; 
    char *result = NULL;
 
    if (!nextfree) {
        extern char end[];
        nextfree = ROUNDUP((char *) end, PGSIZE);
//      cprintf("end = %p\n ",end);
//      cprintf("nextfree = %p\n ",nextfree);   
    }   
 
    result = nextfree;
    if((uint32_t)(result - KERNBASE+n) > (uint32_t)(npages*PGSIZE))
    {   
        panic("boot_alloc():out of physical memory\n");
    }                                                                                                                  
    nextfree = ROUNDUP(result+n,PGSIZE); 
//这里使用两个指针来标记将要使用的空间和下一次要分配的空间，
//其中result代表将要使用的n个byte空间 ，nextfree是指下次要使用的空间的首地址
 
//    cprintf("n = %d\n",n);
//    cprintf("result = %p\n",result);
//    cprintf("nextfree = %p\n\n",nextfree);
    return result;
}
</code></pre>


<p>然后我们要建立一个映射整条物理内存的页表，前面我们已经说明。因为我们已经得到了所有的npages，然后针对每个pages对应一个pages，这样就实现了所有物理内存的映射。</p>

<p>通过上面的图，我们发现已被占用的物理内存有两块：</p>

<p><strong>_1. 0至4KB(第0页)；</strong></p>

<p><strong><em>2. 640KB开始，至当前可用物理地址（利用boot_alloc(0)获得，小心要通过PADDR转化成物理地址）；
另外，我们认为boot loader、Kernel可执行代码的ELF文件头这两块内存的内容是可以覆盖的。</em></strong></p>

<p>所以我们初始寻找出IOPHYSMEM EXTPHYSEME。这部分代码主要是BIOS，CMOS的固件代码，不能覆盖，需要跳过。
但是首先我们需要找到IOPHYSMEM EXTPHYSEME对应的pages页。然后跳过，将空余的pages链接到page_free_list 。如果之后有需要，就要从page_free_list 上面取下一个page，进行分配，说白了就是链表节点的链接与删除。</p>

<pre><code>
void
page_init(void)
{
    size_t i;    
    size_t IOPHYSMEM_begin = ROUNDDOWN(IOPHYSMEM,PGSIZE)/PGSIZE;
    size_t EXTPHYSEME_end = PADDR(boot_alloc(0)) / PGSIZE;
//  cprintf("IO = %d   EXT = %d \n",IOPHYSMEM_begin,EXTPHYSEME_end);
 
//  cprintf("npages_basemem:%d\n",npages_basemem);
//  cprintf("PGNUM : %d\n",PGNUM(PADDR(boot_alloc(0) ) ) );
//  cprintf("npages = %d\n",npages);
    page_free_list = NULL;
     
    for (i = 0; i < npages; i++) {
        pages[i].pp_ref = 0;
        if(0 == i || ( (IOPHYSMEM_begin <= i) && ( i < EXTPHYSEME_end ) ) )
        {
//          cprintf("IOHOLE = %p\n",&pages[i]);
        }
        else
        {
            pages[i].pp_link = page_free_list;
            page_free_list = &pages[i];//等于链表实现
            //cprintf("Normal = %p\n",page_free_list);
        }
    }
}
struct PageInfo *
page_alloc(int alloc_flags)
{
    // Fill this function in
    struct PageInfo *page_return;
    if(page_free_list != NULL)
    {   
        page_return = page_free_list;
        page_free_list = (struct PageInfo *)page_free_list->pp_link;
        if(alloc_flags & ALLOC_ZERO)
        {   
            memset(page2kva(page_return),'\0',PGSIZE);
        }   
    }   
    else
        page_return =NULL;
 
    return page_return;
}
 
void
page_free(struct PageInfo *pp)
{
    // Fill this function in
    pp->pp_link = page_free_list;
    page_free_list = pp; 
 
    return;
}
</code></pre>


</article> <!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=place_your_url_here/2014/03/04/jos.html&text=JOS的物理页表分配实现" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="http://creativecommons.org/licenses/by-nc-sa/3.0" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=place_your_url_here/2014/03/04/jos.html&title=JOS的物理页表分配实现" target="_blank"></a>
</div> <!-- end #post__share -->

<div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div> <!-- end #disqus_thread -->

<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a></p>
      </div> <!-- end #pjax -->

      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">Table of Contents</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div>
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>

    <script src="/assets/js/jquery-2.0.3.min.js"></script>
    <script src="/assets/js/jquery.pjax.js"></script>
    <script src="/assets/js/nprogress.js"></script>
    <script src="/assets/js/script.js"></script>
  </body>
</html>
