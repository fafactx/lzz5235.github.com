<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>JasonLe's Blog |HomePage</title>
    <link href="http://www.lizhaozhong.info/feed/" rel="self" />
    <link href="http://www.lizhaozhong.info" />
    <lastBuildDate>2014-06-09T20:51:12+08:00</lastBuildDate>
    <webMaster>ldm5235@gmail.com</webMaster>
    
    <item>
      <title>User Excption Stack Design</title>
      <link href="http://www.lizhaozhong.info/2014/06/08/user-excption-stack-design.html"/>
      <pubDate>2014-06-08T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/06/08/user-excption-stack-design</guid>
      <content:encoded><![CDATA[<h1>用户空间的异常栈设计</h1>

<p>这个坑想了很久，但是一直没时间填，今天抽出一个周六，把之前的草稿完成！</p>

<p>我们知道在linux中如果用户程序发生错误，kernel会终止程序运行，并发出segment fault错误。
这种实现其实就是在用户空间实现了异常栈的操作。</p>

<p>下面我来说一下JOS的用户空间的异常栈设计。</p>

<p>首先明确几个概念：</p>

<p>在明确概念前，我们要先看明白JOS内存分布</p>

<pre><code>
 * Virtual memory map:                                Permissions
 *                                                    kernel/user
 *
 *    4 Gig -------->  +------------------------------+
 *                     |                              | RW/--
 *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                     :              .               :
 *                     :              .               :
 *                     :              .               :
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
 *                     |                              | RW/--
 *                     |   Remapped Physical Memory   | RW/--
 *                     |                              | RW/--
 *    KERNBASE, ---->  +------------------------------+ 0xf0000000      --+
 *    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
 *                     +------------------------------+                   |
 *                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |
 *                     | - - - - - - - - - - - - - - -|                 PTSIZE
 *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
 *                     +------------------------------+                   |
 *                     :              .               :                   |
 *                     :              .               :                   |
 *    MMIOLIM ------>  +------------------------------+ 0xefc00000      --+
 *                     |       Memory-mapped I/O      | RW/--  PTSIZE
 * ULIM, MMIOBASE -->  +------------------------------+ 0xef800000
 *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
 *    UVPT      ---->  +------------------------------+ 0xef400000
 *                     |          RO PAGES            | R-/R-  PTSIZE
 *    UPAGES    ---->  +------------------------------+ 0xef000000
 *                     |           RO ENVS            | R-/R-  PTSIZE
 * UTOP,UENVS ------>  +------------------------------+ 0xeec00000
 * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebff000
 *                     |       Empty Memory (*)       | --/--  PGSIZE
 *    USTACKTOP  --->  +------------------------------+ 0xeebfe000
 *                     |      Normal User Stack       | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebfd000
 *                     |                              |
 *                     |                              |
 *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                     .                              .
 *                     .                              .
 *                     .                              .
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
 *                     |     Program Data & Heap      |
 *    UTEXT -------->  +------------------------------+ 0x00800000
 *    PFTEMP ------->  |       Empty Memory (*)       |        PTSIZE
 *                     |                              |
 *    UTEMP -------->  +------------------------------+ 0x00400000      --+
 *                     |       Empty Memory (*)       |                   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |  User STAB Data (optional)   |                 PTSIZE
 *    USTABDATA ---->  +------------------------------+ 0x00200000        |
 *                     |       Empty Memory (*)       |                   |
 *    0 ------------>  +------------------------------+                 --+
 *
 * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
 *     "Empty Memory" is normally unmapped, but user programs may map pages
 *     there if desired.  JOS user programs map pages temporarily at UTEMP.
</code></pre>


<h6>内核栈：kernel代码正常执行时，包括发生中断/异常陷入kernel时，kernel运行的栈称为“内核栈(kernel stack)”，它的esp寄存器指向当前CPU的栈顶，栈的线性地址范围为[kstacktop_i - KSTKSIZE, kstacktop_i -1]. （我们要知道在多核环境下，内核栈有多少个由核心数决定）中断/异常发生时，CPU自动切换到内核栈。之前我已经设置过内核栈。</h6>

<h6>用户运行栈：在用户程序正常执行时，它所运行的栈称为“用户运行栈(normal user stack)”，它的esp寄存器指向USTACKTOP, 栈的线性地址范围是[USTACKTOP - PGSIZE, USTACKTOP - 1].</h6>

<h6>用户异常栈：是用户自己定义相应的中断处理程序后，相应处理程序运行时的栈。注意这个处理程序是user mode的，而不是在内核中。它的esp寄存器指向UXSTACKTOP, 栈的线性地址范围是[UXSTACKTOP - PGSIZE, UXSTACKTOP - 1]，也是一页大小。</h6>

<p>user mode发生异常，用户空间发生了一个page fault. 如果没有用户异常栈，理论上用户程序执行不下去了，它将陷入内核栈，然后在内核中处理page fault，然后返回用户程序。但是，这里我们将采用一个新的机制！也就是不再在内核中处理page fault，而是在user mode的用户异常栈上！</p>

<p>用户空间发生page fault后，首先陷入内核（用户运行栈->内核栈， user mode -> kernel mode），进入trap()处理中断分发，进入page_fault_handler().</p>

<p>然后内核中的page_fault_handler()在确认是用户程序而不是内核触发了page fault后（如果是内核发生page fault就直接panic了），在用户异常栈上压入一个UTrapframe作为记录保存现场的信息（注意这只是内存操作，还没有切换到用户异常栈）。</p>

<p>kernel将用户程序切换到用户异常栈（内核栈->用户异常栈, kernel mode -> user mode），然后就让用户程序重新运行了！</p>

<blockquote><p>这里有两点要说明：1.现在用户程序是运行在用户异常栈（而不是用户运行栈）上，2.此时的eip被设置为page fault处理程序的起始地址curenv->env_pgfault_upcall。所以，接下来用户程序执行处理page fault的处理程序，它实际上是在用户空间中进行处理。</p>

<p>page fault被处理完后，切换回用户运行栈（用户异常栈->用户运行栈, user mode -> user mode），用户程序重新运行。
弄清楚page fault发生前后“栈的切换”、“特权级别(mode)的切换”是非常重要的。</p></blockquote>

<p>实际上判断用户程序是在kernel mode 还是 user mode主要是通过寄存器中 tf_cs == GD_KT来判断。</p>

<p>如果这个寄存器记录的值不是GD_KT那么，说明pagefault来自用户空间。</p>

<p>然后检查检查user mode pagefault handler即将调用异常处理函数的入口地址。即env_pgfault_upcall</p>

<p>这里涉及一个问题，判断当前的esp是否已经在用户异常栈中.</p>

<p>如果是的话，就要从esp再往下分配一个sizeof（UTrapframe）大小的空间，存放UTrapframe，否则从用户异常栈顶UXSTACKTOP分配UTrapframe。然后将寄存器里面的值eflags ，eip， esp，regs存入到UTrapframe结构体中。</p>

<h6>UTrapframe不同在于Trapframe的是env_tf.tf_eip env_tf.tf_esp</h6>

<p>env_tf.tf_eip指向用户自己的异常处理函数，env_tf.tf_esp指向的是UTrapframe，保存完现场，然后系统把控制权交给用户定义的异常处理函数，然后系统进行调度。</p>

<p>理解了上述的过程，我对中断用户异常处理函数有了好的了解，下一步实现该代码即可。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Strategy Pattern with C++</title>
      <link href="http://www.lizhaozhong.info/2014/06/06/Strategy-Pattern-with-c.html"/>
      <pubDate>2014-06-06T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/06/06/Strategy-Pattern-with-c</guid>
      <content:encoded><![CDATA[<h1>策略模式及其拓展 C++实现</h1>

<p>策略模式形式上其实和装饰者模式，工厂模式都很像，装饰者模式是在原有核心的业务上添加新的业务，工厂模式是在构造函数中传入新类类名，然后返回新的类。而策略模式则是将策略类传入到执行类里，达到执行策略的目的！</p>

<p>工厂模式和策略模式有很多相通的地方。都是创造类。</p>

<h6>不同点在于：工厂模式有可能各个类的方法名和个数差别很大，注重不同对象的创建。策略模式 一般用于多个类的方法名都相同,但是实现方式不同 注重多个对象的相同行为：屏蔽方法名相同，算法实现细节不同之间的差异</h6>

<p>策略模式的缺点是：策略类数量过多，所有策略类都必须对外暴露。</p>

<h5>原则就是：当具体策略超过4个的时候，就要考虑使用混合模式，比如和工厂模式混用！</h5>

<p><img src="/assets/pic/1855.png" alt="" /></p>

<pre><code>
#include <iostream>
#include <string>
using namespace std;
 
class IStrategy
{
public:
    IStrategy(void){};
    virtual ~IStrategy(void){};
    virtual void Operate(void) = 0;
};
 
class context
{
public:
    context(IStrategy *isstrategy):m_strategy(isstrategy){}
    ~context(){}
    void Operate(void){m_strategy->Operate();}
private:
    IStrategy *m_strategy;
      
};
 
class BackDoor:public IStrategy
{
public:
    BackDoor(void){}
    ~BackDoor(void){}
    void Operate(void){std::cout <<"BackDoor" << std::endl;}
};
 
class GreenLight:public IStrategy
{
public:
    GreenLight(void){}
    ~GreenLight(void){}
    void Operate(void){std::cout << "GreenLight" << std::endl;}
};
 
int main()
{
    context*context1 =  new context(new BackDoor());
    context1->Operate();
 
    context*context2 =  new context(new GreenLight());
    context2->Operate();
 
    return 0;
}
</code></pre>


<p>因为这个模式过于简单,<strong><strong><em>所以我们要配合其他模式使用，如果我们配合工厂模式，正好可以弥补策略模式的缺点！</em></strong></strong></p>

<p>我增加了class Policeoffice 与 class Police</p>

<p>其中class Policeoffice主要是下达具体命令的地方，这也是工厂模式的精髓！class Police封装这个工厂，并使用创造的新类执行。</p>

<h5>这个完美的弥补了策略模式，策略类太多的弊病。策略类多正好由工厂区创建！</h5>

<p><img src="/assets/pic/0551.png" alt="" /></p>

<pre><code>
#include <iostream>
#include <string>
using namespace std;
 
class IStrategy
{
public:
    IStrategy(void){};
    virtual ~IStrategy(void){};
    virtual void Operate(void) = 0;
};
 
class Context
{
public:
    Context(IStrategy *isstrategy):m_strategy(isstrategy){}
    ~Context(){}
    void Operate(void){m_strategy->Operate();}
private:
    IStrategy *m_strategy;
      
};
 
class BackDoor:public IStrategy
{
public:
    BackDoor(void){}
    ~BackDoor(void){}
    void Operate(void){std::cout <<"BackDoor" << std::endl;}
};
 
class GreenLight:public IStrategy
{
public:
    GreenLight(void){}
    ~GreenLight(void){}
    void Operate(void){std::cout << "GreenLight" << std::endl;}
};
 
class Policeoffice
{
public:
    Policeoffice(){}
    ~Policeoffice(){}
    IStrategy* getStrategy(string classname)
    {
        if(classname =="BackDoor")
            return new BackDoor();
        else if(classname =="GreenLight")
            return new GreenLight();
 
        return NULL;
    }
};
 
class Police
{
public:
    Police(){office = new Policeoffice();}
    ~Police(){delete office;}
    void PoliceDeduct(string classname)
    {       
        IStrategy *strategy = office->getStrategy(classname);
        context = new Context(strategy);
        context->Operate();
    }
private:
    Policeoffice *office;
    IStrategy *strategy;
    Context *context;
};
 
int main()
{
    Police police;
    police.PoliceDeduct("BackDoor");
 
    return 0;
}
</code></pre>


<p>设计模式不止一种，所以我们要考虑混用各种设计模式，达到解耦的效果！</p>

<h4>封装的精髓就是避免高层模块深入系统内部，这样使得系统达到高内聚，低耦合的特性。</h4>
]]></content:encoded>
    </item>
    
    <item>
      <title>Decorator Pattern with C++</title>
      <link href="http://www.lizhaozhong.info/2014/06/03/decorator-pattern-with-c.html"/>
      <pubDate>2014-06-03T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/06/03/decorator-pattern-with-c</guid>
      <content:encoded><![CDATA[<h1>装饰者模式 C++实现</h1>

<p>装饰者模式就是在原来类的基础上添加额外的功能，这种方式主要是为了应对继承带来的的类膨胀。</p>

<p>装饰者模式比起继承更加灵活，一般来说，基类是抽象的Component还有一个具体的concreteComponent。这个模式的核心就是继承Component的Decorator类。，然后由Decorator类统一管理拓展的业务，也就是新增加的功能。</p>

<h5>Decorator类中必然有一个private的Component，这个Component来执行concreteComponent的核心操作，而继承Decorator的都是负责装饰这个concreteComponent的</h5>

<p><img src="/assets/pic/decorator.png" alt="" /></p>

<pre><code>
#include <iostream>
#include <string>
using namespace std;
class Beverage
{
protected:
     string description;
public:
     virtual string getDescription() = 0;
     virtual double cost() = 0;
};
class BeverageDecorator:public Beverage
{ 
     string getDescription()
     {
      return description;
     }
};
class Mocha:public BeverageDecorator
{
     Beverage* beverage;
public:
     Mocha(Beverage *beverage)
     {
         this->beverage = beverage;
     }
     string getDescription()
     {
         return beverage->getDescription()+" Mocha";
     }
     double cost()
     {
         return beverage->cost() + 0.2;
     }
};
class Milk:public BeverageDecorator
{
     Beverage* beverage;
public:
     Milk(Beverage *beverage)
     {
         this->beverage = beverage;
     }
     string getDescription()
     {
         return beverage->getDescription()+" Milk";
     }
     double cost()
     {
      return beverage->cost() + 0.1;
     }
};
class ConcreteBeverage:public Beverage
{
public:
     ConcreteBeverage()
     {
         description = "Espresso";
     }
     string getDescription()
     {
         return description;
     }
     double cost()
     {
         return 1.99;
     }
};
void main()
{
     //买个Espresso
     Beverage * beverage1 = new ConcreteBeverage;
     cout << beverage1->getDescription() + " $ " << beverage1->cost()<< endl;
     //买个Espresso+2份Mocha+1份Milk
     Beverage * beverage2 = new ConcreteBeverage;
     beverage2 = new Mocha(beverage2);
     beverage2 = new Mocha(beverage2);
     beverage2 = new Milk(beverage2);
     cout << beverage2->getDescription() + " $ " << beverage2->cost()<< endl;
}
</code></pre>


<p>装饰者模式的优点就是：</p>

<blockquote><p>1.Decorator与concreteComponent独立，不会相互耦合。</p>

<p>2.拓展性非常好，比如我们有father son grandson ，三层继承。通过装饰者模式，我们可以抽象为两层 father son DecoratorSon.这样很好的完成了变更。</p></blockquote>

<h5>缺点就是 多层继承容易带来复杂，维护性变差。需要适度使用，否则，很难维护！</h5>

<h6>因为我用的是C++实现，所以我使用了string类型拼接，达到装饰的目的。</h6>

<h6>在Java中我们可以使用@override重写抽象类执行的核心函数和在子类中配合新添加的业务逻辑和调用super（）方法从而调用父类函数，这样达到装饰的目的。</h6>
]]></content:encoded>
    </item>
    
    <item>
      <title>Commander Pattern and Chain of Responsibility Pattern with C++</title>
      <link href="http://www.lizhaozhong.info/2014/06/03/commander-pattern-and-chain-of-responsibility-pattern-with-c.html"/>
      <pubDate>2014-06-03T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/06/03/commander-pattern-and-chain-of-responsibility-pattern-with-c</guid>
      <content:encoded><![CDATA[<h1>命令模式 责任链模式 C++实现</h1>

<p>命令模式是一种高内聚的设计模式，这种模式主要有三类角色：
1.Receiver ———–就是实际要具体执行的具体函数
2.Commander ———-执行命令的操作在这里
3.Invoker ———-他是一个调用者的角色，接受Commander然后调用Receiver
这样使得调用方和执行方二者分离开来，实现了解耦。</p>

<p>有时候Receiver与Commander会合并，但在大型的项目，三者还是分离开来的。</p>

<h6>这种模式主要是解耦类与类之间复杂的关系。</h6>

<p>其实调用树就是 Invoker -> Commander -> Receiver</p>

<p><img src="/assets/pic/4746.png" alt="" /></p>

<pre><code>
#include <iostream>
using namespace std;
  
#define SAFE_DELETE(p) if (p) { delete p; p = NULL; }
  
class Receiver
{
public:
     void Action()
     {
          cout <<"Receiver->Action"<< endl;
     }
};
  
class Command
{
public:
     virtual void Execute() = 0;
};
  
class ConcreteCommand : public Command
{
public:
     ConcreteCommand(Receiver *pReceiver) : m_pReceiver(pReceiver){}
     void Execute()
     {
          m_pReceiver->Action();
     }
private:
     Receiver *m_pReceiver;
};
  
class Invoker
{
public:
     Invoker(Command *pCommand) : m_pCommand(pCommand){}
     void Invoke()
     {
          m_pCommand->Execute();
     }
private:
     Command *m_pCommand;
};
  
int main()
{
     Receiver *pReceiver = new Receiver();
     Command *pCommand = new ConcreteCommand(pReceiver);
     Invoker *pInvoker = new Invoker(pCommand);
     pInvoker->Invoke();
     SAFE_DELETE(pInvoker);
     SAFE_DELETE(pCommand);
     SAFE_DELETE(pReceiver);
     return 0;
}
</code></pre>


<blockquote><h6>有时候，command可以和receive合在一起。这样可以减少暴露在client中的类，使得更加解耦。我们在上面可以加入setCommand（）方法达到一样的效果。但是下面这种方式，比起通用类图，使得类之前联系减少，效果更好！</h6></blockquote>

<pre><code>
class Receiver
{
public:
     void Action()
     {
          cout<<"Receiver->Action"<< endl;
     }
};
  
class Command
{
public:
     virtual void Execute() = 0;
};
  
class ConcreteCommand : public Command
{
public:
     ConcreteCommand(){m_pReceiver = new Receiver();}
     void Execute()
     {
          m_pReceiver->Action();
     }
private:
     Receiver *m_pReceiver;
};
  
class Invoker
{
public:
     Invoker(Command *pCommand) : m_pCommand(pCommand){}
     void Invoke()
     {
          m_pCommand->Execute();
     }
private:
     Command *m_pCommand;
};
  
int main()
{
     Command *pCommand = new ConcreteCommand();
     Invoker *pInvoker = new Invoker(pCommand);
     pInvoker->Invoke();
     SAFE_DELETE(pInvoker);
     SAFE_DELETE(pCommand);
     return 0;
}
</code></pre>


<p>责任链模式非常高效。
他把请求和处理分开，请求者不用担心是谁处理的，处理者如果不能处理该请求，则这个处理请求会传递给下一个处理者尝试处理。这个原理主要是通过链表对象遍历做到的。
不过需要注意的是链表对象的遍历可能导致请求一直在寻找处理者，导致性能低下。</p>

<p>总的来说都是父类实现请求传递，在子类中实现请求的·处理。</p>

<p>但是要注意：</p>

<blockquote><p>1.一个请求到链的最后可能也没有处理，所以一定要配置得当.</p>

<p>2.责任链模式并不创建责任链。责任链的创建必须由系统的其它部分创建出来。</p>

<p>3.责任链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。一个链可以是一条线，一个树，也可以是一个环。</p></blockquote>

<p><img src="/assets/pic/ClassDiagram.png" alt="" /></p>

<pre><code>
#include <iostream>
#include <string>
using namespace std;
 
class Photo 
{
public:
    Photo(string s) : mTitle(s) 
    {
    cout << "Processing " << mTitle << " ...\n";
    }
 
private:
    string mTitle;
};
 
class PhotoProcessor
{
public:
    PhotoProcessor() : mNextProcessor(0){ }
 
public:
    void process(Photo &p) 
    {
        processImplementation(p);
        if (mNextProcessor != 0) 
            mNextProcessor->process(p);
    }
 
    virtual ~PhotoProcessor() { }
 
    void setNextProcessor(PhotoProcessor *p) {
        mNextProcessor = p;
    }
 
protected:
    virtual void processImplementation(Photo &a) = 0;
 
private:
    PhotoProcessor *mNextProcessor;
};
 
class Scale : public PhotoProcessor
{
public:
    enum SCALE { S50, S100, S200, S300, S500 };
    Scale(SCALE s) : mSCALE(s) { }
 
private:
    void processImplementation(Photo &a) {
        cout << "Scaling photo\n";
    }
 
    SCALE mSCALE;
};
 
class RedEye : public PhotoProcessor
{
private:
    void processImplementation(Photo &a) {
        cout << "Removing red eye\n";
    }
};
 
class Filter : public PhotoProcessor
{
private:
    void processImplementation(Photo &a) {
        cout << "Applying filters\n";
    }
};
 
class ColorMatch : public PhotoProcessor
{
private:
    void processImplementation(Photo &a)
    {
        cout << "Matching colors\n";
    }
};
 
void processPhoto(Photo &photo)
{   
    ColorMatch match;
    RedEye eye;
    Filter filter;
    Scale scale(Scale::S200);
    scale.setNextProcessor(&eye);
    eye.setNextProcessor(&match);
    match.setNextProcessor(&filter);
// scale -> eye -> match -> filter
//也就是说scale eye match filter都保存着下一个class，这样就形成了chain of responsibility
    scale.process(photo);
}
 
int main()
{
    Photo *p = new Photo("lzz");
    processPhoto(*p);
    return 0;
}
</code></pre>

]]></content:encoded>
    </item>
    
    <item>
      <title>Mediator模式C++实现</title>
      <link href="http://www.lizhaozhong.info/2014/05/22/mediatorc.html"/>
      <pubDate>2014-05-22T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/05/22/mediatorc</guid>
      <content:encoded><![CDATA[<h1>中介者模式 C++实现</h1>

<p>中介者模式主要是为了解决类之间依赖关系的，有些类之间存在复杂的关系，这导致代码不具有可维护性。
中介者模式把这其中各类交换的函数统一放在mediator里面，每种colleague只需要和mediator交互就可以了。</p>

<p>中介者模式中，每个Colleague 维护一个 Mediator，当要进行通信时，每个具体的 Colleague 直接向 ConcreteMediator 发信息，至于信息发到哪里，则由 ConcreteMediator 来决定。</p>

<ol>
<li><p>ConcreteColleagueA 和 ConcreteColleagueB 不必维护对各自的引用，甚至它们也不知道各个的存在。</p></li>
<li><p>优点是，各个 Colleague 减少了耦合。</p></li>
</ol>


<h5>不过这种模式最大的缺点在于如果类之间交互特别复杂，容易造成class mediator体积巨大，这时我们要考虑多创建几个mediator来负责交互。</h5>

<h5>设计模式很多其实都是通过class强转成父类来产生不同的效果,比如Student -> Colleague的转换，然后通过Colleague来调用子类的函数。</h5>

<h5>C++中我们要通过Monitor(string n = “”):Colleage(n){};来实现子类通过父类够召唤术初始化。</h5>

<h5>在Java中，我们可以在构造方法中使用super（）函数，达到使用父类所有方法初始化的目的。</h5>

<p><img src="/assets/pic/03054.png" alt="" /></p>

<pre><code>
#include<iostream>
#include<string>
#include <vector>
using namespace std;

class Colleage
{
private:
    string name;
    string content;
public:
    Colleage(string n = " "):name(n){};
    void set_name(string name)
    {
        this->name = name;
    }
    string get_name()
    {
        return this->name;
    }
    void set_content(string content)
    {
        this->content = content;
    }
    string get_content()
    {
        if(content.size() != 0)
            return content;
        else return "Copy that";
    }
    virtual void talk(){};

};

class Monitor : public Colleage
{
public:
    Monitor(string n = ""):Colleage(n){};
    virtual void talk()
    {
        cout<<"Monitor "<< get_name() << " Say" << get_content()<< endl;
    }
};

class Secretary : public Colleage
{
public:
    Secretary(string n = ""):Colleage(n){};
    virtual void talk()
    {
        cout<<"Secretary "<<get_name()<<" Say"<< get_content()<< endl;
    }
};

class StudentA : public Colleage
{
public:
    StudentA(string n = ""):Colleage(n){};
    virtual void talk()
    {
        cout<<"StudentA "<<get_name()<<" Say"<< get_content()<< endl;
    }
};

class StudentB : public Colleage
{
public:
    StudentB(string n = ""):Colleage(n){};
    virtual void talk()
    {
        cout<<"StudentB "<<get_name()<<" Say"<< get_content()<< endl;
    }
};

class Mediator
{
public:
    vector<Colleage*> studentList;
    virtual void add_student(Colleage *student)
    {
        studentList.push_back(student);
    };
    virtual void notify(Colleage *student){};    
};

class QQMediator : public Mediator
{
public:
    virtual void notify(Colleage *student)
    {
        student->talk();
        for(int i = 0 ; i < studentList.size() ; ++i)
        {            
            if(student != studentList[i])
            {
                studentList[i]->talk();
            }
        }
    };  
};


int main()
{
    QQMediator mediator;
    Monitor *studentMonitor = new Monitor("studentMonitor");
    Secretary *studentSecretary = new Secretary("studentSecretary");
    StudentA *studentA = new StudentA("studentA");
    StudentB *studentB = new StudentB("studentB");        

    mediator.add_student(studentSecretary);
    mediator.add_student(studentA);
    mediator.add_student(studentB);     

    studentMonitor->set_content("It's time to end the class");
    mediator.notify(studentMonitor);   
    return 0;
}

</code></pre>



]]></content:encoded>
    </item>
    
    <item>
      <title>Proxy模式C++实现</title>
      <link href="http://www.lizhaozhong.info/2014/05/19/proxyc.html"/>
      <pubDate>2014-05-19T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/05/19/proxyc</guid>
      <content:encoded><![CDATA[<h1>代理模式 C++实现</h1>

<p>代理模式是一种常用的设计模式，他可以使得真实的角色就是实现业务的逻辑，不用关心非其本职责的实务，而是依靠后期代理实现。
这种方式可以实现解耦，让我们类的职责更加明确。
代理模式有很多种，有普通代理，强制代理，还有动态代理。</p>

<h6>普通代理模式与强制代理模式的区别在于真正实现业务的逻辑由谁创建？强制代理模式表示必须由业务者创建，普通代理则认为可以由代理者创建！</h6>

<h6>这种普通代理模式主要应用在smart_ptr中。</h6>

<p><img src="/assets/pic/55800.png" alt="" /></p>

<pre><code>
#include<iostream>
#include<string>
using namespace std;
 
class IGamePlayer
{
public:
    virtual void login(string user,string password) =0;
    virtual void killBoss()=0;
    virtual void update()=0;
};
 
class GamePlayer:public IGamePlayer
{
private :
    string name;
public:
    GamePlayer(IGamePlayer *_gameplayer,string _name)
    {
        name = _name;
        if(_gameplayer==NULL)
            cout << "_gameplayer failture" << endl;
    }
    void killBoss(){ cout << "killBoss" <<endl;}
    void login(string user,string password){ cout << user << "  "<<password <<endl;}
    void update(){ cout << "update!" <<endl; }
};
 
class GamePlayerProxy:public IGamePlayer
{
private:
    IGamePlayer *gameplayer;
public:
    GamePlayerProxy(string name)
    {
        gameplayer = new GamePlayer(this,name);
        if(gameplayer ==NULL)
            cout << "Create failture!" << endl;
    }
    void killBoss() {gameplayer->killBoss();}
    void login(string user,string password){gameplayer->login(user,password);}
    void update(){gameplayer->update();}
};
 
int main()
{
    IGamePlayer *proxy = new GamePlayerProxy("user1");
    proxy->login("lzz","lzz");
    proxy->killBoss();
    proxy->update();
    delete proxy;
    return 0;
}
</code></pre>


<h3>强制代理与普通代理的不同在于业务函数必须由业务类制剂创建！并由业务类返回代理者！</h3>

<pre><code>
#include<iostream>
#include<string>
using namespace std;
 
 
class IGamePlayer
{
public:
    virtual void login(string user,string password) =0;
    virtual void killBoss()=0;
    virtual void update()=0;
    virtual IGamePlayer* getProxy()=0;
};
 
class GamePlayerProxy:public IGamePlayer
{
private:
    IGamePlayer *gameplayer;
public:
    GamePlayerProxy(IGamePlayer *_gameplayer)
    {
        this->gameplayer = _gameplayer;
    }
    void killBoss() {this->gameplayer->killBoss();}
    void login(string user,string password){this->gameplayer->login(user,password);}
    void update(){this->gameplayer->update();}
    IGamePlayer* getProxy(){ return this;}
};
 
class GamePlayer:public IGamePlayer
{
private :
    string name;
    IGamePlayer *Proxy;
    bool isProxy()
    {
        if(Proxy==NULL)
            return false;
        else
            return true;
    }
public:
    GamePlayer(string _name)
    {
        name = _name;
    }
    IGamePlayer* getProxy()
    {
        this->Proxy = new GamePlayerProxy(this);
        return Proxy;
    }
    void killBoss(){ if(isProxy())cout << "killBoss" <<endl;}
    void login(string user,string password){ if(isProxy()) cout << user << "  "<<password <<endl;}
    void update(){ if(isProxy())cout << "update!" <<endl; }
 
};
 
int main()
{
    IGamePlayer *player = new GamePlayer("user1");
    IGamePlayer *proxy = player->getProxy();
    proxy->login("lzz","lzz");
    proxy->killBoss();
    proxy->update();
    delete proxy;
    return 0;
}
</code></pre>


<p>还有一种动态代理的模式，主要用在Java中，动态代理在实现阶段不在乎代理谁，而主要在运行阶段才真正的代理。</p>

<p>handler只需要继承InvocationHandler即可，然后再invoke（）中返回要调用的方法或者函数。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Protype_IteratorC++实现</title>
      <link href="http://www.lizhaozhong.info/2014/05/19/protype_iteratorc.html"/>
      <pubDate>2014-05-19T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/05/19/protype_iteratorc</guid>
      <content:encoded><![CDATA[<h1>原型模式 迭代器模式 C++实现</h1>

<p>原型模式其实非常简单，难易程度其实就是单例模式与迭代器模式差不多。
在Java中我们可以有很多的接口使用，在这里，我们也许会用到Cloneable接口，然后在复制的类里面实现clone方法。</p>

<h5>调用这个clone（）就等于完成了类的复制，而不是通过new来创建。Clone（）方法是在内存中进行拷贝，所以不会调用构造函数！</h5>

<p>final与clone不共融，final使用后，就意味着无法进行重写，而调用clone（）必须重写！</p>

<p>我们知道在OO语言中，有深拷贝与浅拷贝之分。浅拷贝只拷贝类对象，类里面的数组都共享一份，这期中就有潜在的风险。而深拷贝则是完全将对象拷贝两份，也就是说内存中含有两份一模一样的对象！</p>

<h5>扯完Java，我来用C++实现原型模式，C++中没有什么clone接口，所以我们完全要手动来做。</h5>

<blockquote><p>这里有个小插曲：
因为我是在vs2012中编译的。目前vs2012已经把strcpy函数禁用掉，因为存在不安全性。</p></blockquote>

<p><img src="/assets/pic/70658.png" alt="" /></p>

<p>正如之前爆出的heartbleed漏洞，也是未对字符串赋值进行检查导致，所以我们这里使用strcpy_s()不过这样确实丧失了移植性。需要注意一下。
如果我们不需要这种提醒，可以在设置中把预编译检查关闭！</p>

<p><img src="/assets/pic/71649.png" alt="" /></p>

<pre><code>
#include<iostream>
#include<string>
using namespace std;
 
 
class Mail
{
public:
    Mail(){};
    virtual Mail* Clone(){return NULL;}
    virtual void show() =0;
    char *getstr(){return name;}
protected:
    char* name;
};
 
class MailA :public Mail
{
public:
    MailA(char *str)
    {
        if(str==NULL){      name = new char[10];    name[9]='\0';}
        else{name = new char[strlen(str)+1]; strcpy_s(name,10,str);}
    }
    ~MailA(){delete name;}
    MailA(Mail &r){     name = new char[strlen(r.getstr())+1]; strcpy_s(name,strlen(r.getstr())+1,r.getstr());  }
    Mail* Clone(){return (Mail *)new MailA(*this);}
    void show(){cout << name << endl;}
};
 
class MailB :public Mail
{
public:
    MailB(char *str)
    {
        if(str==NULL){      name = new char[10];    name[9]='\0';}
        else{name = new char[strlen(str)+1]; strcpy_s(name,10,str);}
    }
    ~MailB(){delete name;}
    MailB(Mail &r){     name = new char[strlen(r.getstr())+1]; strcpy_s(name,strlen(r.getstr())+1,r.getstr());  }
    Mail* Clone(){return (Mail *)new MailB(*this);}
    void show(){cout << name << endl;}
};
 
int main()
{
    Mail *m1 = new MailA("A");
    Mail *m2 = new MailB("B");
    Mail *m3 = m1->Clone();
    Mail *m4 = m2->Clone();
    m1->show(); m2->show(); //删除m1,m2  
    delete m1; delete m2;     
    m1 = m2 = NULL;  
 
    //深拷贝所以对m3,m4无影响  
    m3->show(); m4->show();  
    delete m3; delete m4;  
    m3 = m4 = NULL;  
}
</code></pre>


<h5>迭代器模式如STL，通过容器来管理复杂的数据结构，类等。然后通过iteration来迭代，俗称迭代器模式。</h5>

<p>在Java中有现成的迭代器来使用，在C++中，我们需要自己实现这种接口iterator。</p>

<p><img src="/assets/pic/3617.png" alt="" /></p>

<pre><code>
#include<iostream>
#include<string>
#include <vector>
using namespace std;
 
template <class T>
class Iterator
{
public:
    virtual void first()=0;
    virtual void next()=0;
    virtual T* currentItem()=0;
    virtual bool isEnd()=0;
    virtual ~Iterator(){}
};
 
template <class T>
class RealSet;
 
template <class T>
class RealIterator:public Iterator <T>
{
private:
    RealSet<T> *rset;
    int cur_ptr;
public:
    RealIterator(RealSet<T> *a):rset(a),cur_ptr(0){}
    void first(){cur_ptr=0;}
    void next(){if(cur_ptr < rset->getlen() ) cur_ptr++;}
    T* currentItem()
    {
        if(cur_ptr <rset->getlen())   return &(*rset)[cur_ptr];
        else return NULL;
    }
    bool isEnd()
    {
        if(cur_ptr >=rset->getlen())return false;
        return true;
    }
};
 
template <class T>
class Set
{
public:
    virtual Iterator<T>* createIterator()=0;
    virtual void push(T a)=0;
    virtual ~Set(){}
};
 
template <class T>
class RealSet:public Set<T>
{
private:
    vector<T> data;
public:
    RealSet(){}
    ~RealSet(){}
    virtual Iterator<T>* createIterator(){ return new RealIterator<T>(this);}
    virtual T& operator[](int index){return data[index];}
    int getlen(){return data.size();}
    void push(T a)
    {
        data.push_back(a);
    }
};
 
int main()
{
    Set<double> *set = new RealSet<double>();
    Iterator<double> *iter = set->createIterator();
    set->push(3.22);
    set->push(1.86);
    set->push(0.88);
 
    for(iter->first();iter->isEnd();iter->next())
    {
        cout << *iter->currentItem() << endl;
    }
    delete iter;
    delete set;
    return 0;
}
</code></pre>


<h6>确实这种template编程很难，我调试了一下好久才找到问题所在。。。。。。</h6>
]]></content:encoded>
    </item>
    
    <item>
      <title>Template_Builder_DesignPattern</title>
      <link href="http://www.lizhaozhong.info/2014/05/13/template_builder_designpattern.html"/>
      <pubDate>2014-05-13T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/05/13/template_builder_designpattern</guid>
      <content:encoded><![CDATA[<h1>模板方法模式 建造者模式 C++实现</h1>

<p>今天我继续来填坑，模板方法模式就是在模板方法中按照一定的规则顺序调用基本方法。这个比较简单。</p>

<p>比如我在父类run（）中调用类中一系列的方法。钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它。</p>

<p><strong><em>Java中，如果父类里面有些方法不允许覆写，那么为了防止子类改变模板方法中的算法，可以将模板方法声明为final。</em></strong></p>

<p><img src="/assets/pic/IMG_0432.jpg" alt="" /></p>

<pre><code>
#include <iostream>
using namespace std;
 
class CarTemplate
{
public:
    CarTemplate(void){};
    virtual ~CarTemplate(void){};
 
protected:
    virtual void Start() = 0;
    virtual void Stop() = 0;
    virtual void Alarm() = 0;
    virtual void EngineBoom() = 0;
    virtual bool IsAlarm() =0;
 
public:
        void Run()
        {
        Start();
 
        EngineBoom();
 
        if(IsAlarm())
            Alarm();
 
        Stop();
        };
};
 
class Hummer: public CarTemplate
{
public:
    Hummer(){m_isAlarm = true;}
    virtual ~Hummer(){};
 
protected:
    void Start(){   cout<< "Hummer Start" << endl;   }
    void Stop(){    cout<< "Hummer Stop" << endl;    }
    void Alarm(){   cout<< "Hummer Alarm" << endl;}
    bool IsAlarm(){ return m_isAlarm;       }
    void EngineBoom(){  cout<< "Hummer EngineBoom" << endl;  }
private:
    bool m_isAlarm;
};
 
class Benz: public CarTemplate
{
public:
    Benz(){m_isAlarm = false;}
    virtual ~Benz(){};
 
protected:
    void Start(){   cout<< "Benz Start" << endl; }
    void Stop(){    cout<< "Benz Stop" << endl;  }
    void Alarm(){   cout<< "Benz Alarm" << endl;}
    bool IsAlarm(){ return m_isAlarm;       }
    void EngineBoom(){  cout<< "Benz EngineBoom" << endl;    } 
private:     
        bool m_isAlarm; 
}; 

int main() 
{   
        CarTemplate *hummer = new Hummer();     
        hummer->Run();
    delete  hummer;
 
    CarTemplate *benz = new Benz();
    benz->Run();
    delete benz;
}
</code></pre>


<p>优点就在于可以封装不变的部分，拓展可变的部分，也就是把共性的东西抽取出来，这样可以便于维护。</p>

<p>但是缺点在于子类的执行，影响到父类的结果。有时候会有一些晦涩难懂。
———————————————————————————————-</p>

<p><strong><em>在模板方法中，我们把相同的都封装在父类中，不同都定义在子类中。但是需求的变化是无穷无尽的。</em></strong></p>

<blockquote><p>比如建造的顺序可能是变化的，所以将他放到builder类中，通过builder类获取真正的product！</p></blockquote>

<p><img src="/assets/pic/6446jgG.gif" alt="" /></p>

<pre><code>
class Builder
{
public:
    virtual void BuildHead() {}
    virtual void BuildBody() {}
    virtual void BuildLeftArm(){}
    virtual void BuildRightArm() {}
    virtual void BuildLeftLeg() {}
    virtual void BuildRightLeg() {}
};
//构造瘦人
class ThinBuilder:public Builder
{
public:
    void BuildHead() { cout<< "build thin body" << endl; }
    void BuildBody() { cout<< "build thin head" << endl; }
    void BuildLeftArm() { cout<< "build thin leftarm" << endl; }
    void BuildRightArm() { cout<< "build thin rightarm" << endl; }
    void BuildLeftLeg() { cout<< "build thin leftleg" << endl; }
    void BuildRightLeg() { cout<< "build thin rightleg" << endl; }
};
//构造胖人
class FatBuilder : public Builder
{
public:
    void BuildHead() { cout<<"build fat body"<< endl; }
    void BuildBody() { cout<<"build fat head"<< endl; }
    void BuildLeftArm() { cout<<"build fat leftarm"<< endl; }
    void BuildRightArm() { cout<<"build fat rightarm"<< endl; }
    void BuildLeftLeg() { cout<<"build fat leftleg"<< endl; }
    void BuildRightLeg() { cout<<"build fat rightleg"<< endl; }   
};   //构造的指挥官   

class Director     {   
private:       
    Builder *m_pBuilder;   
public:       
    Director(Builder *builder) { m_pBuilder = builder; }       
    void Create()
    {           
        m_pBuilder->BuildHead();
        m_pBuilder->BuildBody();
        m_pBuilder->BuildLeftArm();
        m_pBuilder->BuildRightArm();
        m_pBuilder->BuildLeftLeg();
        m_pBuilder->BuildRightLeg();
    }
};
 
int main()
{
    FatBuilder fat;
    Director director(&fat);
    director.Create();
---------------------------------------------------------------------------
    Builder *thin = new ThinBuilder();
    Director *dir = new Director(thin);
    dir->Create();
 
    return 0;
}
</code></pre>


<p><strong><em>建造者模式的优点：在于我们不用关心每个产品内部的组成细节，比如FatBuildier ThinBuilider，然后我们交给Director来构造就好了。</em></strong></p>

<p>建造者是独立的，我们可以拓展更多的builder完成不同的功能。并不对系统有任何影响。</p>

<p><strong>_特别适合产品类特别复杂，顺序不同，效能不同。顺序是区别模板模式与建造者模式最大的不同点！</strong></p>

<blockquote><p>另外同工厂模式进行比较，工厂模式适合生产零件。不能再细分了。否则就不适合工厂模式。</p></blockquote>

<h5>把模板方式和建造者模式组合起来可以产生很好的效果，可以按照model通过builder批量生产某种特定型号的产品。</h5>

<p><img src="/assets/pic/IMG_0433.jpg" alt="" /></p>

<pre><code>
#include<iostream>
#include<vector>
#include<string>
using namespace std;

class CCarModel
{
public:
    CCarModel(void) {}
    virtual ~CCarModel(void){}
    void Run()
    {
            vector::const_iterator it = m_pSequence->begin();
        for (; it < m_pSequence->end(); ++it)
        {
            string actionName = *it;
            if(actionName.compare("start") == 0)
            {
                Start();
            }
            else if(actionName.compare("stop") == 0)
            {
                Stop();
            }
            else if(actionName.compare("alarm") == 0)
            {
                Alarm();
            }
            else if(actionName.compare("engine boom") == 0)
            {
                EngineBoom();
            }
        }
    }
    void SetSequence(vector *pSeq)
    {
            m_pSequence = pSeq;
    }
protected:
    virtual void Start() = 0;
    virtual void Stop() = 0;
    virtual void Alarm() = 0;
    virtual void EngineBoom() = 0;
private:
    vector * m_pSequence;
};

class CBenzModel : public CCarModel
{
public:
    CBenzModel(void){}
    ~CBenzModel(void){}
protected:
    void Start(){cout << "Benz Start..." << endl;}
    void Stop(){cout << "Benz Stop..." << endl;}
    void Alarm(){cout << "Benz Alarm" << endl;}
    void EngineBoom(){cout << "Benz EngineBoom...." << endl;}
};

class CBMWModel : public CCarModel
{
public:
    CBMWModel(void){}
    ~CBMWModel(void){}
protected:
    void Start(){cout << "BMW Start..." << endl;}
    void Stop(){cout << "BMW Stop..." << endl;}
    void Alarm(){cout << "BMW Alarm" << endl;}
    void EngineBoom(){cout << "BMW EngineBoom...." << endl;}
};

class ICarBuilder
{
public:
    ICarBuilder(void)   { }
    virtual ~ICarBuilder(void)  { }
    virtual void SetSequence(vector *pseq) = 0;
    virtual CCarModel * GetCarModel() = 0;
};

class CBenzBuilder : public ICarBuilder
{
public:
    CBenzBuilder(void);
    ~CBenzBuilder(void);
    void SetSequence(vector *pSeq);
    CCarModel * GetCarModel();
private:
    CCarModel *m_pBenz;
};
CBenzBuilder::CBenzBuilder(void)
{
    m_pBenz = new CBenzModel();
}
CBenzBuilder::~CBenzBuilder(void)
{
    delete m_pBenz;
}
void CBenzBuilder::SetSequence(vector *pSeq)
{
    m_pBenz->SetSequence(pSeq);
}
CCarModel * CBenzBuilder::GetCarModel()
{
    return m_pBenz;
}

class CBMWBuilder :public ICarBuilder
{
public:
    CBMWBuilder(void);
    ~CBMWBuilder(void);
    void SetSequence(vector *pSeq);
    CCarModel * GetCarModel();
private:
    CCarModel *m_pBMW;
};

CBMWBuilder::CBMWBuilder(void)
{
    m_pBMW = new CBMWModel();
}
CBMWBuilder::~CBMWBuilder(void)
{
    delete m_pBMW;
}
void CBMWBuilder::SetSequence( vector *pSeq )
{
    m_pBMW->SetSequence(pSeq);
}
CCarModel * CBMWBuilder::GetCarModel()
{
    return m_pBMW;
}

class CDirector
{
public:
    CDirector(void);
    ~CDirector(void);
    CBenzModel * GetABenzModel();
    CBenzModel * GetBBenzModel();
    CBMWModel * GetCBMWModel();
    CBMWModel * GetDBMWModel();
private:
    vector * m_pSeqence;
    CBenzBuilder * m_pBenzBuilder;
    CBMWBuilder * m_pBMWBuilder;
};

CDirector::CDirector(void)
{
    m_pBenzBuilder = new CBenzBuilder();
    m_pBMWBuilder = new CBMWBuilder();
    m_pSeqence = new vector();
}
CDirector::~CDirector(void)
{
    delete m_pBenzBuilder;
    delete m_pBMWBuilder;
    delete m_pSeqence;
}
CBenzModel * CDirector::GetABenzModel()
{
    m_pSeqence->clear();
    m_pSeqence->push_back("start");
    m_pSeqence->push_back("stop");
    m_pBenzBuilder->SetSequence(m_pSeqence);
    return dynamic_cast<CBenzModel*>(m_pBenzBuilder->GetCarModel());
}
CBenzModel * CDirector::GetBBenzModel()
{
    m_pSeqence->clear();
    m_pSeqence->push_back("engine boom");
    m_pSeqence->push_back("start");
    m_pSeqence->push_back("stop");
    m_pBenzBuilder->SetSequence(m_pSeqence);
    return dynamic_cast<CBenzModel*>(m_pBenzBuilder->GetCarModel());
}
CBMWModel * CDirector::GetCBMWModel()
{
    m_pSeqence->clear();
    m_pSeqence->push_back("alarm");
    m_pSeqence->push_back("start");
    m_pSeqence->push_back("stop");
    m_pBMWBuilder->SetSequence(m_pSeqence);
    return static_cast<CBMWModel*>(m_pBMWBuilder->GetCarModel());
}
CBMWModel * CDirector::GetDBMWModel()
{
    m_pSeqence->clear();
    m_pSeqence->push_back("start");
    m_pBenzBuilder->SetSequence(m_pSeqence);
    return dynamic_cast<CBMWModel*>(m_pBMWBuilder->GetCarModel());
}
int main(int argc, char const *argv[])
{
    CDirector *dir = new CDirector();

    dir->GetBBenzModel()->Run();
    return 0;
}


</code></pre>


<p>通过上面可以看出两个模式的配合得到了很好的运用！</p>

<p>引用 http://blog.csdn.net/wuzhekai1985/article/details/6667467</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Unix_Thread_API备注</title>
      <link href="http://www.lizhaozhong.info/2014/05/07/unix_thread_api.html"/>
      <pubDate>2014-05-07T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/05/07/unix_thread_api</guid>
      <content:encoded><![CDATA[<h1>Unix Thread API备注</h1>

<p>这是最近读unix pthread and process使用的注意事项。</p>

<p>fork（）可以创建子进程，这个函数返回两次，通过返回值来判断是父进程还是子进程。fork时子进程获得父进程数据空间、堆和栈的复制，所以变量的地址（当然是虚拟地址）也是一样的。但是需要了解的是我们要分开虚拟地址和物理地址，两个进程虚拟地址可以相同，但是物理地址不同。</p>

<blockquote><p><strong><em>出于效率考虑，linux中引入了“写时复制“（Copy on Write）技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</em></strong></p></blockquote>

<p>但是会把父子共享的页面标记为“只读”（类似mmap的private的方式），如果父子进程一直对这个页面是同一个页面，知道其中任何一个进程要对共享的页面“写操作”，这时内核会复制一个物理页面给这个进程使用，同时修改页表。而把原来的只读页面标记为“可写”，留给另外一个进程使用。</p>

<p><strong>_同时注意stdin stdout是行缓冲，也就意味着子进程会复制父进程输入输出的内容。fork（）函数前的printf（）部分也会复制！</strong></p>

<pre><code>
while (1) {
    connfd = Accept(listenfd, (SA *) &clientaddr, &clientlen);
    if (Fork() == 0) {
        Close(listenfd); /* Child closes its listening socket */
        echo(connfd);    /* Child services client */
        Close(connfd);   /* Child closes connection with client */
        exit(0);         /* Child exits */
    }
    Close(connfd); /* Parent closes connected socket (important!) */
    }
</code></pre>


<p>这个就是返回子进程要先关闭父进程的监听套接字，因为子进程复制了父进程的变量，套接字也是一个道理！</p>

<p>pthread_t pthread_self(void); 函数作用：获得线程自身的ID。</p>

<p>void pthread_exit(void *thread_return) 终止所有线程，父进程先等待子线程退出，然后父进程退出</p>

<p>void pthread_cancel(tid)退出当前线程</p>

<p>int pthread_join(tid,void **return)</p>

<p>int pthread_detach(tid)
编程当中可以用pthread_self返回当前线程的tid。</p>

<p>创建一个线程默认的状态是joinable, 如果一个线程结束运行但没有被join,则它的状态类似于进程中的Zombie Process,即还有一部分资源没有被回收（退出状态码），所以创建线程者应该调用pthread_join来等待线程运行结束，并可得到线程的退出代码，回收其资源（类似于wait,waitpid)
但是调用pthread_join(pthread_id)后，如果该线程没有运行结束，调用者会被阻塞，在有些情况下我们并不希望如此.</p>

<p><strong>比如在Web服务器中当主线程为每个新来的链接创建一个子线程进行处理的时候，主线程并不希望因为调用pthread_join而阻塞（因为还要继续处理之后到来的链接），这时可以在子线程中加入代码pthread_detach(pthread_self())</strong></p>

<p>或者父线程调用</p>

<p><strong>pthread_detach(thread_id)（非阻塞，可立即返回）这将该子线程的状态设置为detached,则该线程运行结束后会自动释放所有资源。</strong></p>

<p>在web服务器里面，线程有同步问题。</p>

<pre><code>
void sbuf_insert(sbuf_t *sp, int item)
{
    P(&sp->slots);                          /* Wait for available slot */
    P(&sp->mutex);                          /* Lock the buffer */
    sp->buf[(++sp->rear)%(sp->n)] = item;   /* Insert the item */
    V(&sp->mutex);                          /* Unlock the buffer */
    V(&sp->items);                          /* Announce available item */
}
 
int sbuf_remove(sbuf_t *sp)
{
    int item;
    P(&sp->items);                          /* Wait for available item */
    P(&sp->mutex);                          /* Lock the buffer */
    item = sp->buf[(++sp->front)%(sp->n)];  /* Remove the item */
    V(&sp->mutex);                          /* Unlock the buffer */
    V(&sp->slots);                          /* Announce available slot */
    return item;
}
....................
for (i = 0; i < NTHREADS; i++)  
    Pthread_create(&tid, NULL, thread, NULL);//创建了大量的thread线程，但是sbuf_remove(&sbuf)相当于V（）操作，如果临界值小宇0，那么阻塞！
 
    while (1) { 
    connfd = Accept(listenfd, (SA *) &clientaddr, &clientlen);
    sbuf_insert(&sbuf, connfd); /* 这里面包含了锁，涉及的PV操作 ，相当于P()，临界值＋1*/
    }
}
 
void *thread(void *vargp) 
{  
    Pthread_detach(pthread_self()); 
    while (1) { 
    int connfd = sbuf_remove(&sbuf); /* Remove connfd from buffer */
    echo_cnt(connfd);                
    Close(connfd);
    }
}
</code></pre>

]]></content:encoded>
    </item>
    
    <item>
      <title>Factory_DesignPattern</title>
      <link href="http://www.lizhaozhong.info/2014/05/03/factory_designpattern.html"/>
      <pubDate>2014-05-03T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/05/03/factory_designpattern</guid>
      <content:encoded><![CDATA[<h1>三种工厂模式的C++实现</h1>

<p>最近想换换口味，于是抱起久违的design pattern漫画书品读起来。
工厂模式属于创建型模式，大致可以分为三类，简单工厂模式、工厂方法模式、抽象工厂模式。</p>

<p>首先介绍简单工厂模式，它的主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类。
缺点：对修改不封闭，新增加产品您要修改工厂。违法了鼎鼎大名的开闭法则（OCP）。</p>

<p><img src="/assets/pic/SingleFactory.png" alt="" />
下面的代码，由于插件有些问题，导致无法在网页显示，我将尽快修复！</p>

<pre><code>
#include <iostream>
using namespace std;
 
enum TYPE{COREA,COREB};

class SingleCore
{
    public:
        virtual ~SingleCore(){};
        virtual void Show() = 0;
};
 
class CoreA:public SingleCore
{
    public:
        void Show()
        {
            cout<< "CoreA"<< endl;
        }
};
class CoreB:public SingleCore
{
    public:
        void Show()
        {
            cout <<"CoreB"<< endl;
        }
};
 
class SingleFactory
{
    public:
        SingleCore* CreateSingleCore(enum TYPE type)
        {
            if(type==COREA)
                return new CoreA();
            else if(type==COREB)
                return new CoreB();
            else 
                return NULL;
        }
};
 
 
int main()
{
    SingleFactory factory;
    SingleCore  *pcorea = factory.CreateSingleCore(COREA);
    pcorea->Show();
    SingleCore  *pcoreb = factory.CreateSingleCore(COREB);
    pcoreb->Show();
 
    delete pcorea;
    delete pcoreb;
}
</code></pre>


<p>工厂方法模式的应用并不是只是为了封装对象的创建，而是要把对象的创建放到子类中实现：Factory中只是提供了对象创建的接口，其实现将放在Factory的子类Factory中进行。
工厂方法模式也有缺点，每增加一种产品，就需要增加一个对象的工厂。</p>

<p><img src="/assets/pic/Factory.png" alt="" /></p>

<pre><code>

#include <iostream>
using namespace std;
 
 
class SingleCore
{
    public:
        virtual ~SingleCore(){};
        virtual void Show() = 0;
};
 
class CoreA:public SingleCore
{
    public:
        void Show()
        {
            cout<< "CoreA"<< endl;
        }
};
class CoreB:public SingleCore
{
    public:
        void Show()
        {
            cout <<"CoreB"<< endl;
        }
};
 
class SingleFactory
{
    public:
        virtual SingleCore* CreateSingleCore() = 0;
};
class FactoryA:public SingleFactory
{
    public:
        SingleCore* CreateSingleCore()
        {
            return new CoreA;
        }
};
 
class FactoryB:public SingleFactory
{
    public:
        SingleCore* CreateSingleCore()
        {
            return new CoreB;
        }
};
 
 
int main()
{
    FactoryA factorya;
    SingleCore  *pcorea = factorya.CreateSingleCore();
    pcorea->Show();
 
    FactoryB factoryb;
    SingleCore  *pcoreb = factoryb.CreateSingleCore();
    pcoreb->Show();
 
    delete pcorea;
    delete pcoreb;
}
</code></pre>


<p>抽象工厂模式登场了。它的定义为提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
抽象工厂模式的组成（和工厂方法模式一样）：</p>

<p>1)抽象工厂角色：这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。</p>

<p>2)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。</p>

<p>3)抽象产品角色：它是具体产品继承的父类或者是实现的接口。</p>

<p>4)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。</p>

<p><img src="/assets/pic/AbstractFactory.png" alt="" /></p>

<pre><code>

#include <iostream>
using namespace std;
 
 
class SingleCore
{
    public:
        virtual ~SingleCore();
        virtual void Show() = 0;
};
 
class CoreA:public SingleCore
{
    public:
        void Show()
        {
            cout<< "CoreA"<< endl;
        }
};

class CoreB:public SingleCore
{
    public:
        void Show()
        {
            cout <<"CoreB"<< endl;
        }
};
//-------------------------------------------------------
class MultiCore
{
    public:
        virtual void Show() = 0;
        virtual ~MultiCore(){};
};
 
class MultiCoreA:public MultiCore
{
    public:
        void Show()
        {
            cout<<"MultiCoreA"<< endl;
        }
};
 
class MultiCoreB:public MultiCore
{
    public:
        void Show()
        {   
            cout<<"MultiCoreB"<< endl;
        }   
};
//----------------------------------------------------------
class CoreFactory
{
    public:
        virtual SingleCore* CreateSingleCore() = 0;
        virtual MultiCore* CreateMultiCore() = 0;
};
class FactoryA:public CoreFactory
{
    public:
        SingleCore* CreateSingleCore()
        {
            return new CoreA();
        }
        MultiCore* CreateMultiCore()
        {
            return new MultiCoreA();
        }
};
 
class FactoryB:public CoreFactory
{
    public:
        SingleCore* CreateSingleCore()
        {
            return new CoreB();
        }
        MultiCore* CreateMultiCore()
        {
            return new MultiCoreB();
        }
 
};
 
 
int main()
{
    FactoryA factorya;
    SingleCore  *pcorea = factorya.CreateSingleCore();
    pcorea->Show();
 
    MultiCore   *pmulticorea = factorya.CreateMultiCore();
    pmulticorea->Show();
 
    FactoryB factoryb;
    SingleCore  *pcoreb = factoryb.CreateSingleCore();
    pcoreb->Show();
 
    MultiCore   *pmulticoreb = factoryb.CreateMultiCore();
    pmulticoreb->Show();
 
    delete pcorea;
    delete pcoreb;
    delete pmulticorea;
    delete pmulticoreb;
}

</code></pre>


<p>后续我会学习其他设计模式。并贴出C++代码实现。</p>

<p>参考：http://blog.csdn.net/silangquan/article/details/20492293</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
