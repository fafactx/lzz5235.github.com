<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>JasonLe's Blog |HomePage</title>
    <link href="http://www.lizhaozhong.info/feed/" rel="self" />
    <link href="http://www.lizhaozhong.info" />
    <lastBuildDate>2014-05-22T20:07:05+08:00</lastBuildDate>
    <webMaster>ldm5235@gmail.com</webMaster>
    
    <item>
      <title>Mediator模式C++实现</title>
      <link href="http://www.lizhaozhong.info/2014/05/22/mediatorc.html"/>
      <pubDate>2014-05-22T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/05/22/mediatorc</guid>
      <content:encoded><![CDATA[<h1>中介者模式 C++实现</h1>

<p>中介者模式主要是为了解决类之间依赖关系的，有些类之间存在复杂的关系，这导致代码不具有可维护性。
中介者模式把这其中各类交换的函数统一放在mediator里面，每种colleague只需要和mediator交互就可以了。</p>

<p>中介者模式中，每个Colleague 维护一个 Mediator，当要进行通信时，每个具体的 Colleague 直接向 ConcreteMediator 发信息，至于信息发到哪里，则由 ConcreteMediator 来决定。</p>

<ol>
<li><p>ConcreteColleagueA 和 ConcreteColleagueB 不必维护对各自的引用，甚至它们也不知道各个的存在。</p></li>
<li><p>优点是，各个 Colleague 减少了耦合。</p></li>
</ol>


<h5>不过这种模式最大的缺点在于如果类之间交互特别复杂，容易造成class mediator体积巨大，这时我们要考虑多创建几个mediator来负责交互。</h5>

<h5>设计模式很多其实都是通过class强转成父类来产生不同的效果,比如Student -> Colleague的转换，然后通过Colleague来调用子类的函数。</h5>

<h5>C++中我们要通过Monitor(string n = “”):Colleage(n){};来实现子类通过父类够召唤术初始化。</h5>

<h5>在Java中，我们可以在构造方法中使用super（）函数，达到使用父类所有方法初始化的目的。</h5>

<p><img src="/assets/pic/03054.png" alt="" /></p>

<pre><code>
#include<iostream>
#include<string>
#include <vector>
using namespace std;

class Colleage
{
private:
    string name;
    string content;
public:
    Colleage(string n = " "):name(n){};
    void set_name(string name)
    {
        this->name = name;
    }
    string get_name()
    {
        return this->name;
    }
    void set_content(string content)
    {
        this->content = content;
    }
    string get_content()
    {
        if(content.size() != 0)
            return content;
        else return "Copy that";
    }
    virtual void talk(){};

};

class Monitor : public Colleage
{
public:
    Monitor(string n = ""):Colleage(n){};
    virtual void talk()
    {
        cout<<"Monitor "<< get_name() << " Say" << get_content()<< endl;
    }
};

class Secretary : public Colleage
{
public:
    Secretary(string n = ""):Colleage(n){};
    virtual void talk()
    {
        cout<<"Secretary "<<get_name()<<" Say"<< get_content()<< endl;
    }
};

class StudentA : public Colleage
{
public:
    StudentA(string n = ""):Colleage(n){};
    virtual void talk()
    {
        cout<<"StudentA "<<get_name()<<" Say"<< get_content()<< endl;
    }
};

class StudentB : public Colleage
{
public:
    StudentB(string n = ""):Colleage(n){};
    virtual void talk()
    {
        cout<<"StudentB "<<get_name()<<" Say"<< get_content()<< endl;
    }
};

class Mediator
{
public:
    vector<Colleage*> studentList;
    virtual void add_student(Colleage *student)
    {
        studentList.push_back(student);
    };
    virtual void notify(Colleage *student){};    
};

class QQMediator : public Mediator
{
public:
    virtual void notify(Colleage *student)
    {
        student->talk();
        for(int i = 0 ; i < studentList.size() ; ++i)
        {            
            if(student != studentList[i])
            {
                studentList[i]->talk();
            }
        }
    };  
};


int main()
{
    QQMediator mediator;
    Monitor *studentMonitor = new Monitor("studentMonitor");
    Secretary *studentSecretary = new Secretary("studentSecretary");
    StudentA *studentA = new StudentA("studentA");
    StudentB *studentB = new StudentB("studentB");        

    mediator.add_student(studentSecretary);
    mediator.add_student(studentA);
    mediator.add_student(studentB);     

    studentMonitor->set_content("It's time to end the class");
    mediator.notify(studentMonitor);   
    return 0;
}

</code></pre>



]]></content:encoded>
    </item>
    
    <item>
      <title>Proxy模式C++实现</title>
      <link href="http://www.lizhaozhong.info/2014/05/19/proxyc.html"/>
      <pubDate>2014-05-19T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/05/19/proxyc</guid>
      <content:encoded><![CDATA[<h1>代理模式 C++实现</h1>

<p>代理模式是一种常用的设计模式，他可以使得真实的角色就是实现业务的逻辑，不用关心非其本职责的实务，而是依靠后期代理实现。
这种方式可以实现解耦，让我们类的职责更加明确。
代理模式有很多种，有普通代理，强制代理，还有动态代理。</p>

<h6>普通代理模式与强制代理模式的区别在于真正实现业务的逻辑由谁创建？强制代理模式表示必须由业务者创建，普通代理则认为可以由代理者创建！</h6>

<h6>这种普通代理模式主要应用在smart_ptr中。</h6>

<p><img src="/assets/pic/55800.png" alt="" /></p>

<pre><code>
#include<iostream>
#include<string>
using namespace std;
 
class IGamePlayer
{
public:
    virtual void login(string user,string password) =0;
    virtual void killBoss()=0;
    virtual void update()=0;
};
 
class GamePlayer:public IGamePlayer
{
private :
    string name;
public:
    GamePlayer(IGamePlayer *_gameplayer,string _name)
    {
        name = _name;
        if(_gameplayer==NULL)
            cout << "_gameplayer failture" << endl;
    }
    void killBoss(){ cout << "killBoss" <<endl;}
    void login(string user,string password){ cout << user << "  "<<password <<endl;}
    void update(){ cout << "update!" <<endl; }
};
 
class GamePlayerProxy:public IGamePlayer
{
private:
    IGamePlayer *gameplayer;
public:
    GamePlayerProxy(string name)
    {
        gameplayer = new GamePlayer(this,name);
        if(gameplayer ==NULL)
            cout << "Create failture!" << endl;
    }
    void killBoss() {gameplayer->killBoss();}
    void login(string user,string password){gameplayer->login(user,password);}
    void update(){gameplayer->update();}
};
 
int main()
{
    IGamePlayer *proxy = new GamePlayerProxy("user1");
    proxy->login("lzz","lzz");
    proxy->killBoss();
    proxy->update();
    delete proxy;
    return 0;
}
</code></pre>


<h3>强制代理与普通代理的不同在于业务函数必须由业务类制剂创建！并由业务类返回代理者！</h3>

<pre><code>
#include<iostream>
#include<string>
using namespace std;
 
 
class IGamePlayer
{
public:
    virtual void login(string user,string password) =0;
    virtual void killBoss()=0;
    virtual void update()=0;
    virtual IGamePlayer* getProxy()=0;
};
 
class GamePlayerProxy:public IGamePlayer
{
private:
    IGamePlayer *gameplayer;
public:
    GamePlayerProxy(IGamePlayer *_gameplayer)
    {
        this->gameplayer = _gameplayer;
    }
    void killBoss() {this->gameplayer->killBoss();}
    void login(string user,string password){this->gameplayer->login(user,password);}
    void update(){this->gameplayer->update();}
    IGamePlayer* getProxy(){ return this;}
};
 
class GamePlayer:public IGamePlayer
{
private :
    string name;
    IGamePlayer *Proxy;
    bool isProxy()
    {
        if(Proxy==NULL)
            return false;
        else
            return true;
    }
public:
    GamePlayer(string _name)
    {
        name = _name;
    }
    IGamePlayer* getProxy()
    {
        this->Proxy = new GamePlayerProxy(this);
        return Proxy;
    }
    void killBoss(){ if(isProxy())cout << "killBoss" <<endl;}
    void login(string user,string password){ if(isProxy()) cout << user << "  "<<password <<endl;}
    void update(){ if(isProxy())cout << "update!" <<endl; }
 
};
 
int main()
{
    IGamePlayer *player = new GamePlayer("user1");
    IGamePlayer *proxy = player->getProxy();
    proxy->login("lzz","lzz");
    proxy->killBoss();
    proxy->update();
    delete proxy;
    return 0;
}
</code></pre>


<p>还有一种动态代理的模式，主要用在Java中，动态代理在实现阶段不在乎代理谁，而主要在运行阶段才真正的代理。</p>

<p>handler只需要继承InvocationHandler即可，然后再invoke（）中返回要调用的方法或者函数。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Protype_IteratorC++实现</title>
      <link href="http://www.lizhaozhong.info/2014/05/19/protype_iteratorc.html"/>
      <pubDate>2014-05-19T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/05/19/protype_iteratorc</guid>
      <content:encoded><![CDATA[<h1>原型模式 迭代器模式 C++实现</h1>

<p>原型模式其实非常简单，难易程度其实就是单例模式与迭代器模式差不多。
在Java中我们可以有很多的接口使用，在这里，我们也许会用到Cloneable接口，然后在复制的类里面实现clone方法。</p>

<h5>调用这个clone（）就等于完成了类的复制，而不是通过new来创建。Clone（）方法是在内存中进行拷贝，所以不会调用构造函数！</h5>

<p>final与clone不共融，final使用后，就意味着无法进行重写，而调用clone（）必须重写！</p>

<p>我们知道在OO语言中，有深拷贝与浅拷贝之分。浅拷贝只拷贝类对象，类里面的数组都共享一份，这期中就有潜在的风险。而深拷贝则是完全将对象拷贝两份，也就是说内存中含有两份一模一样的对象！</p>

<h5>扯完Java，我来用C++实现原型模式，C++中没有什么clone接口，所以我们完全要手动来做。</h5>

<blockquote><p>这里有个小插曲：
因为我是在vs2012中编译的。目前vs2012已经把strcpy函数禁用掉，因为存在不安全性。</p></blockquote>

<p><img src="/assets/pic/70658.png" alt="" /></p>

<p>正如之前爆出的heartbleed漏洞，也是未对字符串赋值进行检查导致，所以我们这里使用strcpy_s()不过这样确实丧失了移植性。需要注意一下。
如果我们不需要这种提醒，可以在设置中把预编译检查关闭！</p>

<p><img src="/assets/pic/71649.png" alt="" /></p>

<pre><code>
#include<iostream>
#include<string>
using namespace std;
 
 
class Mail
{
public:
    Mail(){};
    virtual Mail* Clone(){return NULL;}
    virtual void show() =0;
    char *getstr(){return name;}
protected:
    char* name;
};
 
class MailA :public Mail
{
public:
    MailA(char *str)
    {
        if(str==NULL){      name = new char[10];    name[9]='\0';}
        else{name = new char[strlen(str)+1]; strcpy_s(name,10,str);}
    }
    ~MailA(){delete name;}
    MailA(Mail &r){     name = new char[strlen(r.getstr())+1]; strcpy_s(name,strlen(r.getstr())+1,r.getstr());  }
    Mail* Clone(){return (Mail *)new MailA(*this);}
    void show(){cout << name << endl;}
};
 
class MailB :public Mail
{
public:
    MailB(char *str)
    {
        if(str==NULL){      name = new char[10];    name[9]='\0';}
        else{name = new char[strlen(str)+1]; strcpy_s(name,10,str);}
    }
    ~MailB(){delete name;}
    MailB(Mail &r){     name = new char[strlen(r.getstr())+1]; strcpy_s(name,strlen(r.getstr())+1,r.getstr());  }
    Mail* Clone(){return (Mail *)new MailB(*this);}
    void show(){cout << name << endl;}
};
 
int main()
{
    Mail *m1 = new MailA("A");
    Mail *m2 = new MailB("B");
    Mail *m3 = m1->Clone();
    Mail *m4 = m2->Clone();
    m1->show(); m2->show(); //删除m1,m2  
    delete m1; delete m2;     
    m1 = m2 = NULL;  
 
    //深拷贝所以对m3,m4无影响  
    m3->show(); m4->show();  
    delete m3; delete m4;  
    m3 = m4 = NULL;  
}
</code></pre>


<h5>迭代器模式如STL，通过容器来管理复杂的数据结构，类等。然后通过iteration来迭代，俗称迭代器模式。</h5>

<p>在Java中有现成的迭代器来使用，在C++中，我们需要自己实现这种接口iterator。</p>

<p><img src="/assets/pic/3617.png" alt="" /></p>

<pre><code>
#include<iostream>
#include<string>
#include <vector>
using namespace std;
 
template <class T>
class Iterator
{
public:
    virtual void first()=0;
    virtual void next()=0;
    virtual T* currentItem()=0;
    virtual bool isEnd()=0;
    virtual ~Iterator(){}
};
 
template <class T>
class RealSet;
 
template <class T>
class RealIterator:public Iterator <T>
{
private:
    RealSet<T> *rset;
    int cur_ptr;
public:
    RealIterator(RealSet<T> *a):rset(a),cur_ptr(0){}
    void first(){cur_ptr=0;}
    void next(){if(cur_ptr < rset->getlen() ) cur_ptr++;}
    T* currentItem()
    {
        if(cur_ptr <rset->getlen())   return &(*rset)[cur_ptr];
        else return NULL;
    }
    bool isEnd()
    {
        if(cur_ptr >=rset->getlen())return false;
        return true;
    }
};
 
template <class T>
class Set
{
public:
    virtual Iterator<T>* createIterator()=0;
    virtual void push(T a)=0;
    virtual ~Set(){}
};
 
template <class T>
class RealSet:public Set<T>
{
private:
    vector<T> data;
public:
    RealSet(){}
    ~RealSet(){}
    virtual Iterator<T>* createIterator(){ return new RealIterator<T>(this);}
    virtual T& operator[](int index){return data[index];}
    int getlen(){return data.size();}
    void push(T a)
    {
        data.push_back(a);
    }
};
 
int main()
{
    Set<double> *set = new RealSet<double>();
    Iterator<double> *iter = set->createIterator();
    set->push(3.22);
    set->push(1.86);
    set->push(0.88);
 
    for(iter->first();iter->isEnd();iter->next())
    {
        cout << *iter->currentItem() << endl;
    }
    delete iter;
    delete set;
    return 0;
}
</code></pre>


<h6>确实这种template编程很难，我调试了一下好久才找到问题所在。。。。。。</h6>
]]></content:encoded>
    </item>
    
    <item>
      <title>Template_Builder_DesignPattern</title>
      <link href="http://www.lizhaozhong.info/2014/05/13/template_builder_designpattern.html"/>
      <pubDate>2014-05-13T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/05/13/template_builder_designpattern</guid>
      <content:encoded><![CDATA[<h1>模板方法模式 建造者模式 C++实现</h1>

<p>今天我继续来填坑，模板方法模式就是在模板方法中按照一定的规则顺序调用基本方法。这个比较简单。</p>

<p>比如我在父类run（）中调用类中一系列的方法。钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它。</p>

<p><strong><em>Java中，如果父类里面有些方法不允许覆写，那么为了防止子类改变模板方法中的算法，可以将模板方法声明为final。</em></strong></p>

<p><img src="/assets/pic/IMG_0432.jpg" alt="" /></p>

<pre><code>
#include <iostream>
using namespace std;
 
class CarTemplate
{
public:
    CarTemplate(void){};
    virtual ~CarTemplate(void){};
 
protected:
    virtual void Start() = 0;
    virtual void Stop() = 0;
    virtual void Alarm() = 0;
    virtual void EngineBoom() = 0;
    virtual bool IsAlarm() =0;
 
public:
        void Run()
        {
        Start();
 
        EngineBoom();
 
        if(IsAlarm())
            Alarm();
 
        Stop();
        };
};
 
class Hummer: public CarTemplate
{
public:
    Hummer(){m_isAlarm = true;}
    virtual ~Hummer(){};
 
protected:
    void Start(){   cout<< "Hummer Start" << endl;   }
    void Stop(){    cout<< "Hummer Stop" << endl;    }
    void Alarm(){   cout<< "Hummer Alarm" << endl;}
    bool IsAlarm(){ return m_isAlarm;       }
    void EngineBoom(){  cout<< "Hummer EngineBoom" << endl;  }
private:
    bool m_isAlarm;
};
 
class Benz: public CarTemplate
{
public:
    Benz(){m_isAlarm = false;}
    virtual ~Benz(){};
 
protected:
    void Start(){   cout<< "Benz Start" << endl; }
    void Stop(){    cout<< "Benz Stop" << endl;  }
    void Alarm(){   cout<< "Benz Alarm" << endl;}
    bool IsAlarm(){ return m_isAlarm;       }
    void EngineBoom(){  cout<< "Benz EngineBoom" << endl;    } 
private:     
        bool m_isAlarm; 
}; 

int main() 
{   
        CarTemplate *hummer = new Hummer();     
        hummer->Run();
    delete  hummer;
 
    CarTemplate *benz = new Benz();
    benz->Run();
    delete benz;
}
</code></pre>


<p>优点就在于可以封装不变的部分，拓展可变的部分，也就是把共性的东西抽取出来，这样可以便于维护。</p>

<p>但是缺点在于子类的执行，影响到父类的结果。有时候会有一些晦涩难懂。
———————————————————————————————-</p>

<p><strong><em>在模板方法中，我们把相同的都封装在父类中，不同都定义在子类中。但是需求的变化是无穷无尽的。</em></strong></p>

<blockquote><p>比如建造的顺序可能是变化的，所以将他放到builder类中，通过builder类获取真正的product！</p></blockquote>

<p><img src="/assets/pic/6446jgG.gif" alt="" /></p>

<pre><code>
class Builder
{
public:
    virtual void BuildHead() {}
    virtual void BuildBody() {}
    virtual void BuildLeftArm(){}
    virtual void BuildRightArm() {}
    virtual void BuildLeftLeg() {}
    virtual void BuildRightLeg() {}
};
//构造瘦人
class ThinBuilder:public Builder
{
public:
    void BuildHead() { cout<< "build thin body" << endl; }
    void BuildBody() { cout<< "build thin head" << endl; }
    void BuildLeftArm() { cout<< "build thin leftarm" << endl; }
    void BuildRightArm() { cout<< "build thin rightarm" << endl; }
    void BuildLeftLeg() { cout<< "build thin leftleg" << endl; }
    void BuildRightLeg() { cout<< "build thin rightleg" << endl; }
};
//构造胖人
class FatBuilder : public Builder
{
public:
    void BuildHead() { cout<<"build fat body"<< endl; }
    void BuildBody() { cout<<"build fat head"<< endl; }
    void BuildLeftArm() { cout<<"build fat leftarm"<< endl; }
    void BuildRightArm() { cout<<"build fat rightarm"<< endl; }
    void BuildLeftLeg() { cout<<"build fat leftleg"<< endl; }
    void BuildRightLeg() { cout<<"build fat rightleg"<< endl; }   
};   //构造的指挥官   

class Director     {   
private:       
    Builder *m_pBuilder;   
public:       
    Director(Builder *builder) { m_pBuilder = builder; }       
    void Create()
    {           
        m_pBuilder->BuildHead();
        m_pBuilder->BuildBody();
        m_pBuilder->BuildLeftArm();
        m_pBuilder->BuildRightArm();
        m_pBuilder->BuildLeftLeg();
        m_pBuilder->BuildRightLeg();
    }
};
 
int main()
{
    FatBuilder fat;
    Director director(&fat);
    director.Create();
---------------------------------------------------------------------------
    Builder *thin = new ThinBuilder();
    Director *dir = new Director(thin);
    dir->Create();
 
    return 0;
}
</code></pre>


<p><strong><em>建造者模式的优点：在于我们不用关心每个产品内部的组成细节，比如FatBuildier ThinBuilider，然后我们交给Director来构造就好了。</em></strong></p>

<p>建造者是独立的，我们可以拓展更多的builder完成不同的功能。并不对系统有任何影响。</p>

<p><strong>_特别适合产品类特别复杂，顺序不同，效能不同。顺序是区别模板模式与建造者模式最大的不同点！</strong></p>

<blockquote><p>另外同工厂模式进行比较，工厂模式适合生产零件。不能再细分了。否则就不适合工厂模式。</p></blockquote>

<h5>把模板方式和建造者模式组合起来可以产生很好的效果，可以按照model通过builder批量生产某种特定型号的产品。</h5>

<p><img src="/assets/pic/IMG_0433.jpg" alt="" /></p>

<pre><code>
#include<iostream>
#include<vector>
#include<string>
using namespace std;

class CCarModel
{
public:
    CCarModel(void) {}
    virtual ~CCarModel(void){}
    void Run()
    {
            vector::const_iterator it = m_pSequence->begin();
        for (; it < m_pSequence->end(); ++it)
        {
            string actionName = *it;
            if(actionName.compare("start") == 0)
            {
                Start();
            }
            else if(actionName.compare("stop") == 0)
            {
                Stop();
            }
            else if(actionName.compare("alarm") == 0)
            {
                Alarm();
            }
            else if(actionName.compare("engine boom") == 0)
            {
                EngineBoom();
            }
        }
    }
    void SetSequence(vector *pSeq)
    {
            m_pSequence = pSeq;
    }
protected:
    virtual void Start() = 0;
    virtual void Stop() = 0;
    virtual void Alarm() = 0;
    virtual void EngineBoom() = 0;
private:
    vector * m_pSequence;
};

class CBenzModel : public CCarModel
{
public:
    CBenzModel(void){}
    ~CBenzModel(void){}
protected:
    void Start(){cout << "Benz Start..." << endl;}
    void Stop(){cout << "Benz Stop..." << endl;}
    void Alarm(){cout << "Benz Alarm" << endl;}
    void EngineBoom(){cout << "Benz EngineBoom...." << endl;}
};

class CBMWModel : public CCarModel
{
public:
    CBMWModel(void){}
    ~CBMWModel(void){}
protected:
    void Start(){cout << "BMW Start..." << endl;}
    void Stop(){cout << "BMW Stop..." << endl;}
    void Alarm(){cout << "BMW Alarm" << endl;}
    void EngineBoom(){cout << "BMW EngineBoom...." << endl;}
};

class ICarBuilder
{
public:
    ICarBuilder(void)   { }
    virtual ~ICarBuilder(void)  { }
    virtual void SetSequence(vector *pseq) = 0;
    virtual CCarModel * GetCarModel() = 0;
};

class CBenzBuilder : public ICarBuilder
{
public:
    CBenzBuilder(void);
    ~CBenzBuilder(void);
    void SetSequence(vector *pSeq);
    CCarModel * GetCarModel();
private:
    CCarModel *m_pBenz;
};
CBenzBuilder::CBenzBuilder(void)
{
    m_pBenz = new CBenzModel();
}
CBenzBuilder::~CBenzBuilder(void)
{
    delete m_pBenz;
}
void CBenzBuilder::SetSequence(vector *pSeq)
{
    m_pBenz->SetSequence(pSeq);
}
CCarModel * CBenzBuilder::GetCarModel()
{
    return m_pBenz;
}

class CBMWBuilder :public ICarBuilder
{
public:
    CBMWBuilder(void);
    ~CBMWBuilder(void);
    void SetSequence(vector *pSeq);
    CCarModel * GetCarModel();
private:
    CCarModel *m_pBMW;
};

CBMWBuilder::CBMWBuilder(void)
{
    m_pBMW = new CBMWModel();
}
CBMWBuilder::~CBMWBuilder(void)
{
    delete m_pBMW;
}
void CBMWBuilder::SetSequence( vector *pSeq )
{
    m_pBMW->SetSequence(pSeq);
}
CCarModel * CBMWBuilder::GetCarModel()
{
    return m_pBMW;
}

class CDirector
{
public:
    CDirector(void);
    ~CDirector(void);
    CBenzModel * GetABenzModel();
    CBenzModel * GetBBenzModel();
    CBMWModel * GetCBMWModel();
    CBMWModel * GetDBMWModel();
private:
    vector * m_pSeqence;
    CBenzBuilder * m_pBenzBuilder;
    CBMWBuilder * m_pBMWBuilder;
};

CDirector::CDirector(void)
{
    m_pBenzBuilder = new CBenzBuilder();
    m_pBMWBuilder = new CBMWBuilder();
    m_pSeqence = new vector();
}
CDirector::~CDirector(void)
{
    delete m_pBenzBuilder;
    delete m_pBMWBuilder;
    delete m_pSeqence;
}
CBenzModel * CDirector::GetABenzModel()
{
    m_pSeqence->clear();
    m_pSeqence->push_back("start");
    m_pSeqence->push_back("stop");
    m_pBenzBuilder->SetSequence(m_pSeqence);
    return dynamic_cast<CBenzModel*>(m_pBenzBuilder->GetCarModel());
}
CBenzModel * CDirector::GetBBenzModel()
{
    m_pSeqence->clear();
    m_pSeqence->push_back("engine boom");
    m_pSeqence->push_back("start");
    m_pSeqence->push_back("stop");
    m_pBenzBuilder->SetSequence(m_pSeqence);
    return dynamic_cast<CBenzModel*>(m_pBenzBuilder->GetCarModel());
}
CBMWModel * CDirector::GetCBMWModel()
{
    m_pSeqence->clear();
    m_pSeqence->push_back("alarm");
    m_pSeqence->push_back("start");
    m_pSeqence->push_back("stop");
    m_pBMWBuilder->SetSequence(m_pSeqence);
    return static_cast<CBMWModel*>(m_pBMWBuilder->GetCarModel());
}
CBMWModel * CDirector::GetDBMWModel()
{
    m_pSeqence->clear();
    m_pSeqence->push_back("start");
    m_pBenzBuilder->SetSequence(m_pSeqence);
    return dynamic_cast<CBMWModel*>(m_pBMWBuilder->GetCarModel());
}
int main(int argc, char const *argv[])
{
    CDirector *dir = new CDirector();

    dir->GetBBenzModel()->Run();
    return 0;
}


</code></pre>


<p>通过上面可以看出两个模式的配合得到了很好的运用！</p>

<p>引用 http://blog.csdn.net/wuzhekai1985/article/details/6667467</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Unix_Thread_API备注</title>
      <link href="http://www.lizhaozhong.info/2014/05/07/unix_thread_api.html"/>
      <pubDate>2014-05-07T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/05/07/unix_thread_api</guid>
      <content:encoded><![CDATA[<h1>Unix Thread API备注</h1>

<p>这是最近读unix pthread and process使用的注意事项。</p>

<p>fork（）可以创建子进程，这个函数返回两次，通过返回值来判断是父进程还是子进程。fork时子进程获得父进程数据空间、堆和栈的复制，所以变量的地址（当然是虚拟地址）也是一样的。但是需要了解的是我们要分开虚拟地址和物理地址，两个进程虚拟地址可以相同，但是物理地址不同。</p>

<blockquote><p><strong><em>出于效率考虑，linux中引入了“写时复制“（Copy on Write）技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</em></strong></p></blockquote>

<p>但是会把父子共享的页面标记为“只读”（类似mmap的private的方式），如果父子进程一直对这个页面是同一个页面，知道其中任何一个进程要对共享的页面“写操作”，这时内核会复制一个物理页面给这个进程使用，同时修改页表。而把原来的只读页面标记为“可写”，留给另外一个进程使用。</p>

<p><strong>_同时注意stdin stdout是行缓冲，也就意味着子进程会复制父进程输入输出的内容。fork（）函数前的printf（）部分也会复制！</strong></p>

<pre><code>
while (1) {
    connfd = Accept(listenfd, (SA *) &clientaddr, &clientlen);
    if (Fork() == 0) {
        Close(listenfd); /* Child closes its listening socket */
        echo(connfd);    /* Child services client */
        Close(connfd);   /* Child closes connection with client */
        exit(0);         /* Child exits */
    }
    Close(connfd); /* Parent closes connected socket (important!) */
    }
</code></pre>


<p>这个就是返回子进程要先关闭父进程的监听套接字，因为子进程复制了父进程的变量，套接字也是一个道理！</p>

<p>pthread_t pthread_self(void); 函数作用：获得线程自身的ID。</p>

<p>void pthread_exit(void *thread_return) 终止所有线程，父进程先等待子线程退出，然后父进程退出</p>

<p>void pthread_cancel(tid)退出当前线程</p>

<p>int pthread_join(tid,void **return)</p>

<p>int pthread_detach(tid)
编程当中可以用pthread_self返回当前线程的tid。</p>

<p>创建一个线程默认的状态是joinable, 如果一个线程结束运行但没有被join,则它的状态类似于进程中的Zombie Process,即还有一部分资源没有被回收（退出状态码），所以创建线程者应该调用pthread_join来等待线程运行结束，并可得到线程的退出代码，回收其资源（类似于wait,waitpid)
但是调用pthread_join(pthread_id)后，如果该线程没有运行结束，调用者会被阻塞，在有些情况下我们并不希望如此.</p>

<p><strong>比如在Web服务器中当主线程为每个新来的链接创建一个子线程进行处理的时候，主线程并不希望因为调用pthread_join而阻塞（因为还要继续处理之后到来的链接），这时可以在子线程中加入代码pthread_detach(pthread_self())</strong></p>

<p>或者父线程调用</p>

<p><strong>pthread_detach(thread_id)（非阻塞，可立即返回）这将该子线程的状态设置为detached,则该线程运行结束后会自动释放所有资源。</strong></p>

<p>在web服务器里面，线程有同步问题。</p>

<pre><code>
void sbuf_insert(sbuf_t *sp, int item)
{
    P(&sp->slots);                          /* Wait for available slot */
    P(&sp->mutex);                          /* Lock the buffer */
    sp->buf[(++sp->rear)%(sp->n)] = item;   /* Insert the item */
    V(&sp->mutex);                          /* Unlock the buffer */
    V(&sp->items);                          /* Announce available item */
}
 
int sbuf_remove(sbuf_t *sp)
{
    int item;
    P(&sp->items);                          /* Wait for available item */
    P(&sp->mutex);                          /* Lock the buffer */
    item = sp->buf[(++sp->front)%(sp->n)];  /* Remove the item */
    V(&sp->mutex);                          /* Unlock the buffer */
    V(&sp->slots);                          /* Announce available slot */
    return item;
}
....................
for (i = 0; i < NTHREADS; i++)  
    Pthread_create(&tid, NULL, thread, NULL);//创建了大量的thread线程，但是sbuf_remove(&sbuf)相当于V（）操作，如果临界值小宇0，那么阻塞！
 
    while (1) { 
    connfd = Accept(listenfd, (SA *) &clientaddr, &clientlen);
    sbuf_insert(&sbuf, connfd); /* 这里面包含了锁，涉及的PV操作 ，相当于P()，临界值＋1*/
    }
}
 
void *thread(void *vargp) 
{  
    Pthread_detach(pthread_self()); 
    while (1) { 
    int connfd = sbuf_remove(&sbuf); /* Remove connfd from buffer */
    echo_cnt(connfd);                
    Close(connfd);
    }
}
</code></pre>

]]></content:encoded>
    </item>
    
    <item>
      <title>Factory_DesignPattern</title>
      <link href="http://www.lizhaozhong.info/2014/05/03/factory_designpattern.html"/>
      <pubDate>2014-05-03T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/05/03/factory_designpattern</guid>
      <content:encoded><![CDATA[<h1>三种工厂模式的C++实现</h1>

<p>最近想换换口味，于是抱起久违的design pattern漫画书品读起来。
工厂模式属于创建型模式，大致可以分为三类，简单工厂模式、工厂方法模式、抽象工厂模式。</p>

<p>首先介绍简单工厂模式，它的主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类。
缺点：对修改不封闭，新增加产品您要修改工厂。违法了鼎鼎大名的开闭法则（OCP）。</p>

<p><img src="/assets/pic/SingleFactory.png" alt="" />
下面的代码，由于插件有些问题，导致无法在网页显示，我将尽快修复！</p>

<pre><code>
#include <iostream>
using namespace std;
 
enum TYPE{COREA,COREB};

class SingleCore
{
    public:
        virtual ~SingleCore(){};
        virtual void Show() = 0;
};
 
class CoreA:public SingleCore
{
    public:
        void Show()
        {
            cout<< "CoreA"<< endl;
        }
};
class CoreB:public SingleCore
{
    public:
        void Show()
        {
            cout <<"CoreB"<< endl;
        }
};
 
class SingleFactory
{
    public:
        SingleCore* CreateSingleCore(enum TYPE type)
        {
            if(type==COREA)
                return new CoreA();
            else if(type==COREB)
                return new CoreB();
            else 
                return NULL;
        }
};
 
 
int main()
{
    SingleFactory factory;
    SingleCore  *pcorea = factory.CreateSingleCore(COREA);
    pcorea->Show();
    SingleCore  *pcoreb = factory.CreateSingleCore(COREB);
    pcoreb->Show();
 
    delete pcorea;
    delete pcoreb;
}
</code></pre>


<p>工厂方法模式的应用并不是只是为了封装对象的创建，而是要把对象的创建放到子类中实现：Factory中只是提供了对象创建的接口，其实现将放在Factory的子类Factory中进行。
工厂方法模式也有缺点，每增加一种产品，就需要增加一个对象的工厂。</p>

<p><img src="/assets/pic/Factory.png" alt="" /></p>

<pre><code>

#include <iostream>
using namespace std;
 
 
class SingleCore
{
    public:
        virtual ~SingleCore(){};
        virtual void Show() = 0;
};
 
class CoreA:public SingleCore
{
    public:
        void Show()
        {
            cout<< "CoreA"<< endl;
        }
};
class CoreB:public SingleCore
{
    public:
        void Show()
        {
            cout <<"CoreB"<< endl;
        }
};
 
class SingleFactory
{
    public:
        virtual SingleCore* CreateSingleCore() = 0;
};
class FactoryA:public SingleFactory
{
    public:
        SingleCore* CreateSingleCore()
        {
            return new CoreA;
        }
};
 
class FactoryB:public SingleFactory
{
    public:
        SingleCore* CreateSingleCore()
        {
            return new CoreB;
        }
};
 
 
int main()
{
    FactoryA factorya;
    SingleCore  *pcorea = factorya.CreateSingleCore();
    pcorea->Show();
 
    FactoryB factoryb;
    SingleCore  *pcoreb = factoryb.CreateSingleCore();
    pcoreb->Show();
 
    delete pcorea;
    delete pcoreb;
}
</code></pre>


<p>抽象工厂模式登场了。它的定义为提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
抽象工厂模式的组成（和工厂方法模式一样）：</p>

<p>1)抽象工厂角色：这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。</p>

<p>2)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。</p>

<p>3)抽象产品角色：它是具体产品继承的父类或者是实现的接口。</p>

<p>4)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。</p>

<p><img src="/assets/pic/AbstractFactory.png" alt="" /></p>

<pre><code>

#include <iostream>
using namespace std;
 
 
class SingleCore
{
    public:
        virtual ~SingleCore();
        virtual void Show() = 0;
};
 
class CoreA:public SingleCore
{
    public:
        void Show()
        {
            cout<< "CoreA"<< endl;
        }
};

class CoreB:public SingleCore
{
    public:
        void Show()
        {
            cout <<"CoreB"<< endl;
        }
};
//-------------------------------------------------------
class MultiCore
{
    public:
        virtual void Show() = 0;
        virtual ~MultiCore(){};
};
 
class MultiCoreA:public MultiCore
{
    public:
        void Show()
        {
            cout<<"MultiCoreA"<< endl;
        }
};
 
class MultiCoreB:public MultiCore
{
    public:
        void Show()
        {   
            cout<<"MultiCoreB"<< endl;
        }   
};
//----------------------------------------------------------
class CoreFactory
{
    public:
        virtual SingleCore* CreateSingleCore() = 0;
        virtual MultiCore* CreateMultiCore() = 0;
};
class FactoryA:public CoreFactory
{
    public:
        SingleCore* CreateSingleCore()
        {
            return new CoreA();
        }
        MultiCore* CreateMultiCore()
        {
            return new MultiCoreA();
        }
};
 
class FactoryB:public CoreFactory
{
    public:
        SingleCore* CreateSingleCore()
        {
            return new CoreB();
        }
        MultiCore* CreateMultiCore()
        {
            return new MultiCoreB();
        }
 
};
 
 
int main()
{
    FactoryA factorya;
    SingleCore  *pcorea = factorya.CreateSingleCore();
    pcorea->Show();
 
    MultiCore   *pmulticorea = factorya.CreateMultiCore();
    pmulticorea->Show();
 
    FactoryB factoryb;
    SingleCore  *pcoreb = factoryb.CreateSingleCore();
    pcoreb->Show();
 
    MultiCore   *pmulticoreb = factoryb.CreateMultiCore();
    pmulticoreb->Show();
 
    delete pcorea;
    delete pcoreb;
    delete pmulticorea;
    delete pmulticoreb;
}

</code></pre>


<p>后续我会学习其他设计模式。并贴出C++代码实现。</p>

<p>参考：http://blog.csdn.net/silangquan/article/details/20492293</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>RAM_Management3个层次的关系</title>
      <link href="http://www.lizhaozhong.info/2014/04/14/ram_management3.html"/>
      <pubDate>2014-04-14T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/04/14/ram_management3</guid>
      <content:encoded><![CDATA[<h1>内存管理3个层次的关系</h1>

<p><img src="/assets/pic/1561.jpg" alt="" /></p>

<p>下面以扩展用户堆栈为例，解释3个层次的关系。</p>

<p>调用函数时，会涉及堆栈的操作，当访问地址超过堆栈的边界时，便引起page fault，内核处理页面失效的过程中，涉及到内存管理的3个层次。</p>

<p>Ø 调用expand_stack()修改vm_area_struct结构，即扩展堆栈区的虚拟地址空间；</p>

<p>Ø 创建空白页表项，这一过程会利用mm_struct中的pgd(页全局目录表基址)得到页目录表项(pgd_offset())，然后计算得到相应的页表项(pte_alloc())地址；</p>

<p>Ø 调用alloc_page()分配物理页面，它会从指定内存管理区的buddy system中查找一块合适的free_area，进而得到一个物理页面；</p>

<p>Ø 创建映射关系，先调用mk_pte()产生页表项内容，然后调用set_pte()写入页表项。</p>

<p>Ø 至此，扩展堆栈基本完成，用户进程重新访问堆栈便可以成功。</p>

<p>可以认为，结构体pgd和vm_area_struct，函数alloc_page()和mk_pte()是连接三者的桥梁。</p>

<blockquote><p>让内核能够支持4K页到某一值之间的任意2的幂数值的大小的页面。注意，这里的页面指的是连续的物理页。
这个有点像伙伴系统。如果我们选择支持4K~4M页，那么我们就要能够分配4K~4M之间的任意2的幂数值的大小的连续物理页框：如果没有合适大小的页框，要对更大的页框进行剪裁；如果页框被归还回来，要主动将两个连续的页框块合并为一个较大的页框块。</p></blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Linux VM虚拟存储器系统（读书笔记）</title>
      <link href="http://www.lizhaozhong.info/2014/04/14/linux-vm.html"/>
      <pubDate>2014-04-14T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/04/14/linux-vm</guid>
      <content:encoded><![CDATA[<h1>Linux虚拟存储器系统（读书笔记）</h1>

<p>之前学了一段时间JOS的Env，对Linux的进程来说，每个进程有个进程控制块PCB。进程的消亡，就是Linux通过控制PCB进行的。</p>

<p>内核虚拟存储器包含内核中的代码和数据结构。内核虚拟存储器的某些区域被映射到所有进程共享的物理页面。例如，每个进程共享内核的代码和全局数据结构。下面这个图和JOS很像。高位属于kernel地址，低位留给user application。</p>

<p><img src="/assets/pic/3419.png" alt="" /></p>

<p>内核为系统中的每个进程维护一个单独的任务结构(源代码中的task_struct)。任务结构中的元素包含或者指向内核运行该进程所需要的所有信息(例如，PID，指向用户栈的指针、可执行的目标文件的名字以及程序计数器)。</p>

<p><img src="/assets/pic/3845.png" alt="" /></p>

<p>task_struct中的一个条目指向mm_struct，它描述了虚拟存储器中的当前状态。其中pgd指向第一级页表(页全局目录)的基址，而mmap指向一个vm_area_struct(区域结构)的链表，其中每个vm_area_structs都描述了当前虚拟地址空间的一个区域(area)。当内核运行这个进程时，它就将pgd存放在CR3控制寄存器中。</p>

<h4>在JOS中使用lcr3(physics address)来记录地址。</h4>

<p>一个具体区域结构包含下面的字段：</p>

<p>vm_start：指向这个区域的起始处。
vm_end：指向这个区域的结束处。
vm_prot：描述这个区域的内包含的所有页的读写许可权限。
vm_flags：描述这个区域内页面是与其他进程共享的，还是这个进程私有的(还描述了其他一些信息)。
vm_next：指向链表中下一个区域结构。
共享页面</p>

<p>共享对象的关键点在于即使对象被映射到了多个共享区域，物理存储器也只需要存放共享对象的一个拷贝。</p>

<h5>一个共享对象(注意，物理页面不一定是连续的。)</h5>

<p><img src="/assets/pic/5618.png" alt="" /></p>

<h5>私有对象是使用一种叫做写时拷贝(copy-on-write)的巧妙技术被映射到虚拟存储器中的。对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时拷贝。</h5>

<p><img src="/assets/pic/5641.png" alt="" /></p>

<p>其中有些函数比较重要.</p>

<ul>
<li>mmap函数要求内核创建一个新的虚拟存储器区域是，最好是从地址start开始的一个区域，并将文件描述符fd指定的对象的一个连续的片(chunk)映射到这个新区域。连续的对象片大小为length字节，从距文件开始处偏移量为offset字节的地方开始。start地址仅仅是一个暗示，通常被定义为NULL。</li>
</ul>


<pre><code>
#include<unistd.h>
#include<sys/mman.h>
void *mmap(void *start,size_t length,int prot,int flags,int fd,off_t offset) ;
                //返回：若成功时则为指向映射区域的指针，若出错则为MAP_FAILED(-1)
</code></pre>


<h6>我们可以使用这个函数将磁盘文件拷贝到stdout。首先我们要明确stdout 在write中fd=1 ，stderr fd =2</h6>

<pre><code>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <errno.h>
#include <math.h>
#include <pthread.h>
#include <semaphore.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
 
 
void unix_error(char *msg)                                                                                          
{                                                                                                              
    fprintf(stderr, "%s: %s\n", msg, strerror(errno));                                                         
    exit(0);                                                                                                   
}   
int Open(const char *pathname, int flags, mode_t mode)                                                         
{                                                                                                              
    int rc;                                                                                                    
                                                                                                                
    if ((rc = open(pathname, flags, mode))  < 0)                                                               
    unix_error("Open error");                                                                                  
    return rc;                                                                                                 
}
ssize_t Write(int fd, const void *buf, size_t count)                                                           
{                                                                                                              
    ssize_t rc;                                                                                                
                                                                                                                
    if ((rc = write(fd, buf, count)) < 0)                                                                      
    unix_error("Write error");                                                                                 
    return rc;                                                                                                 
} 
void *Mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset)                                                                 
{                                                                                                              
    void *ptr;                                                                                                 
                                                                                                                
    if ((ptr = mmap(addr, len, prot, flags, fd, offset)) == ((void *) -1))                                     
    unix_error("mmap error");                                                                                  
    return(ptr);                                                                                               
}  
 
void mmapcopy(int fd, int size) 
{
    char *bufp; /* ptr to memory mapped VM area */
 
    bufp = Mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
    Write(1, bufp, size);
    return;
}
 
 
int main(int argc, char **argv) 
{
    struct stat stat;
    int fd;
 
    if (argc != 2) {
    printf("usage: %s <filename>\n", argv[0]);
    exit(0);
    }
 
    fd = Open(argv[1], O_RDONLY, 0);
    fstat(fd, &stat);
    mmapcopy(fd, stat.st_size);
    exit(0);
}
</code></pre>



]]></content:encoded>
    </item>
    
    <item>
      <title>在JOS上实现基于Priority的RR_sched</title>
      <link href="http://www.lizhaozhong.info/2014/04/09/jospriorityrr_sched.html"/>
      <pubDate>2014-04-09T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/04/09/jospriorityrr_sched</guid>
      <content:encoded><![CDATA[<h1>在JOS上实现基于Priority的RR_sched</h1>

<p>JOS在一开始实现的是简单的RR算法，没有优先级调度。</p>

<p>下面我实现了具有Priority的RR调度算法。首先我们需要增加一个sys_env_set_priority（）的系统调用。</p>

<p>首先在inc/env.h 的struct Env中增加env_priority字段。这个字段来表示进程的优先级。</p>

<p>然后再inc/env.h中增加<strong>PRIORITY_HIGH PRIORITY_DEFAULT</strong> …..等宏变量。</p>

<p>在kern/env.h 的 env_alloc（）增加对env.env_priority的设定，默认为PRIORITY_DEAULT。</p>

<p>然后在真正的kern/syscall.c中实现该函数sys_env_set_priority（）。</p>

<p>下面我们对添加JOS系统中断</p>

<ul>
<li><p>在inc/syscall.h中添加新的中断号：SYS_env_set_priority。</p></li>
<li><p>在kern/syscall.c的syscall()函数中添加相应switch分发语句。</p></li>
<li><p>在lib/syscall.c中添加供用户调用系统调用的库函数。</p></li>
</ul>


<pre><code>
int sys_env_set_priority(envid_t envid, int priority)
{
return syscall(SYS_env_set_priority, 1, envid, priority, 0, 0, 0);
}
</code></pre>


<p>万事俱备，只欠东风。</p>

<p>下面在kern/sched.c中编写真正的调度程序 void sched_yield(void)</p>

<pre><code>
void RR_Priority_sched(void)
{
       int now_env,i;
       if(curenv)
       {
           now_env = (ENVX(curenv->env_id) +1) % NENV;
       }
       else
       {
           now_env = 0 ;
       }

       uint32_t max_priority = 0;
       int select_env = -1;

   //  cprintf("NENV=%d\n",NENV);
       for(i= 0;i< NENV;i++ , now_env = (now_env+1)%NENV)      
       {          
            if(envs[now_env].env_status ==ENV_RUNNABLE && (envs[now_env].env_priority > max_priority
                       ||select_env == -1))
           {
               select_env=now_env;
               max_priority = envs[now_env].env_priority;
               cprintf ("I am CPU %d , I am in sched yield , I find ENV %d,Priority 0x%x, i = %d\n",
                       thiscpu ->cpu_id , select_env,max_priority,i);
           }
       }

       //cprintf ("I am CPU %d , I am in sched yield , I find ENV %d,Priority %d\n",thiscpu ->cpu_id , select_env,max_priority);

       if (select_env >= 0 && (! curenv || curenv ->env_status != ENV_RUNNING ||
                   max_priority >= curenv ->env_priority))
       {
           env_run (& envs[select_env ]);
       }
       if (curenv && curenv ->env_status == ENV_RUNNING)
       {
           env_run(curenv);
       }

   }
</code></pre>


<p>系统调用在linux中差不多也是这个流程。<a href="">http://blog.csdn.net/m6830098/article/details/9056457</a></p>

<p>一般的，进程是不能访问内核的。它不能访问内核所占内存空间也不能调用内核函数。CPU硬件决定了这些（这就是为什么它被称作”保护模式”）。系统调用是这些规则的一个例外。其原理是进程先用适当的值填充寄存器，然后调用一个特殊的指令，这个指令会跳到一个事先定义的内核中的一个位置（当然，这个位置是用户进程可读但是不可写的）。在Intel CPU中，这个由中断0×80实现。硬件知道一旦你跳到这个位置，你就不是在限制模式下运行的用户，而是作为操作系统的内核–所以你就可以为所欲为。
进程可以跳转到的内核位置叫做sysem_call。这个过程检查系统调用号，这个号码告诉内核进程请求哪种服务。然后，它查看系统调用表(sys_call_table)找到所调用的内核函数入口地址。接着，就调用函数，等返回后，做一些系统检查，最后返回到进程（或到其他进程，如果这个进程时间用尽）。如果你希望读这段代码，它在&lt;内核源码目录>/kernel/entry.S，Entry(system_call)的下一行。</p>

<p>传统意义上系统调用产生中断，陷入内核。</p>

<p><img src="/assets/pic/IMG_0343.JPG" alt="" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Systemcall流程</title>
      <link href="http://www.lizhaozhong.info/2014/04/08/systemcall.html"/>
      <pubDate>2014-04-08T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/04/08/systemcall</guid>
      <content:encoded><![CDATA[
]]></content:encoded>
    </item>
    
  </channel>
</rss>
