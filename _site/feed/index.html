<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>JasonLe's Blog |HomePage</title>
    <link href="http://www.lizhaozhong.info/feed/" rel="self" />
    <link href="http://www.lizhaozhong.info" />
    <lastBuildDate>2014-06-20T17:20:56+08:00</lastBuildDate>
    <webMaster>ldm5235@gmail.com</webMaster>
    
    <item>
      <title>Flyweight Pattern with C++</title>
      <link href="http://www.lizhaozhong.info/2014/06/20/flyweight-pattern-with-c.html"/>
      <pubDate>2014-06-20T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/06/20/flyweight-pattern-with-c</guid>
      <content:encoded><![CDATA[<h1>享元模式 C++实现</h1>

<p>享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例数据除了几个参数外基本都是相同的。有时就能够大幅度地减少实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。</p>

<p>这种模式可以运用共享技术有效地支持大量细粒度的对象。适合具有缓冲池的场景。</p>

<p>首先我们要分清楚享元模式的内部状态和外部状态。</p>

<p>内部状态：在享元对象内部并且不会随环境改变而改变的共享部分，可以称为是享元对象的内部状态，比如base class中的member</p>

<p>外部状态：而随环境改变而改变的，取决于应用环境，或是实时数据，这些不可以共享的东西就是外部状态了。比如存在的map的key值</p>

<p>内部状态存储于ConcreteFlyweight对象之中；而外部状态则由Client对象存储或计算。</p>

<h4>当用户调用Flyweight对象的操作时，将该状态传递给它。</h4>

<h4>外部状态有一个factory，负责维护外部状态，并把外部状态和class放入container中。</h4>

<p><img src="/assets/pic/flyweight.png" alt="" /></p>

<pre><code>
#include <iostream>
#include <string>
#include <list>
#include <vector>
#include <hash_map>
using namespace std;
 
class Flyweight
{
public:
    //操作外部状态extrinsicState
    virtual void Operation(const string& extrinsicState)=0;
    string GetIntrinsicState()
    {
        return this->_intrinsicState;
    }
    virtual ~Flyweight(){}
protected:
    Flyweight(string intrinsicState)
    {
        this->_intrinsicState = intrinsicState;
    }
private:
    //内部状态，也可以放在ConcreteFlyweight中
    string _intrinsicState;
};
 
class ConcreteFlyweight:public Flyweight
{
public:
    virtual void Operation(const string& extrinsicState)
    {
        cout << this->GetIntrinsicState() << endl;
        cout << extrinsicState << endl;
    }
    ConcreteFlyweight(string intrinsicState):Flyweight(intrinsicState){}
    ~ConcreteFlyweight(){}
};
 
class UnsharedConcreteFlyweight:public Flyweight
{
public:
    virtual void Operation(const string& extrinsicState)
    {
        cout << extrinsicState << endl;
    }
    UnsharedConcreteFlyweight(string intrinsicState):Flyweight(intrinsicState){}
    ~UnsharedConcreteFlyweight(){}
};
 
class FlyweightFactory
{
public:
    FlyweightFactory(){}
    ~FlyweightFactory(){}
    //获得一个请求的Flyweight对象
    Flyweight* GetFlyweight(string key)
    {
        if(m_mapFly.find(key)!=m_mapFly.end())
        {
            return m_mapFly[key];
        }
        //Flyweight* fly = new ConcreteFlyweight(key);
        Flyweight* fly = new UnsharedConcreteFlyweight(key);
        this->m_mapFly.insert(pair<string,Flyweight*>(key,fly));
        return fly;
    }
    //获取容器中存储的对象数量
    void GetFlyweightCount()
    {
        cout << this->m_mapFly.size() << endl;
    }
protected:
private:
    //保存内部状态对象的容器
    hash_map<string,Flyweight*> m_mapFly;
};
 
int main()
{
    //外部状态extrinsicState
    string extrinsicState = "ext";
 
    //工厂对象，工厂对象
    FlyweightFactory* fc = new FlyweightFactory();
 
    Flyweight* fly = fc->GetFlyweight("hello");
    fly = fc->GetFlyweight("hello1");
 
    fly = fc->GetFlyweight("hello");
 
    //应用外部状态
    fly->Operation("hello3");
 
    fc->GetFlyweightCount();
 
    return 0;
}
</code></pre>


<p>线程环境下，必须使用锁变量。结局这种问题的方式，就是使用外部类来当做key值，但是这又会出现另一个问题：维护一个container。class的效率明显比string类型低。</p>

<p>参考：</p>

<p><a href="http://blog.csdn.net/lcl_data/article/details/8974679">http://blog.csdn.net/lcl_data/article/details/8974679</a></p>

<p><a href="http://msdn.microsoft.com/zh-cn/library/th79x793.aspx">http://msdn.microsoft.com/zh-cn/library/th79x793.aspx</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Bridge Pattern with C++</title>
      <link href="http://www.lizhaozhong.info/2014/06/19/bridge-pattern-with-c.html"/>
      <pubDate>2014-06-19T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/06/19/bridge-pattern-with-c</guid>
      <content:encoded><![CDATA[<h1>桥梁模式 C++实现</h1>

<p>桥梁模式主要解决多层继承，比如我们可以想想，人可以分为男人女人，人又有不同的行为。如果把这个两个class继承，也就意味着是男人行为A，男人行为B。女人行为A，女人行为B。
这种方式非常难以扩展，所以桥梁模式派上用场，它将表示和实现解耦,两者可以独立的变化。</p>

<h5>也就是抽象出人和行为，然后人调用行为，减少了继承的class。</h5>

<p>其中这种模式又有一些像策略模式，又有一些像建造者模式。</p>

<h5>当我们考虑一个对象的多个变化因素可以动态变化的时候，考虑使用桥接模式</h5>

<p>优点</p>

<p>1.将实现抽离出来，再实现抽象，使得对象的具体实现依赖于抽象，满足了依赖倒转原则。</p>

<p>2.将可以共享的变化部分，抽离出来，减少了代码的重复信息。</p>

<p>3.对象的具体实现可以更加灵活，可以满足多个因素变化的要求。</p>

<p>缺点</p>

<p>1.客户必须知道选择哪一种类型的实现。</p>

<p>如果我们用山寨工厂和房地产工厂生产产品做例子，非常清晰易懂。</p>

<h4>这里我们要知道class IProduct中有两个虚基类，用于动态绑定！</h4>

<p><img src="/assets/pic/bridge.png" alt="" /></p>

<pre><code>
#include <iostream>
#include <string>
#include <list>
using namespace std;
 
class IProduct
{
public:
    IProduct(void)
    {
    }
    virtual ~IProduct(void)
    {
    }
    virtual void BeProducted() = 0;
    virtual void BeSelled() = 0;
};
 
class CNewCorp
{
public:
    CNewCorp(IProduct *pproduct)
    {
        this->m_pProduct = pproduct;
    }
    virtual ~CNewCorp(void){}
    void MakeMoney()
    {
        //每个公司都是一样，先生产
        this->m_pProduct->BeProducted();
        //然后销售
        this->m_pProduct->BeSelled();
    }
private:
    IProduct *m_pProduct;
};
class CHouse : public IProduct
{
public:
    CHouse(void){}
    ~CHouse(void){}
    void BeProducted(){cout << "生产出的房子是这个样子的..." << endl;}
    void BeSelled(){cout << "生产出的房子卖出去了..." << endl;}
};
 
class CClothes : public IProduct
{
public:
    CClothes(void){}
    ~CClothes(void){}
    void BeProducted(){cout << "生产出的衣服是这个样子的..." << endl;}
    void BeSelled(){cout << "生产出的衣服卖出去了..." << endl;}
};
 
class CNewHouseCorp : public CNewCorp
{
public:
    CNewHouseCorp(CHouse *pHouse):CNewCorp(pHouse){}
    ~CNewHouseCorp(void){}
    void MakeMoney()
    {
        this->CNewCorp::MakeMoney();
        cout << "房地产公司赚大钱了..." << endl;
    }
};
 
class CIPod :public IProduct
{
public:
    CIPod(void){}
    ~CIPod(void){}
    void BeProducted(){cout << "生产出的ipod是这个样子的..." << endl;}
    void BeSelled(){ cout << "生产出的ipod卖出去了..." << endl;}
};
 
class CShanZhaiCorp : public CNewCorp
{
public:
    CShanZhaiCorp(IProduct *pproduct): CNewCorp(pproduct){}
    ~CShanZhaiCorp(void){}
    void MakeMoney()
    {
        this->CNewCorp::MakeMoney();
        cout << "我赚钱呀..." << endl;
    }
};
void DoNewRun1()
{
    cout << "----------房地产公司是这样运行的----------" << endl;
    CHouse house;
    CNewHouseCorp newHouseCorp(&house);
    newHouseCorp.MakeMoney();
    cout << endl;
 
    cout << "----------山寨公司是这样运行的----------" << endl;
    CClothes clothes;
    CShanZhaiCorp shanZhaiCorp(&clothes);
    shanZhaiCorp.MakeMoney();
    cout << endl;
}
 
void DoNewRun2()
{
    cout << "----------房地产公司是这样运行的----------" << endl;
    CHouse house;
    CNewHouseCorp newHouseCorp(&house);
    newHouseCorp.MakeMoney();
    cout << endl;
 
    cout << "----------山寨公司是这样运行的----------" << endl;
    CIPod ipod;
    CShanZhaiCorp shanZhaiCorp(&ipod);
    shanZhaiCorp.MakeMoney();
    cout << endl;
}
 
int main()
{
    DoNewRun1();
 
    DoNewRun2();
    return 0;
}
 </code></pre>


<p>这里我们要说明的是Java中我们可以使用super.func()的方式调用基类，在C++中，我们直接this->CNewCorp::MakeMoney();来调用基类</p>

<p>另外，我们要深刻理解动态绑定的灵活性！</p>

<p>客户直接使用CNewHouseCorp和CShanZhaiCorp类.</p>

<h4>在main()函数里构造产品，然后传到这两个类里。这两个类的MakeMoney()函数，先调用基类的MakeMoney()，然后分别执行各自的逻辑。各自逻辑就是子类的具体实现（concreteimplement）</h4>

<p>参考<a href="http://www.cnblogs.com/jiese/p/3164940.html">http://www.cnblogs.com/jiese/p/3164940.html</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Visitor Pattern with C++</title>
      <link href="http://www.lizhaozhong.info/2014/06/17/visitor-pattern-with-c.html"/>
      <pubDate>2014-06-17T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/06/17/visitor-pattern-with-c</guid>
      <content:encoded><![CDATA[<h1>访问者模式 C++实现</h1>

<p>访问者模式，顾名思义就是使用vistor类来访问其他类的intern数据，而不改变intern的数据结构和代码。
这样可以分开数据显示和业务逻辑，使得代码更加清晰。</p>

<p>访问者模式的优点就是：灵活度非常高，有优秀的拓展性。
缺点就是：不依赖抽象元素，违反了依赖倒置的原则，直接依赖实现类，拓展实现类比较难。</p>

<blockquote><p>访问者模式和迭代器模式有相同点又有不同点。
相同点都是访问具体的实现类。
不同点在于迭代器模式只能访问相同由base class引用来的class或者interface的数据，而访问者模式可以访问不同的class，不再依赖base class</p></blockquote>

<h5>总的来说 访问者模式适用范围大于迭代器模式的范围！</h5>

<p><img src="/assets/pic/visitor.png" alt="" /></p>

<p>下面这种方式是使用不同访问者定义不同的访问方式，可以说是多个访问者。</p>

<pre><code>
#include <iostream>
#include <string>
#include <list>
using namespace std;
 
class BaseElement;
 
class BaseVisitor
{
public:
    virtual void Visit( BaseElement *element ){};
};
 
class BaseElement
{
public:
    // Methods
    virtual void Accept( BaseVisitor *visitor ){};
};
 
 
// "ConcreteElement"
class Employee : public BaseElement
{
public:
    string name;
    double income;
    int vacationDays;
 
public :
    Employee( string name, double income,
        int vacationDays )
    {
        this->name = name;
        this->income = income;
        this->vacationDays = vacationDays;
    }
 
    void Accept( BaseVisitor *visitor )
    {
        visitor->Visit( this );
    }
};
 
class IncomeVisitor : public BaseVisitor
{
public: 
    void Visit( BaseElement *element )
    {
        Employee *employee = ((Employee*)element);
        employee->income *= 1.10;
        cout<<employee->name<<" 's new income: " << employee->income<< endl; 
    }
};
 
class VacationVisitor : public BaseVisitor
{
public :
    void Visit( BaseElement *element )
    {
        Employee *employee = ((Employee*)element);
        employee->vacationDays += 3;     
        cout<< employee->name <<" 's new vacation days: " << employee->vacationDays<< endl;
    }
};
 
class Employees
{   
private :
    list< Employee*> employees;
 
public :
 
    void Attach( Employee *employee )
    {       
        employees.push_back(employee);      
    }
 
    void Detach( Employee *employee )
    {
        employees.remove(employee);     
    }
 
    void Accept( BaseVisitor *visitor )
    {       
        for (std::list<Employee*>::iterator it=employees.begin(); it != employees.end(); ++it)
            (*it)->Accept(visitor);
    }
};
 
void main( )
{
    Employees *e = new Employees();
    e->Attach( new Employee( "Jason", 25000.0, 14 ) );
    e->Attach( new Employee( "Albter", 35000.0, 16 ) );
    e->Attach( new Employee( "lily", 45000.0, 21 ) );
 
    IncomeVisitor *v1 = new IncomeVisitor();
    VacationVisitor *v2 = new VacationVisitor();
 
    e->Accept( v1 );
    e->Accept( v2 );
}
</code></pre>


<p>在vistor模式中，以及以前的design pattern中，我们都使用了动态绑定！
动态绑定就是在基类中定义virtual function 然后继承该base class，创建derive class时转到base class。当我们使用derive class中的function，我们只需要把base class指针指向该函数即可！</p>

<blockquote><p>我们要分清函数重载与动态绑定在工程中的区别（重载只是函数类型不同而已！）</p>

<p>动态绑定中，函数的执行操作决定于请求种类，与接收者类型！</p></blockquote>

<p>访问者模式适合于重构！比如功能集中化，UI集中化。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Memento Pattern with C++</title>
      <link href="http://www.lizhaozhong.info/2014/06/12/memento-pattern-with-c.html"/>
      <pubDate>2014-06-12T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/06/12/memento-pattern-with-c</guid>
      <content:encoded><![CDATA[<h1>备忘录模式C++实现</h1>

<p>备忘录模式是一种比较重要的设计模式，如果程序执行错误，我们可以恢复restore之前的状态，就好像我们在编辑word文档，需要撤销原操作，那么我们使用ctrl+Z。
在数据库操作中，这个模式用的非常多！</p>

<p>说白了就是在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。</p>

<p>这个模式有三个对象：</p>

<p>Originator（执行业务逻辑的class）：负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。Originator可根据需要决定Memento存储Originator的哪些内部状态。</p>

<p>Memento（备份数据的class）:负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。</p>

<p>Caretaker（说白了就是管理备份数据的class）：负责保存好备忘录Memento,不能对备忘录的内容进行操作或检查。</p>

<h5>由于备忘录模式非常灵活，往简单说可以保存单state，多state。甚至是一个保存class，往更大的说了，就是一个备份系统，每隔一段时间备份一次数据。</h5>

<h5>不过使用备忘录模式的时候，要考虑控制建立Memento的数量，大的object非常消耗资源，有可能产生内存泄露。</h5>

<p>下面我先来说对于单变量的备忘录模式。
<img src="/assets/pic/memento.png" alt="" /></p>

<pre><code>
#include <iostream>
#include <string>
#include <vector>
using namespace std;
 
//保存数据的class
class Memento
{
private:
    friend class Originator;
    Memento(const string& state){this->_state = state;}
    ~Memento(){}
    void SetState(const string& state){this->_state = state;}
    string GetState(){return this->_state;}
    string _state;
};
 
 
//备份数据逻辑的class
class Originator
{
public:
    Originator();
    Originator(const string& state){this->_state = state;}
    ~Originator(){}
    void RestoreToMemento(Memento* pMemento){this->_state = pMemento->GetState();}
    Memento* CreateMemento(){return new Memento(this->_state);}
    void SetState(const string& state){this->_state = state;}
    string GetState(){return this->_state;}
    void show(){cout << this->_state << endl;}
protected:
private:
    string _state;
};
 
//管理备份数据的class
class Caretaker
{
public:
    Caretaker(){}
    ~Caretaker(){}
    void SetMemento(Memento *pMemento){this->_memento = pMemento;}
    Memento* GetMemento(){return this->_memento;}
private:
    Memento* _memento;
};
int main()
{
    //初始化对象，状态为“Old”
    Originator* o = new Originator("Old");
    o->show();
 
    //建立并保存Memento
    Caretaker* pTaker = new Caretaker();
    pTaker->SetMemento(o->CreateMemento());
 
    //改变状态
    o->SetState("New");
    o->show();
 
    //恢复状态
    o->RestoreToMemento(pTaker->GetMemento());
    o->show();
 
    return 0;
}
</code></pre>


<p>上面我们只是保存了一个state值，如果要保存一系列的值，小于6个，个人推荐直接在构造函数里传值保存！
如果是保存一个类，在Java中我们有clone（）方法，但是在C++中，我们没有现成的cloneable接口，我们无法进行深拷贝，只能借助库或者是直接实现，这里我们可以参考之前的原型模式（protype pattern）实现方式。</p>

<p>对于多状态备忘录模式在Java中我们可以使用BeanUtils工具类，在Java中使用BeanUtils；类以及反射的技术，进行保存，精髓就是使用hashmap来进行保存！</p>

<p>对于多备份备忘录，我们构造一个hashmap来存放不同时刻的memento</p>

<pre><code>
class MultiCaretaker
{
public:
    MultiCaretaker(){}
    ~MultiCaretaker(){}
    void SetMemento(string name,Memento *pMemento){this->memmap.insert(pair<string,Memento*>(name,pMemento));}
    Memento* GetMemento(string name){return this->memmap[name];}
private:
    hash_map<string,Memento*> memmap;
};
</code></pre>


<p>如果为了封装好一点，可以将memento放在originator中，只有originator可以调用memento！
刚才在上面做的那种单状态保存的方式，使用friend属性，其实打破了OO的开闭原则，存在一定的缺陷！</p>

<h5>Java中有反射机制，C++中如何具体实现这种机制还要继续学习一下！</h5>

<p>参考
<a href="http://blog.csdn.net/wuzhekai1985/article/details/6672906">http://blog.csdn.net/wuzhekai1985/article/details/6672906</a></p>

<p><a href="http://blog.csdn.net/ai92/article/details/454354">http://blog.csdn.net/ai92/article/details/454354</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Observer Pattern with C++</title>
      <link href="http://www.lizhaozhong.info/2014/06/10/observer-pattern-with-c.html"/>
      <pubDate>2014-06-10T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/06/10/observer-pattern-with-c</guid>
      <content:encoded><![CDATA[<h1>观察者模式C++实现</h1>

<p>观察者模式是非常重要的一个模式，初次遇到该模式，想了很久没有想通应该怎么做。</p>

<p>其实原理很简单：就是当被观察者（Observable）发生变化，然后就会某种数据方式通知（Notify）观察者（Observer），Notify的方式很多，比如我们将Observer 放到一个list或者set中，分别调用Observer的update（）这样实现通知。</p>

<p>这个模式和之前的责任链模式很相似，不同的是观察者模式在消息传播的时候，消息是可变的。责任链模式在消息 传播的过程保持消息的不可变。</p>

<h4>另外我们要说明的是ObserverPattern模式中最好只出现一个既是Observer又是Observable的对象，消息最多转发一次</h4>

<h4>从效率上来说，如果一个Observer被阻塞，会影响其他Observer的Notify（），所以Notify（）最好采用异步的方式。不过异步的话就要考虑线程安全和队列的问题，需要查看message queue。</h4>

<p>下面是UML类图
<img src="/assets/pic/Observer.png" alt="" /></p>

<pre><code>
#include <iostream>
#include <string>
#include <vector>
using namespace std;
 
class IObserver
{
public:
    IObserver(string _name)
    {
        this->m_name = _name;
    }
    virtual ~IObserver(void)
    {
    }
    virtual void Update(string context) = 0;
    virtual string GetName() = 0;//为c++单独增加的函数，用于删除时查找观察者。
protected:
    string m_name;
};
 
class IObservable
{
public:
    IObservable(void)
    {
    }
    virtual ~IObservable(void)
    {
    }
    virtual void AddObserver(IObserver *pObserver) = 0;
    virtual void DeleteObserver(IObserver *pObserver) = 0;
    virtual void NotifyObservers(string context) = 0;
};
 
class SuperStar : public IObservable
{
public:
    SuperStar(void){}
    ~SuperStar(void){}
    void AddObserver(IObserver *pObserver){m_observerList.push_back(pObserver);}
    void DeleteObserver(IObserver *pObserver)
    {
        ObserverList_C_iterator it = m_observerList.begin();
        for (; it != m_observerList.end(); it++)
        {
            string name = (*it)->GetName();
            if (name.compare(pObserver->GetName()) == 0)
            {
                it = m_observerList.erase(it);
            }
        }
    }
    void NotifyObservers(string context)
    {
        ObserverList_C_iterator it = m_observerList.begin();
        for (; it != m_observerList.end(); it ++)
        {
            (*it)->Update(context);
        }
    }
    void HaveBreakfast()
    {
         cout << "SuperStart begin to have breakfast..." << endl;
         this->NotifyObservers("SuperStart begin to have breakfast");
    }
    void HaveFun()
    {
         cout << "SuperStart begin to have fun..." << endl;
         this->NotifyObservers("SuperStart begin to have fun");
    }
private:
    vector<IObserver*> m_observerList;
    typedef vector<IObserver*>::const_iterator ObserverList_C_iterator;
};
class Spy1 :  public IObserver
{
public:
    Spy1(void):IObserver("SPY1"){}
    ~Spy1(void){}
    void Update(string context)
    {
        cout << "Spy1:something happened..." << endl;
        this->ReportToBoss(context);
        cout << "Spy1:get some price" << endl;
    }
    string GetName(){return m_name;}
private:
    void ReportToBoss(string report)
    {
         cout << "Spy1:Boss->" << report.c_str() << endl;
    }
};
class Spy2 :  public IObserver
{
public:
    Spy2(void):IObserver("SPY1"){}
    ~Spy2(void){}
    void Update(string context)
    {
        cout << "Spy2:something happened..." << endl;
        this->ReportToBoss(context);
        cout << "Spy2:get some price" << endl;
    }
    string GetName(){return m_name;}
private:
    void ReportToBoss(string report)
    {
         cout << "Spy2:Boss->" << report.c_str() << endl;
    }
};
 
int main()
{
    IObserver *spy1 = new Spy1();
    IObserver *spy2 = new Spy2();
 
    SuperStar *superstar = new SuperStar();
 
    superstar->AddObserver(spy1);
    superstar->AddObserver(spy2);
 
    superstar->HaveFun();
 
    cout << endl;
    superstar->DeleteObserver(spy1);
    superstar->HaveBreakfast();
 
    delete spy1;
    spy1 = NULL;
    delete spy2;
    spy2 = NULL;
}
</code></pre>


<p>因为是C++实现，没有通用的Observer Pattern framework，所以我们在class superstar中实现了</p>

<p>void AddObserver(IObserver *pObserver)</p>

<p>void DeleteObserver(IObserver *pObserver)</p>

<p>void NotifyObservers(string context)</p>

<p>如果我们把这个代码变为一种framework，类图会变化
<img src="/assets/pic/Observer2.png" alt="" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>User Excption Stack Design</title>
      <link href="http://www.lizhaozhong.info/2014/06/08/user-excption-stack-design.html"/>
      <pubDate>2014-06-08T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/06/08/user-excption-stack-design</guid>
      <content:encoded><![CDATA[<h1>用户空间的异常栈设计</h1>

<p>这个坑想了很久，但是一直没时间填，今天抽出一个周六，把之前的草稿完成！</p>

<p>我们知道在linux中如果用户程序发生错误，kernel会终止程序运行，并发出segment fault错误。
这种实现其实就是在用户空间实现了异常栈的操作。</p>

<p>下面我来说一下JOS的用户空间的异常栈设计。</p>

<p>首先明确几个概念：</p>

<p>在明确概念前，我们要先看明白JOS内存分布</p>

<pre><code>
 * Virtual memory map:                                Permissions
 *                                                    kernel/user
 *
 *    4 Gig -------->  +------------------------------+
 *                     |                              | RW/--
 *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                     :              .               :
 *                     :              .               :
 *                     :              .               :
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
 *                     |                              | RW/--
 *                     |   Remapped Physical Memory   | RW/--
 *                     |                              | RW/--
 *    KERNBASE, ---->  +------------------------------+ 0xf0000000      --+
 *    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
 *                     +------------------------------+                   |
 *                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |
 *                     | - - - - - - - - - - - - - - -|                 PTSIZE
 *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
 *                     +------------------------------+                   |
 *                     :              .               :                   |
 *                     :              .               :                   |
 *    MMIOLIM ------>  +------------------------------+ 0xefc00000      --+
 *                     |       Memory-mapped I/O      | RW/--  PTSIZE
 * ULIM, MMIOBASE -->  +------------------------------+ 0xef800000
 *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
 *    UVPT      ---->  +------------------------------+ 0xef400000
 *                     |          RO PAGES            | R-/R-  PTSIZE
 *    UPAGES    ---->  +------------------------------+ 0xef000000
 *                     |           RO ENVS            | R-/R-  PTSIZE
 * UTOP,UENVS ------>  +------------------------------+ 0xeec00000
 * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebff000
 *                     |       Empty Memory (*)       | --/--  PGSIZE
 *    USTACKTOP  --->  +------------------------------+ 0xeebfe000
 *                     |      Normal User Stack       | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebfd000
 *                     |                              |
 *                     |                              |
 *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                     .                              .
 *                     .                              .
 *                     .                              .
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
 *                     |     Program Data & Heap      |
 *    UTEXT -------->  +------------------------------+ 0x00800000
 *    PFTEMP ------->  |       Empty Memory (*)       |        PTSIZE
 *                     |                              |
 *    UTEMP -------->  +------------------------------+ 0x00400000      --+
 *                     |       Empty Memory (*)       |                   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |  User STAB Data (optional)   |                 PTSIZE
 *    USTABDATA ---->  +------------------------------+ 0x00200000        |
 *                     |       Empty Memory (*)       |                   |
 *    0 ------------>  +------------------------------+                 --+
 *
 * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
 *     "Empty Memory" is normally unmapped, but user programs may map pages
 *     there if desired.  JOS user programs map pages temporarily at UTEMP.
</code></pre>


<h6>内核栈：kernel代码正常执行时，包括发生中断/异常陷入kernel时，kernel运行的栈称为“内核栈(kernel stack)”，它的esp寄存器指向当前CPU的栈顶，栈的线性地址范围为[kstacktop_i - KSTKSIZE, kstacktop_i -1]. （我们要知道在多核环境下，内核栈有多少个由核心数决定）中断/异常发生时，CPU自动切换到内核栈。之前我已经设置过内核栈。</h6>

<h6>用户运行栈：在用户程序正常执行时，它所运行的栈称为“用户运行栈(normal user stack)”，它的esp寄存器指向USTACKTOP, 栈的线性地址范围是[USTACKTOP - PGSIZE, USTACKTOP - 1].</h6>

<h6>用户异常栈：是用户自己定义相应的中断处理程序后，相应处理程序运行时的栈。注意这个处理程序是user mode的，而不是在内核中。它的esp寄存器指向UXSTACKTOP, 栈的线性地址范围是[UXSTACKTOP - PGSIZE, UXSTACKTOP - 1]，也是一页大小。</h6>

<p>user mode发生异常，用户空间发生了一个page fault. 如果没有用户异常栈，理论上用户程序执行不下去了，它将陷入内核栈，然后在内核中处理page fault，然后返回用户程序。但是，这里我们将采用一个新的机制！也就是不再在内核中处理page fault，而是在user mode的用户异常栈上！</p>

<p>用户空间发生page fault后，首先陷入内核（用户运行栈->内核栈， user mode -> kernel mode），进入trap()处理中断分发，进入page_fault_handler().</p>

<p>然后内核中的page_fault_handler()在确认是用户程序而不是内核触发了page fault后（如果是内核发生page fault就直接panic了），在用户异常栈上压入一个UTrapframe作为记录保存现场的信息（注意这只是内存操作，还没有切换到用户异常栈）。</p>

<p>kernel将用户程序切换到用户异常栈（内核栈->用户异常栈, kernel mode -> user mode），然后就让用户程序重新运行了！</p>

<blockquote><p>这里有两点要说明：1.现在用户程序是运行在用户异常栈（而不是用户运行栈）上，2.此时的eip被设置为page fault处理程序的起始地址curenv->env_pgfault_upcall。所以，接下来用户程序执行处理page fault的处理程序，它实际上是在用户空间中进行处理。</p>

<p>page fault被处理完后，切换回用户运行栈（用户异常栈->用户运行栈, user mode -> user mode），用户程序重新运行。
弄清楚page fault发生前后“栈的切换”、“特权级别(mode)的切换”是非常重要的。</p></blockquote>

<p>实际上判断用户程序是在kernel mode 还是 user mode主要是通过寄存器中 tf_cs == GD_KT来判断。</p>

<p>如果这个寄存器记录的值不是GD_KT那么，说明pagefault来自用户空间。</p>

<p>然后检查检查user mode pagefault handler即将调用异常处理函数的入口地址。即env_pgfault_upcall</p>

<p>这里涉及一个问题，判断当前的esp是否已经在用户异常栈中.</p>

<p>如果是的话，就要从esp再往下分配一个sizeof（UTrapframe）大小的空间，存放UTrapframe，否则从用户异常栈顶UXSTACKTOP分配UTrapframe。然后将寄存器里面的值eflags ，eip， esp，regs存入到UTrapframe结构体中。</p>

<h6>UTrapframe不同在于Trapframe的是env_tf.tf_eip env_tf.tf_esp</h6>

<p>env_tf.tf_eip指向用户自己的异常处理函数，env_tf.tf_esp指向的是UTrapframe，保存完现场，然后系统把控制权交给用户定义的异常处理函数，然后系统进行调度。</p>

<p>理解了上述的过程，我对中断用户异常处理函数有了好的了解，下一步实现该代码即可。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Strategy Pattern with C++</title>
      <link href="http://www.lizhaozhong.info/2014/06/06/Strategy-Pattern-with-c.html"/>
      <pubDate>2014-06-06T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/06/06/Strategy-Pattern-with-c</guid>
      <content:encoded><![CDATA[<h1>策略模式及其拓展 C++实现</h1>

<p>策略模式形式上其实和装饰者模式，工厂模式都很像，装饰者模式是在原有核心的业务上添加新的业务，工厂模式是在构造函数中传入新类类名，然后返回新的类。而策略模式则是将策略类传入到执行类里，达到执行策略的目的！</p>

<p>工厂模式和策略模式有很多相通的地方。都是创造类。</p>

<h6>不同点在于：工厂模式有可能各个类的方法名和个数差别很大，注重不同对象的创建。策略模式 一般用于多个类的方法名都相同,但是实现方式不同 注重多个对象的相同行为：屏蔽方法名相同，算法实现细节不同之间的差异</h6>

<p>策略模式的缺点是：策略类数量过多，所有策略类都必须对外暴露。</p>

<h5>原则就是：当具体策略超过4个的时候，就要考虑使用混合模式，比如和工厂模式混用！</h5>

<p><img src="/assets/pic/1855.png" alt="" /></p>

<pre><code>
#include <iostream>
#include <string>
using namespace std;
 
class IStrategy
{
public:
    IStrategy(void){};
    virtual ~IStrategy(void){};
    virtual void Operate(void) = 0;
};
 
class context
{
public:
    context(IStrategy *isstrategy):m_strategy(isstrategy){}
    ~context(){}
    void Operate(void){m_strategy->Operate();}
private:
    IStrategy *m_strategy;
      
};
 
class BackDoor:public IStrategy
{
public:
    BackDoor(void){}
    ~BackDoor(void){}
    void Operate(void){std::cout <<"BackDoor" << std::endl;}
};
 
class GreenLight:public IStrategy
{
public:
    GreenLight(void){}
    ~GreenLight(void){}
    void Operate(void){std::cout << "GreenLight" << std::endl;}
};
 
int main()
{
    context*context1 =  new context(new BackDoor());
    context1->Operate();
 
    context*context2 =  new context(new GreenLight());
    context2->Operate();
 
    return 0;
}
</code></pre>


<p>因为这个模式过于简单,<strong><strong><em>所以我们要配合其他模式使用，如果我们配合工厂模式，正好可以弥补策略模式的缺点！</em></strong></strong></p>

<p>我增加了class Policeoffice 与 class Police</p>

<p>其中class Policeoffice主要是下达具体命令的地方，这也是工厂模式的精髓！class Police封装这个工厂，并使用创造的新类执行。</p>

<h5>这个完美的弥补了策略模式，策略类太多的弊病。策略类多正好由工厂区创建！</h5>

<p><img src="/assets/pic/0551.png" alt="" /></p>

<pre><code>
#include <iostream>
#include <string>
using namespace std;
 
class IStrategy
{
public:
    IStrategy(void){};
    virtual ~IStrategy(void){};
    virtual void Operate(void) = 0;
};
 
class Context
{
public:
    Context(IStrategy *isstrategy):m_strategy(isstrategy){}
    ~Context(){}
    void Operate(void){m_strategy->Operate();}
private:
    IStrategy *m_strategy;
      
};
 
class BackDoor:public IStrategy
{
public:
    BackDoor(void){}
    ~BackDoor(void){}
    void Operate(void){std::cout <<"BackDoor" << std::endl;}
};
 
class GreenLight:public IStrategy
{
public:
    GreenLight(void){}
    ~GreenLight(void){}
    void Operate(void){std::cout << "GreenLight" << std::endl;}
};
 
class Policeoffice
{
public:
    Policeoffice(){}
    ~Policeoffice(){}
    IStrategy* getStrategy(string classname)
    {
        if(classname =="BackDoor")
            return new BackDoor();
        else if(classname =="GreenLight")
            return new GreenLight();
 
        return NULL;
    }
};
 
class Police
{
public:
    Police(){office = new Policeoffice();}
    ~Police(){delete office;}
    void PoliceDeduct(string classname)
    {       
        IStrategy *strategy = office->getStrategy(classname);
        context = new Context(strategy);
        context->Operate();
    }
private:
    Policeoffice *office;
    IStrategy *strategy;
    Context *context;
};
 
int main()
{
    Police police;
    police.PoliceDeduct("BackDoor");
 
    return 0;
}
</code></pre>


<p>设计模式不止一种，所以我们要考虑混用各种设计模式，达到解耦的效果！</p>

<h4>封装的精髓就是避免高层模块深入系统内部，这样使得系统达到高内聚，低耦合的特性。</h4>
]]></content:encoded>
    </item>
    
    <item>
      <title>Decorator Pattern with C++</title>
      <link href="http://www.lizhaozhong.info/2014/06/03/decorator-pattern-with-c.html"/>
      <pubDate>2014-06-03T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/06/03/decorator-pattern-with-c</guid>
      <content:encoded><![CDATA[<h1>装饰者模式 C++实现</h1>

<p>装饰者模式就是在原来类的基础上添加额外的功能，这种方式主要是为了应对继承带来的的类膨胀。</p>

<p>装饰者模式比起继承更加灵活，一般来说，基类是抽象的Component还有一个具体的concreteComponent。这个模式的核心就是继承Component的Decorator类。，然后由Decorator类统一管理拓展的业务，也就是新增加的功能。</p>

<h5>Decorator类中必然有一个private的Component，这个Component来执行concreteComponent的核心操作，而继承Decorator的都是负责装饰这个concreteComponent的</h5>

<p><img src="/assets/pic/decorator.png" alt="" /></p>

<pre><code>
#include <iostream>
#include <string>
using namespace std;
class Beverage
{
protected:
     string description;
public:
     virtual string getDescription() = 0;
     virtual double cost() = 0;
};
class BeverageDecorator:public Beverage
{ 
     string getDescription()
     {
      return description;
     }
};
class Mocha:public BeverageDecorator
{
     Beverage* beverage;
public:
     Mocha(Beverage *beverage)
     {
         this->beverage = beverage;
     }
     string getDescription()
     {
         return beverage->getDescription()+" Mocha";
     }
     double cost()
     {
         return beverage->cost() + 0.2;
     }
};
class Milk:public BeverageDecorator
{
     Beverage* beverage;
public:
     Milk(Beverage *beverage)
     {
         this->beverage = beverage;
     }
     string getDescription()
     {
         return beverage->getDescription()+" Milk";
     }
     double cost()
     {
      return beverage->cost() + 0.1;
     }
};
class ConcreteBeverage:public Beverage
{
public:
     ConcreteBeverage()
     {
         description = "Espresso";
     }
     string getDescription()
     {
         return description;
     }
     double cost()
     {
         return 1.99;
     }
};
void main()
{
     //买个Espresso
     Beverage * beverage1 = new ConcreteBeverage;
     cout << beverage1->getDescription() + " $ " << beverage1->cost()<< endl;
     //买个Espresso+2份Mocha+1份Milk
     Beverage * beverage2 = new ConcreteBeverage;
     beverage2 = new Mocha(beverage2);
     beverage2 = new Mocha(beverage2);
     beverage2 = new Milk(beverage2);
     cout << beverage2->getDescription() + " $ " << beverage2->cost()<< endl;
}
</code></pre>


<p>装饰者模式的优点就是：</p>

<blockquote><p>1.Decorator与concreteComponent独立，不会相互耦合。</p>

<p>2.拓展性非常好，比如我们有father son grandson ，三层继承。通过装饰者模式，我们可以抽象为两层 father son DecoratorSon.这样很好的完成了变更。</p></blockquote>

<h5>缺点就是 多层继承容易带来复杂，维护性变差。需要适度使用，否则，很难维护！</h5>

<h6>因为我用的是C++实现，所以我使用了string类型拼接，达到装饰的目的。</h6>

<h6>在Java中我们可以使用@override重写抽象类执行的核心函数和在子类中配合新添加的业务逻辑和调用super（）方法从而调用父类函数，这样达到装饰的目的。</h6>
]]></content:encoded>
    </item>
    
    <item>
      <title>Commander Pattern and Chain of Responsibility Pattern with C++</title>
      <link href="http://www.lizhaozhong.info/2014/06/03/commander-pattern-and-chain-of-responsibility-pattern-with-c.html"/>
      <pubDate>2014-06-03T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/06/03/commander-pattern-and-chain-of-responsibility-pattern-with-c</guid>
      <content:encoded><![CDATA[<h1>命令模式 责任链模式 C++实现</h1>

<p>命令模式是一种高内聚的设计模式，这种模式主要有三类角色：
1.Receiver ———–就是实际要具体执行的具体函数
2.Commander ———-执行命令的操作在这里
3.Invoker ———-他是一个调用者的角色，接受Commander然后调用Receiver
这样使得调用方和执行方二者分离开来，实现了解耦。</p>

<p>有时候Receiver与Commander会合并，但在大型的项目，三者还是分离开来的。</p>

<h6>这种模式主要是解耦类与类之间复杂的关系。</h6>

<p>其实调用树就是 Invoker -> Commander -> Receiver</p>

<p><img src="/assets/pic/4746.png" alt="" /></p>

<pre><code>
#include <iostream>
using namespace std;
  
#define SAFE_DELETE(p) if (p) { delete p; p = NULL; }
  
class Receiver
{
public:
     void Action()
     {
          cout <<"Receiver->Action"<< endl;
     }
};
  
class Command
{
public:
     virtual void Execute() = 0;
};
  
class ConcreteCommand : public Command
{
public:
     ConcreteCommand(Receiver *pReceiver) : m_pReceiver(pReceiver){}
     void Execute()
     {
          m_pReceiver->Action();
     }
private:
     Receiver *m_pReceiver;
};
  
class Invoker
{
public:
     Invoker(Command *pCommand) : m_pCommand(pCommand){}
     void Invoke()
     {
          m_pCommand->Execute();
     }
private:
     Command *m_pCommand;
};
  
int main()
{
     Receiver *pReceiver = new Receiver();
     Command *pCommand = new ConcreteCommand(pReceiver);
     Invoker *pInvoker = new Invoker(pCommand);
     pInvoker->Invoke();
     SAFE_DELETE(pInvoker);
     SAFE_DELETE(pCommand);
     SAFE_DELETE(pReceiver);
     return 0;
}
</code></pre>


<blockquote><h6>有时候，command可以和receive合在一起。这样可以减少暴露在client中的类，使得更加解耦。我们在上面可以加入setCommand（）方法达到一样的效果。但是下面这种方式，比起通用类图，使得类之前联系减少，效果更好！</h6></blockquote>

<pre><code>
class Receiver
{
public:
     void Action()
     {
          cout<<"Receiver->Action"<< endl;
     }
};
  
class Command
{
public:
     virtual void Execute() = 0;
};
  
class ConcreteCommand : public Command
{
public:
     ConcreteCommand(){m_pReceiver = new Receiver();}
     void Execute()
     {
          m_pReceiver->Action();
     }
private:
     Receiver *m_pReceiver;
};
  
class Invoker
{
public:
     Invoker(Command *pCommand) : m_pCommand(pCommand){}
     void Invoke()
     {
          m_pCommand->Execute();
     }
private:
     Command *m_pCommand;
};
  
int main()
{
     Command *pCommand = new ConcreteCommand();
     Invoker *pInvoker = new Invoker(pCommand);
     pInvoker->Invoke();
     SAFE_DELETE(pInvoker);
     SAFE_DELETE(pCommand);
     return 0;
}
</code></pre>


<p>责任链模式非常高效。
他把请求和处理分开，请求者不用担心是谁处理的，处理者如果不能处理该请求，则这个处理请求会传递给下一个处理者尝试处理。这个原理主要是通过链表对象遍历做到的。
不过需要注意的是链表对象的遍历可能导致请求一直在寻找处理者，导致性能低下。</p>

<p>总的来说都是父类实现请求传递，在子类中实现请求的·处理。</p>

<p>但是要注意：</p>

<blockquote><p>1.一个请求到链的最后可能也没有处理，所以一定要配置得当.</p>

<p>2.责任链模式并不创建责任链。责任链的创建必须由系统的其它部分创建出来。</p>

<p>3.责任链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。一个链可以是一条线，一个树，也可以是一个环。</p></blockquote>

<p><img src="/assets/pic/chain-of-responsibility.png" alt="" /></p>

<pre><code>
#include <iostream>
#include <string>
using namespace std;
 
class Photo 
{
public:
    Photo(string s) : mTitle(s) 
    {
    cout << "Processing " << mTitle << " ...\n";
    }
 
private:
    string mTitle;
};
 
class PhotoProcessor
{
public:
    PhotoProcessor() : mNextProcessor(0){ }
 
public:
    void process(Photo &p) 
    {
        processImplementation(p);
        if (mNextProcessor != 0) 
            mNextProcessor->process(p);
    }
 
    virtual ~PhotoProcessor() { }
 
    void setNextProcessor(PhotoProcessor *p) {
        mNextProcessor = p;
    }
 
protected:
    virtual void processImplementation(Photo &a) = 0;
 
private:
    PhotoProcessor *mNextProcessor;
};
 
class Scale : public PhotoProcessor
{
public:
    enum SCALE { S50, S100, S200, S300, S500 };
    Scale(SCALE s) : mSCALE(s) { }
 
private:
    void processImplementation(Photo &a) {
        cout << "Scaling photo\n";
    }
 
    SCALE mSCALE;
};
 
class RedEye : public PhotoProcessor
{
private:
    void processImplementation(Photo &a) {
        cout << "Removing red eye\n";
    }
};
 
class Filter : public PhotoProcessor
{
private:
    void processImplementation(Photo &a) {
        cout << "Applying filters\n";
    }
};
 
class ColorMatch : public PhotoProcessor
{
private:
    void processImplementation(Photo &a)
    {
        cout << "Matching colors\n";
    }
};
 
void processPhoto(Photo &photo)
{   
    ColorMatch match;
    RedEye eye;
    Filter filter;
    Scale scale(Scale::S200);
    scale.setNextProcessor(&eye);
    eye.setNextProcessor(&match);
    match.setNextProcessor(&filter);
// scale -> eye -> match -> filter
//也就是说scale eye match filter都保存着下一个class，这样就形成了chain of responsibility
    scale.process(photo);
}
 
int main()
{
    Photo *p = new Photo("lzz");
    processPhoto(*p);
    return 0;
}
</code></pre>

]]></content:encoded>
    </item>
    
    <item>
      <title>Mediator模式C++实现</title>
      <link href="http://www.lizhaozhong.info/2014/05/22/mediatorc.html"/>
      <pubDate>2014-05-22T00:00:00+08:00</pubDate>
      <author>JasonLe</author>
      <guid>http://www.lizhaozhong.info/2014/05/22/mediatorc</guid>
      <content:encoded><![CDATA[<h1>中介者模式 C++实现</h1>

<p>中介者模式主要是为了解决类之间依赖关系的，有些类之间存在复杂的关系，这导致代码不具有可维护性。
中介者模式把这其中各类交换的函数统一放在mediator里面，每种colleague只需要和mediator交互就可以了。</p>

<p>中介者模式中，每个Colleague 维护一个 Mediator，当要进行通信时，每个具体的 Colleague 直接向 ConcreteMediator 发信息，至于信息发到哪里，则由 ConcreteMediator 来决定。</p>

<ol>
<li><p>ConcreteColleagueA 和 ConcreteColleagueB 不必维护对各自的引用，甚至它们也不知道各个的存在。</p></li>
<li><p>优点是，各个 Colleague 减少了耦合。</p></li>
</ol>


<h5>不过这种模式最大的缺点在于如果类之间交互特别复杂，容易造成class mediator体积巨大，这时我们要考虑多创建几个mediator来负责交互。</h5>

<h5>设计模式很多其实都是通过class强转成父类来产生不同的效果,比如Student -> Colleague的转换，然后通过Colleague来调用子类的函数。</h5>

<h5>C++中我们要通过Monitor(string n = “”):Colleage(n){};来实现子类通过父类够召唤术初始化。</h5>

<h5>在Java中，我们可以在构造方法中使用super（）函数，达到使用父类所有方法初始化的目的。</h5>

<p><img src="/assets/pic/mediapattern.png" alt="" /></p>

<pre><code>
#include<iostream>
#include<string>
#include <vector>
using namespace std;

class Colleage
{
private:
    string name;
    string content;
public:
    Colleage(string n = " "):name(n){};
    void set_name(string name)
    {
        this->name = name;
    }
    string get_name()
    {
        return this->name;
    }
    void set_content(string content)
    {
        this->content = content;
    }
    string get_content()
    {
        if(content.size() != 0)
            return content;
        else return "Copy that";
    }
    virtual void talk(){};

};

class Monitor : public Colleage
{
public:
    Monitor(string n = ""):Colleage(n){};
    virtual void talk()
    {
        cout<<"Monitor "<< get_name() << " Say" << get_content()<< endl;
    }
};

class Secretary : public Colleage
{
public:
    Secretary(string n = ""):Colleage(n){};
    virtual void talk()
    {
        cout<<"Secretary "<<get_name()<<" Say"<< get_content()<< endl;
    }
};

class StudentA : public Colleage
{
public:
    StudentA(string n = ""):Colleage(n){};
    virtual void talk()
    {
        cout<<"StudentA "<<get_name()<<" Say"<< get_content()<< endl;
    }
};

class StudentB : public Colleage
{
public:
    StudentB(string n = ""):Colleage(n){};
    virtual void talk()
    {
        cout<<"StudentB "<<get_name()<<" Say"<< get_content()<< endl;
    }
};

class Mediator
{
public:
    vector<Colleage*> studentList;
    virtual void add_student(Colleage *student)
    {
        studentList.push_back(student);
    };
    virtual void notify(Colleage *student){};    
};

class QQMediator : public Mediator
{
public:
    virtual void notify(Colleage *student)
    {
        student->talk();
        for(int i = 0 ; i < studentList.size() ; ++i)
        {            
            if(student != studentList[i])
            {
                studentList[i]->talk();
            }
        }
    };  
};


int main()
{
    QQMediator mediator;
    Monitor *studentMonitor = new Monitor("studentMonitor");
    Secretary *studentSecretary = new Secretary("studentSecretary");
    StudentA *studentA = new StudentA("studentA");
    StudentB *studentB = new StudentB("studentB");        

    mediator.add_student(studentSecretary);
    mediator.add_student(studentA);
    mediator.add_student(studentB);     

    studentMonitor->set_content("It's time to end the class");
    mediator.notify(studentMonitor);   
    return 0;
}

</code></pre>



]]></content:encoded>
    </item>
    
  </channel>
</rss>
