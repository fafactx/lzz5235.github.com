<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>place_your_blog_title_here</title>
    <link>place_your_blog_url_here</link>
    <atom:link href="place_your_blog_url_here/rss.xml" rel="self" type="application/rss+xml" />
    <description>place_your_blog_description_here</description>
    <language>place_your_blog_language_here</language>
    <pubDate>Tue, 15 Jul 2014 10:51:46 +0800</pubDate>
    <lastBuildDate>Tue, 15 Jul 2014 10:51:46 +0800</lastBuildDate>

    
    <item>
      <title>StatePattern with C++</title>
      <link>place_your_blog_url_here/2014/07/15/statepattern-with-c.html</link>
      <pubDate>15 Jul 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/07/15/statepattern-with-c</guid>
      <description>&lt;h1&gt;状态模式 C++实现&lt;/h1&gt;

&lt;p&gt;状态模式是一种封装模式，也就是说当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。&lt;/p&gt;

&lt;h3&gt;它有两种使用情况：（1）一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。（2）一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。如果if-else过于庞大，那么状态模式将是很好的选择。&lt;/h3&gt;

&lt;h3&gt;之前我的文章都见过这种方式，将具体的实现class都委托给一个封装类来执行，这种方式非常普遍！比如在访问者模式中，通过&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
void Accept( BaseVisitor *visitor )
{
   visitor-&gt;Visit( this );
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;来委托给visitor 执行concrete class！
这种模式适合在权限设计，条件分子判断设计中使用，当然了，也容易造成concrete class 膨胀！&lt;/p&gt;

&lt;p&gt;首先，我们要先说单状态的状态模式，这种模式，我们不需要使用if – else语句就可以通过状态切换，达到行为切换！&lt;/p&gt;

&lt;p&gt;状态模式的优点在于遵循了很好的开闭原则和单一职责原则，只要修改状态，我们修改一个子类就好了。&lt;/p&gt;

&lt;p&gt;但是存在的问题在于如果状态过多，那就会导致子类过多，发生类膨胀，所以在使用这个模式的时候要权衡好状态模式的利弊！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/StatePattern.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
 
class Context;
class State
{
public:
    virtual void Handle(Context* pContext)=0;
    ~State(){}
protected:
    State(){}
private:
};
class Context
{
public:
    Context(State* pState){this-&gt;_state = pState;}
    ~Context(){}
    void Request()
    {
        if(NULL != this-&gt;_state)
        {
            this-&gt;_state-&gt;Handle(this);
        }
    }
    void ChangeState(State* pState)
    {
        this-&gt;_state = pState;
    }
protected:
private:
    State* _state;
};
class ConcreteStateA;
class ConcreteStateC : public State
{
public:
    ConcreteStateC(){}
    ~ConcreteStateC(){}
    virtual void Handle(Context* pContext)
    {
        cout &lt;&lt; &quot;ConcreteStateC&quot; &lt;&lt; endl;
        pContext-&gt;ChangeState(new ConcreteStateA());
    }
protected:
private:
};
class ConcreteStateB : public State
{
public:
    ConcreteStateB(){}
    ~ConcreteStateB(){}
    virtual void Handle(Context* pContext)
    {
        cout &lt;&lt; &quot;ConcreteStateB&quot; &lt;&lt; endl;
        pContext-&gt;ChangeState(new ConcreteStateC());
    }
protected:
private:
};
class ConcreteStateA : public State
{
public:
    ConcreteStateA(){}
    ~ConcreteStateA(){}
    virtual void Handle(Context* pContext)
    {
        cout &lt;&lt; &quot;ConcreteStateA&quot; &lt;&lt; endl;
        pContext-&gt;ChangeState(new ConcreteStateB());
        //execute and change status
    }
protected:
private:
};
 
int main()
{
    State* pState = new ConcreteStateA();
    Context* pContext = new Context(pState);
    pContext-&gt;Request();
    pContext-&gt;Request();
    pContext-&gt;Request();
    pContext-&gt;Request();
    pContext-&gt;Request();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;接下来，多状态切换，我们使用switch case来判断。&lt;/p&gt;

&lt;h5&gt;另外如果业务需求某项业务有多个状态，通常都是一些枚举常量，状态的变化都是依靠大量的多分支判断语句来实现，此时应该考虑将每一种业务状态定义为一个State的子类。这样这些对象就可以不依赖于其他对象儿独立变化了。&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/multiState.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
 
class CContext;
class COpenningState;
class CCloseingState;
class CRunningState;
class CStoppingState;
 
COpenningState* CContext::pOpenningState = NULL;
CCloseingState* CContext::pCloseingState = NULL;
CRunningState* CContext::pRunningState = NULL;
CStoppingState* CContext::pStoppingState = NULL;
 
class CLiftState
{
public:
    CLiftState(void){}
    virtual ~CLiftState(void){}
    void SetContext(CContext *pContext){this-&gt;m_pContext = pContext;}
    virtual void Open() = 0;
    virtual void Close() = 0;
    virtual void Run() = 0;
    virtual void Stop() = 0;
protected:
    CContext *m_pContext;
};
 
 
 
class CCloseingState :  public CLiftState
{
public:
    CCloseingState(void){}
    ~CCloseingState(void){}
    void Open()
    {
        this-&gt;CLiftState::m_pContext-&gt;SetLiftState(CContext::pOpenningState);
        this-&gt;CLiftState::m_pContext-&gt;GetLiftState()-&gt;Open();
    }
    void Close(){cout &lt;&lt; &quot;Close....&quot; &lt;&lt; endl;}
    void Run()
    {
        this-&gt;CLiftState::m_pContext-&gt;SetLiftState(CContext::pRunningState);
        this-&gt;CLiftState::m_pContext-&gt;GetLiftState()-&gt;Run();
    }
    void Stop()
    {
        this-&gt;CLiftState::m_pContext-&gt;SetLiftState(CContext::pStoppingState);
        this-&gt;CLiftState::m_pContext-&gt;GetLiftState()-&gt;Stop();
    }
};
class COpenningState : public CLiftState
{
public:
    COpenningState(void){}
    ~COpenningState(void){}
    void Open(){cout &lt;&lt; &quot;Open....&quot; &lt;&lt; endl;}
    void Close()
    {
        this-&gt;CLiftState::m_pContext-&gt;SetLiftState(CContext::pCloseingState);
        this-&gt;CLiftState::m_pContext-&gt;GetLiftState()-&gt;Close();
    }
    void Run(){ }
    void Stop(){}
};
class CRunningState : public CLiftState
{
public:
    CRunningState(void){}
    ~CRunningState(void){}
    void Open(){}
    void Close(){}
    void Run(){cout&lt;&lt;&quot;Run....&quot;&lt;&lt; endl;}
    void Stop()
    {
        this-&gt;CLiftState::m_pContext-&gt;SetLiftState(CContext::pStoppingState);
        this-&gt;CLiftState::m_pContext-&gt;GetLiftState()-&gt;Stop();
    }
};
class CStoppingState : public CLiftState
{
public:
    CStoppingState(void){}
    ~CStoppingState(void){}
    void Open()
    {
        this-&gt;CLiftState::m_pContext-&gt;SetLiftState(CContext::pOpenningState);
        this-&gt;CLiftState::m_pContext-&gt;GetLiftState()-&gt;Open();
    }
    void Close(){}
    void Run()
    {
        this-&gt;CLiftState::m_pContext-&gt;SetLiftState(CContext::pRunningState);
        this-&gt;CLiftState::m_pContext-&gt;GetLiftState()-&gt;Run();
    }
    void Stop(){cout &lt;&lt; &quot;Stop....&quot; &lt;&lt; endl;}
};
class CContext
{
public:
    CContext(void)
    {
        m_pLiftState = NULL;
        pOpenningState = new COpenningState();
        pCloseingState = new CCloseingState();
        pRunningState = new CRunningState();
        pStoppingState = new CStoppingState();
    }
    ~CContext(void)
    {
        delete pOpenningState;
        pOpenningState = NULL;
        delete pCloseingState;
        pCloseingState = NULL;
        delete pRunningState;
        pRunningState = NULL;
        delete pStoppingState;
        pStoppingState = NULL;
    }
 
    CLiftState * GetLiftState(){return m_pLiftState;}
    void SetLiftState(CLiftState *pLiftState)
    {
        this-&gt;m_pLiftState = pLiftState;
        this-&gt;m_pLiftState-&gt;SetContext(this);
    }
    void Open(){this-&gt;m_pLiftState-&gt;Open();}
    void Close(){this-&gt;m_pLiftState-&gt;Close();}
    void Run(){this-&gt;m_pLiftState-&gt;Run();}
    void Stop(){this-&gt;m_pLiftState-&gt;Stop();}
 
    static COpenningState *pOpenningState;
    static CCloseingState *pCloseingState;
    static CRunningState *pRunningState;
    static CStoppingState *pStoppingState;
 
private:
    CLiftState *m_pLiftState;
};
int main()
{
    CContext context;
    CCloseingState closeingState;
    context.SetLiftState(&amp;closeingState);
    context.Close();
    context.Open();
    context.Run();
    context.Stop();
}

&lt;/code&gt;&lt;/pre&gt;


&lt;h4&gt;状态模式实现了非常好的封装，对外屏蔽了状态切换，状态的切换就是类的切换！&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>Create Design Pattern Comparison</title>
      <link>place_your_blog_url_here/2014/07/14/create-design-pattern-comparison.html</link>
      <pubDate>14 Jul 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/07/14/create-design-pattern-comparison</guid>
      <description>&lt;h1&gt;创建类模式比较&lt;/h1&gt;

&lt;p&gt;创建类模式包括工厂方法模式，建造者模式，抽象工厂模式，单例模式，原型模式，这些都是创建类的design pattern，可以创建class的创建。&lt;/p&gt;

&lt;p&gt;单例模式和原型模式比较简单，单例模式主要是在内存中保持一个对象，原型模式是指通过复制的方式产生新的对象。&lt;/p&gt;

&lt;p&gt;比较容易混淆的是工厂模式，抽象工厂模式和建造者模式。&lt;/p&gt;

&lt;p&gt;1.工厂模式和抽象工厂模式其实就是一个工厂生产一种product与一个工厂生产多种product的区别。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/Factory.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/AbstractFactory.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面主要来说一下工厂模式与建造者模式的区别。&lt;/p&gt;

&lt;p&gt;工厂模式如上面所说的，创造一个整体的class，至于class内部是无法定制的。比如class内部的attribute，如果需要定制的话，就要用到建造者模式。&lt;/p&gt;

&lt;p&gt;两种模式的class复杂度是不同的，工厂模式创建的产品是单一性质的产品，无法更改。而建造者模式创建的是一种复合的class，粒度不同，建造者模式制造的类更加精细。&lt;/p&gt;

&lt;p&gt;抽象工厂模式与建造者模式区别其实与上面所说的差不多，&lt;/p&gt;

&lt;p&gt;抽象工厂屏蔽了建造的过程，建造者模式更加容易建造崭新的产品。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/IMG_0433.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5&gt;总的来说从建造类的粒度来看：工厂模式&gt;抽象工厂模式&gt;建造者模式&lt;/h5&gt;

&lt;p&gt;我们要根据实际项目，来选择不同的粒度。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Keynote of Data Mining by myself</title>
      <link>place_your_blog_url_here/2014/07/11/the-keynote-of-data-mining-by-myself.html</link>
      <pubDate>11 Jul 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/07/11/the-keynote-of-data-mining-by-myself</guid>
      <description>&lt;h1&gt;数据挖掘—–自己整理的笔记&lt;/h1&gt;

&lt;p&gt;将近一个月没有更新博客，主要这期间有太多的考试，数据挖掘就是其中的一门比较难的课程，由于一直不敢怎么掉以轻心，总结了好长的笔记来复习。其实在读研期间也曾考虑学习Data Mining方向，虽说不是很擅长，但是通过这门课也算是data mining入了门。&lt;/p&gt;

&lt;p&gt;本科时候也学过这门课，那时候主要以计算为主，其中的原理有很多是云里雾里的感觉。这次的学习，使得我从数据的预处理，到关联规则，分类，聚类的算法，有了清晰的了解，并可以通过分析各个算法的优缺点，改进现有某个算法的存在的问题。&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;h5&gt;支持向量机（ SVM）是 一种具有高准确率的分类方法。但是SVM 处理大型数据元组集时，速度很慢试开发一种可伸缩的算法克服以上困难。&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;先使用层次聚类的CF-tree构造出微小的聚类簇&lt;/li&gt;
&lt;li&gt;找出聚类簇的质心代表该聚类，然后使用SVM进行训练,这样可以大大减少数据元组的数量。&lt;/li&gt;
&lt;li&gt;找出超平面来划分这些微型聚类簇。&lt;/li&gt;
&lt;li&gt;加入新的聚类簇来进行SVM训练&lt;/li&gt;
&lt;li&gt;直到没有新的聚类簇加入，分类完毕&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;又比如：&lt;/p&gt;

&lt;h5&gt;提升的基本思想:假设你是一位患者,有某某些症状.你选择咨询多位医生,假设你根据医生先前的诊断准确率,对每位医生的诊断赋予一个权重.然后这些加权诊断的组合最为最终的诊断,这就是提升的基本思想.&lt;/h5&gt;

&lt;p&gt;提高决策归纳准确性的原因:在提升方法中,权重赋予每个训练元组.迭代的学习K个分类器序列,学习得到分类器Mi之后,更新权重,使得其后的分类器Mi+1”更关注” Mi误分类的训练元组，最终提升的分类器M*组合每个个体分类器，其中每个分类器投票的权重是其准确率的函数。可以扩充提升算法，预测连续值。&lt;/p&gt;

&lt;p&gt;这个就是分类与聚类的结合，通过这种方式，我们克服了SVM的缺点，为我们所用！&lt;/p&gt;

&lt;p&gt;下面贴出我从数据预处理，OLAP，到数据各种分类算法的笔记：&lt;/p&gt;

&lt;p&gt;——————————————————————————————————–&lt;/p&gt;

&lt;p&gt;1.数据仓库的概念：      数据仓库是一种为信息分析提供了良好的基础并支持管理决策活动的分析环境，是面向主题的，集成的，稳定的，不可更新的,随时间变化的，分层次的,多维的集成数据集合。&lt;/p&gt;

&lt;p&gt;特点：     1主题与面向主题；2数据的集成性；3数据的不可更新性；4数据的时态性。为什么要建立数据仓库：为了使数据能够发挥其最佳效用，更好的为用户服务，才要建立数据仓库。它可以从各信息源提取决策需要的数据，加工后，存储到数据仓库中；并且可以提供用户的查询和决策分析的依据。&lt;/p&gt;

&lt;p&gt;为什么建立数据仓库&lt;/p&gt;

&lt;p&gt;}   提高两个系统的性能&lt;/p&gt;

&lt;p&gt;◦       DBMS是为OLTP而设计的：存储方式,索引, 并发控制, 恢复&lt;/p&gt;

&lt;p&gt;◦       数据仓库是为OLAP而设计：复杂的 OLAP查询, 多维视图，汇总&lt;/p&gt;

&lt;p&gt;}   不同的功能和不同的数据:&lt;/p&gt;

&lt;p&gt;◦       历史数据: 决策支持需要历史数据，而这些数据在操作数据库中一般不会去维护&lt;/p&gt;

&lt;p&gt;◦       数据汇总：决策支持需要将来自异种源的数据统一（如聚集和汇总）&lt;/p&gt;

&lt;p&gt;◦       数据质量: 不同的源使用不一致的数据表示、编码和格式，对这些数据进行有效的分析需要将他们转化后进行集成&lt;/p&gt;

&lt;p&gt;建立数据仓库过程：&lt;/p&gt;

&lt;p&gt;1.自顶向下法：由总体设计和规划开始，在技术成熟、商业理解透彻的情况下使用。   &lt;br/&gt;
2.自底向上法：以实验和原型开始，常用在模型和技术开发的初期，可以有效的对使用的技术和模型进行评估，降低风险。
3.混合方法：上述两者的结合&lt;/p&gt;

&lt;p&gt;从软件过程的观点&lt;/p&gt;

&lt;p&gt;1.瀑布式方法：在进行下一步前，每一步都进行结构化和系统的分析&lt;/p&gt;

&lt;p&gt;2.螺旋式方法：功能渐增的系统的快速产生，相继版本之间间隔很短&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数据预处理：&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;}   不完整数据的成因：&lt;/p&gt;

&lt;p&gt;◦       数据收集的时候就缺乏合适的值&lt;/p&gt;

&lt;p&gt;◦       数据收集时和数据分析时的不同考虑因素&lt;/p&gt;

&lt;p&gt;◦       人为/硬件/软件 问题&lt;/p&gt;

&lt;p&gt;}   噪声数据（不正确的值）的成因&lt;/p&gt;

&lt;p&gt;◦       数据收集工具的问题&lt;/p&gt;

&lt;p&gt;◦       数据输入时的 人为/计算机 错误&lt;/p&gt;

&lt;p&gt;◦       数据传输中产生的错误&lt;/p&gt;

&lt;p&gt;}   数据不一致性的成因&lt;/p&gt;

&lt;p&gt;◦       不同的数据源&lt;/p&gt;

&lt;p&gt;◦       违反了函数依赖性&lt;/p&gt;

&lt;p&gt;}   没有高质量的数据，就没有高质量的挖掘结果&lt;/p&gt;

&lt;p&gt;◦       高质量的决策必须依赖高质量的数据&lt;/p&gt;

&lt;p&gt;◦       数据仓库需要对高质量的数据进行一致地集成&lt;/p&gt;

&lt;p&gt;◦       数据预处理将是构建数据仓库或者进行数据挖掘的工作中占工作量最大的一个步骤&lt;/p&gt;

&lt;p&gt;}   数据清理&lt;/p&gt;

&lt;p&gt;◦       填写空缺的值，平滑噪声数据，识别、删除孤立点，解决不一致性&lt;/p&gt;

&lt;p&gt;}   数据集成&lt;/p&gt;

&lt;p&gt;◦       集成多个数据库、数据立方体或文件&lt;/p&gt;

&lt;p&gt;}   数据变换&lt;/p&gt;

&lt;p&gt;◦       规范化和聚集&lt;/p&gt;

&lt;p&gt;}   数据归约&lt;/p&gt;

&lt;p&gt;◦       得到数据集的压缩表示，它小得多，但可以得到相同或相近的结果&lt;/p&gt;

&lt;p&gt;}   数据离散化&lt;/p&gt;

&lt;p&gt;◦       数据归约的一部分，通过概念分层和数据的离散化来规约数据，对数字型数据特别重要&lt;/p&gt;

&lt;p&gt;3.数据仓库的数据模型有哪些？&lt;/p&gt;

&lt;p&gt;数据仓库的数据模型包括：星型数据模型、雪花型数据模型、星群型数据模型。&lt;/p&gt;

&lt;p&gt;其中星型模型包括一个中央表（事实表）和一系列的附表（维度表），附表环绕中央表，并产生关系，但不关联。雪花型数据模型设计其附表（维度表）被进一步规范化，分割出额外的表，产生的图形像雪花状。这种形式易于维护并节省存储空间。但表之间的关联多，影响系统的性能，其使用没有星型构架广泛。星群型架构的数据模型设计是多个主表（事实表）共享附表（维度表），其是星型的集合。对于数据集市使用星群数据模型，雪花模型。&lt;/p&gt;

&lt;h5&gt;4.OLAP操作主要优点&lt;/h5&gt;

&lt;p&gt;}   数据视图经过演化的、集成的数据&lt;/p&gt;

&lt;p&gt;}   OLAP面向市场（分析）历史的、汇总的数据&lt;/p&gt;

&lt;p&gt;}   访问模式只读查询（但很多是复杂的查询）&lt;/p&gt;

&lt;p&gt;}   访问数据量数百万个&lt;/p&gt;

&lt;p&gt;}   用户数数百个&lt;/p&gt;

&lt;p&gt;}   数据库规模100GB-数TB&lt;/p&gt;

&lt;p&gt;}   设计优先性高灵活性、端点用户自治&lt;/p&gt;

&lt;p&gt;◦       度量查询吞吐量、响应时间，复杂的 OLAP查询, 多维视图，汇总&lt;/p&gt;

&lt;p&gt;}   不同的功能和不同的数据:&lt;/p&gt;

&lt;p&gt;◦       历史数据: 决策支持需要历史数据，而这些数据在操作数据库中一般不会去维护&lt;/p&gt;

&lt;p&gt;◦       数据汇总：决策支持需要将来自异种源的数据统一（如聚集和汇总）&lt;/p&gt;

&lt;p&gt;◦       数据质量: 不同的源使用不一致的数据表示、编码和格式，对这些数据进行有效的分析需要将他们转化后进行集成&lt;/p&gt;

&lt;p&gt;5.OLAP操作方法&lt;/p&gt;

&lt;p&gt;}   上卷(roll-up):汇总数据&lt;/p&gt;

&lt;p&gt;◦       通过一个维的概念分层向上攀升或者通过维规约&lt;/p&gt;

&lt;p&gt;◦       当用维归约进行上卷时，一个或多个维由给定的数据立方体删除&lt;/p&gt;

&lt;p&gt;}   下钻(drill-down)：上卷的逆操作&lt;/p&gt;

&lt;p&gt;◦       由不太详细的数据到更详细的数据，可以通过沿维的概念分层向下或引入新的维来实现 (为给定数据添加更多细节)&lt;/p&gt;

&lt;p&gt;}   切片和切块(slice and dice)&lt;/p&gt;

&lt;p&gt;◦       切片操作在给定的数据立方体的一个维上进行选择，导致一个子方&lt;/p&gt;

&lt;p&gt;◦       切块操作通过对两个或多个维进行选择，定义子方&lt;/p&gt;

&lt;p&gt;}   转轴(pivot)&lt;/p&gt;

&lt;p&gt;◦       立方体的重定位，可视化，或将一个3维立方体转化为一个2维平面序列&lt;/p&gt;

&lt;p&gt;◦       转轴是一种可视化操作，通过转动当前数据的视图来提供一个数据的替代表示&lt;/p&gt;

&lt;p&gt;}   其他OLAP操作&lt;/p&gt;

&lt;p&gt;◦       钻过(drill_across)：执行涉及多个事实表的查询&lt;/p&gt;

&lt;p&gt;◦       钻透(drill_through)：使用关系SQL机制，钻到数据立方体的底层，到后端关系表&lt;/p&gt;

&lt;p&gt;◦       其他OLAP操作可能包括列出表中最高或最低的N项，以及计算移动平均值、增长率、利润、统计函数等等&lt;/p&gt;

&lt;p&gt;6.Apriori过程，不足&lt;/p&gt;

&lt;p&gt;Apriori算法利用频繁项集性质的先验知识（prior knowledge），通过逐层搜索的迭代方法，即将k-项集用于探察(k+1)-项集，来穷尽数据集中的所有频繁项集。Apriori算法利用的是Apriori性质：频繁项集的所有非空子集也必须是频繁的。&lt;/p&gt;

&lt;p&gt;Apriori算法由连接和剪枝两个步骤组成。&lt;/p&gt;

&lt;p&gt;连接：为了找Lk，通过Lk-1与自己连接产生候选k-项集的集合，该候选k项集记为Ck。&lt;/p&gt;

&lt;p&gt;Ck是Lk的超集，即它的成员可能不是频繁的，但是所有频繁的k-项集都在Ck中。因此可以通过扫描数据库，通过计算每个k-项集的支持度来得到Lk 。为了减少计算量，可以使用Apriori性质，即如果一个k-项集的(k-1)-子集不在Lk-1中，则该候选不可能是频繁的，可以直接从Ck删除。&lt;/p&gt;

&lt;p&gt;不足：1.要对数据进行多次扫描；2.会产生大量的候选项集；3.对候选项集的支持度计算非常繁琐；&lt;/p&gt;

&lt;p&gt;7.简述决策树归纳算法，分析优缺点&lt;/p&gt;

&lt;p&gt;常见的算法有ID3，C4.5，CART算法，他们都是采用贪心（非回溯）的方法。&lt;/p&gt;

&lt;p&gt;树以代表训练样本的单个节点（N）开始
如果样本都在同一个类，则该节点成为树叶，并用该类标记
否则，算法调用Attribute_selection_method，选择能够最好的将样本分类的属性；确定“分裂准则”，指出“分裂点”或“分裂子集”。
对测试属性每个已知的值，创建一个分支，并以此划分元组
算法使用同样的过程，递归的形成每个划分上的元组决策树。一旦一个属性出现在一个节点上，就不在该节点的任何子节点上出现
递归划分步骤停止的条件：划分D（在N节点提供）的所有元组属于同一类，没有剩余属性可以用来进一步划分元组——使用多数表决，没有剩余的样本，给定分支没有元组，则以D中多数类创建一个树叶
优点(1) 速度快：计算量相对较小，且容易转化成分类规则。只要沿着树根向下一直走到叶，沿途的分裂条件就能够唯一确定一条分类的谓词。&lt;/p&gt;

&lt;p&gt;(2) 准确性高：挖掘出的分类规则准确性高，便于理解，决策树可以清晰的显示哪些字段比较重要。&lt;/p&gt;

&lt;p&gt;缺点(1) 缺乏伸缩性：由于进行深度优先搜索，所以算法受内存大小限制，难于处理大训练集。(2) 要多次扫描数据集，导致低效。决策树技术也可能产生子树复制和碎片问题。&lt;/p&gt;

&lt;p&gt;8.简述人工神经网络分类方法及其优缺点&lt;/p&gt;

&lt;p&gt;人工神经网络分类方法主要包括，贝叶斯信念网络，向后传播分类，SVM，频繁模式分类，遗传算法。（人工神经网络分类方法很多都是监督学习，模型的学习在被告知每个训练样本属于哪个类的“指导”下进行，新数据使用训练数据集中得到的规则进行分类）贝叶斯信念网络通过计算元素的相关度，将元素进行划分。后向传播是一种神经网络学习算法；神经网络是一组连接的输入/输出单元，每个连接都与一个权相连。在学习阶段，通过调整神经网络的权，使得能够预测输入样本的正确标号来学习。SVM使用一种非线性的映射，将原训练数据映射到较高的维，使用一个适当的对足够高维的非线性映射，两类的数据总可以被超平面分开。遗传算法对于一个规模为N的种群S,按每个染色体si∈S的选择计算适应度，进行复制操作。&lt;/p&gt;

&lt;p&gt;}   优点：预测精度总的来说较高，健壮性好，训练样本中包含错误时也可正常工作&lt;/p&gt;

&lt;p&gt;，输出可能是离散值、连续值或者是离散或量化属性的向量值，对目标进行分类较快&lt;/p&gt;

&lt;p&gt;}   缺点：训练（学习）时间长，蕴涵在学习的权中的符号含义很难理解，很难和专业领域知识相整合&lt;/p&gt;

&lt;p&gt;提高分类准确率的技术：装袋，提升，adaboost。&lt;/p&gt;

&lt;p&gt;}   Bagging技术和boosting技术都通过将T个学习得到的分类法C1,C2…CT组合起来，从而创造一个改进的分类法C*&lt;/p&gt;

&lt;p&gt;}   Boosting技术，每个训练样本赋予一个权值Ct的权值取决于其错误率&lt;/p&gt;

&lt;p&gt;48、简述决策树归纳算法，分析优缺点&lt;/p&gt;

&lt;p&gt;常见的算法有ID3，C4.5，CART算法，他们都是采用贪心（非回溯）的方法。&lt;/p&gt;

&lt;p&gt;树以代表训练样本的单个节点（N）开始
如果样本都在同一个类，则该节点成为树叶，并用该类标记
否则，算法调用Attribute_selection_method，选择能够最好的将样本分类的属性；确定“分裂准则”，指出“分裂点”或“分裂子集”。
对测试属性每个已知的值，创建一个分支，并以此划分元组
算法使用同样的过程，递归的形成每个划分上的元组决策树。一旦一个属性出现在一个节点上，就不在该节点的任何子节点上出现
递归划分步骤停止的条件：划分D（在N节点提供）的所有元组属于同一类，没有剩余属性可以用来进一步划分元组——使用多数表决，没有剩余的样本，给定分支没有元组，则以D中多数类创建一个树叶
优点(1) 速度快：计算量相对较小，且容易转化成分类规则。只要沿着树根向下一直走到叶，沿途的分裂条件就能够唯一确定一条分类的谓词。&lt;/p&gt;

&lt;p&gt;(2) 准确性高：挖掘出的分类规则准确性高，便于理解，决策树可以清晰的显示哪些字段比较重要。&lt;/p&gt;

&lt;p&gt;缺点(1) 缺乏伸缩性：由于进行深度优先搜索，所以算法受内存大小限制，难于处理大训练集。(2) 要多次扫描数据集，导致低效。决策树技术也可能产生子树复制和碎片问题。&lt;/p&gt;

&lt;p&gt;61、贝叶斯网络的特点：&lt;/p&gt;

&lt;p&gt;（1）贝叶斯分类提供了一种用图形模型来捕获特定领域的先验知识的方法，网络还可以用来对变量间的因果依赖关系进行编码。（2）构造网格可能既费时又费力，但一旦网格结构确定下来，添加新变量就十分容易。（3）贝叶斯网络很适合处理不完整的数据。（4）因为数据和先验知识以概率方式结合起来了，所以该方法对模型的过分拟合问题是非常鲁棒的。&lt;/p&gt;

&lt;p&gt;62、神经网络的特点&lt;/p&gt;

&lt;p&gt;（1）对于噪声数据的承受能力高，对未经训练的数据的模式分类能力强。（2）神经网络可以处理冗余特征，对训练数据中的噪声非常敏感。（3）不像大部分的决策数算法，它非常适合连续值得输入和输出。(4)神经网络算法是固有并行的，可以使用并行技术来加快计算过程。(5)神经网络权值学习使用的梯度下降方法经常会收敛到局部极小值。训练神经网络是一个很耗时的过程，而测试样例分类时非常快。&lt;/p&gt;

&lt;p&gt;51、分类的过程包括获取数据、预处理、分类器设计和分类决策。&lt;/p&gt;

&lt;p&gt;2、分类器设计阶段包含三个过程：划分数据集、分类器构造和分类器测试。&lt;/p&gt;

&lt;p&gt;3、分类问题中常用的评价准则有精确度、查全率和查准率和集合均值。&lt;/p&gt;

&lt;p&gt;52、聚类分析包括连续型、二值离散型、多值离散型和混合类型4种类型描述属性的相似度计算方法。&lt;/p&gt;

&lt;p&gt;63、K 最邻近分类特点：&lt;/p&gt;

&lt;p&gt;（1）由于KNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，KNN方法较其他方法更为适合。(2) 当样本不平衡时，如一个类的样本容量很大，而其他类样本容量很小时，有可能导致当输入一个新样本时，该样本的K个邻居中大容量类的样本占多数。数量影响运行结果。(可以采用权值的方法来改进)。(3)该方法的另一个不足之处是计算量较大。(4)准确率受噪声影响。&lt;/p&gt;

&lt;h4&gt;9,。简述主要的聚类方法，分析聚类算法以及各自特点。&lt;/h4&gt;

&lt;p&gt;划分方法：K-均值，K-中心点，CLARA&lt;/p&gt;

&lt;p&gt;给定一个n个对象或元组的数据库，一个划分方法构建数据的k个划分，每个划分表示一个簇，并且k&amp;lt;=n。每个组至少包含一个对象，每个对象属于且仅属于一个组。&lt;/p&gt;

&lt;p&gt;k-平均算法由簇的平均值来代表整个簇。噪声，离群点产生较大影响，不适用于非凸形状的簇，需要指定k。&lt;/p&gt;

&lt;p&gt;k中心点算法，由处于簇的中心区域的某个值代表整个簇。每次迭代复杂度比较大，需要指定k。&lt;/p&gt;

&lt;p&gt;CLARA ，先抽样，然后用样本进行k中心点算法。&lt;/p&gt;

&lt;p&gt;基于距离的聚类方法的缺点：只能发现球状的簇，难以发现任意形状的簇。&lt;/p&gt;

&lt;p&gt;层次的方法：对给定数据对象集合进行层次分解&lt;/p&gt;

&lt;p&gt;自底向上方法（凝聚AGNES）：开始将每个对象作为单独的一个组，然后相继的合并相近的对象或组，直到所有的组合并为一个，或者达到一个终止条件。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;输入:包含n个对象的数据库，终止条件簇的数目k&lt;/p&gt;

&lt;p&gt;输出:k个簇，达到终止条件规定簇数目&lt;/p&gt;

&lt;p&gt;(1)将每个对象当成一个初始簇；&lt;/p&gt;

&lt;p&gt;(2)Repeat&lt;/p&gt;

&lt;p&gt;(3) 根据两个簇中最近的数据点（单链接）找到最近的两个簇；&lt;/p&gt;

&lt;p&gt;(4) 合并两个簇，生成新的簇的集合；&lt;/p&gt;

&lt;p&gt;(5)Until 达到定义的簇的数目&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;AGNES算法比较简单，但经常会遇到合并点选择的困难。如果在某一步没有很好地选择出合并点，很可能导致低质量的聚类结果。而且此算法没有良好的可伸缩性，算法复杂度较高。&lt;/p&gt;

&lt;p&gt;自顶向下方法（分裂DIANA）：开始将所有的对象置于一个簇中，在迭代的每一步，一个簇被分裂为多个更小的簇，直到最终每个对象在一个单独的簇中，或达到一个终止条件&lt;/p&gt;

&lt;p&gt;输入：包含n个对象的数据库，终止条件簇的数目k&lt;/p&gt;

&lt;p&gt;输出：k个簇，达到终止条件规定簇数目&lt;/p&gt;

&lt;p&gt;（1）将所有对象整个当成一个初始簇&lt;/p&gt;

&lt;p&gt;（2） For ( i=1;i!=k; i++)&lt;/p&gt;

&lt;p&gt;（3） 在所有簇中挑选出具有最大直径的簇c；&lt;/p&gt;

&lt;p&gt;（4） 找出簇c里与其他点平均相异度最大的一个点放入splinter group，剩余的放入old party中。&lt;/p&gt;

&lt;p&gt;（5） Repeat&lt;/p&gt;

&lt;p&gt;（6） 在old party里找出到splinter group中点的最近距离不大于old party中点的最近距离的点，并将该点加入splinter group&lt;/p&gt;

&lt;p&gt;（7）  Until 没有新的old party的点被分配给splinter group；&lt;/p&gt;

&lt;p&gt;（8）  Splinter group 和old party为被选中的簇分裂成的两个簇，与其他簇一起组成新的簇集合&lt;/p&gt;

&lt;p&gt;（9）  end for&lt;/p&gt;

&lt;p&gt;（9）  END&lt;/p&gt;

&lt;p&gt;缺点：合并或分裂的步骤不能被撤销。类之间不能交换对象。如果在某步没有选择好分裂点，可能会导致低质量的聚类结果。大数据集不太适用。&lt;/p&gt;

&lt;p&gt;BIRCH(聚类特征树): 首先使用层次聚类算法将对象分组成微簇，然后用另一个聚类方法对这些微簇进行宏聚类。&lt;/p&gt;

&lt;p&gt;算法第一阶段：构造CF树（两个参数：分枝因子B和阈值T）第二阶段：用选定的聚类算法对叶结点进行聚类&lt;/p&gt;

&lt;p&gt;分枝因子B：定义节点的分支最大个数  阈值T：定义叶结点中子簇的最大直径&lt;/p&gt;

&lt;p&gt;CF 树的构造过程实际上是一个数据点的插入过程&lt;/p&gt;

&lt;p&gt;(1) 从根节点root 开始递归往下，计算当前条目与要插入数据点之间的距离，寻找距离最小的那个路径，直到找到与该数据点最接近的叶节点中的条目。&lt;/p&gt;

&lt;p&gt;(2) 比较计算出的距离是否小于阈值T，如果小于则当前条目吸收该数据点；反之，则继续第三步。&lt;/p&gt;

&lt;p&gt;(3) 判断当前条目所在叶节点的条目个数是否小于L，如果是，则直接将数据点插入作 为该数据点的新条目，否则需要分裂该叶节点。分裂的原则是寻找该叶节点中距离最远的两 个条目并以这两个条目作为分裂后新的两个叶节点的起始条目，其他剩下的条目根据距离最 小原则分配到这两个新的叶节点中，删除原叶节点并更新整个CF 树。&lt;/p&gt;

&lt;p&gt;基于密度的方法：DBSCAN，OPTICS，DENCLUE&lt;/p&gt;

&lt;p&gt;DBSCAN，OPTICS， DENCLUE：基于连接和密度函数：只要临近区域的密度（对象或数据点的数目）超过某个临界值，就继续聚类。优点：可以过滤掉“噪声”和“离群点”，发现任意形状的簇。需要定义密度参数作为终结条件&lt;/p&gt;

&lt;p&gt;基于网格的方法: 基于多层粒度结构，把对象空间量化为有限数目的单元，形成一个网格结构。所有的聚类都在这个网格结构上进行。&lt;/p&gt;

&lt;p&gt;STING，CLIQUE，优点：处理数度快，缺点：簇边界都是竖直的，降低簇的质量和精确性。&lt;/p&gt;

&lt;p&gt;基于模型的方法：为每个簇假定一个模型，寻找数据对给定模型的最佳拟合。&lt;/p&gt;

&lt;p&gt;42、K-均值 划分方法&lt;/p&gt;

&lt;p&gt;给定k 值, k -均值算法 通过以下4个步骤实现:&lt;/p&gt;

&lt;p&gt;随机选择k个对象，每个对象初始地代表一个簇的平均值或中心；&lt;/p&gt;

&lt;p&gt;其余每个对象，根据其与各个簇中心的距离，将它赋给最近的簇；&lt;/p&gt;

&lt;p&gt;重新计算每个簇的平均值 ；&lt;/p&gt;

&lt;p&gt;重复此过程，直至准则函数收敛。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;K-均值聚类法的优缺点：&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;缺点:  在 K-means 算法中 K 是事先给定的，这个 K 值的选定是非常难以估计的。&lt;/p&gt;

&lt;p&gt;在K-means 算法中，首先需要根据初始聚类中心来确定一个初始划分，然后对初始划分进行优化。这个初始聚类中心的选择对聚类结果有较大的影响，一旦初始值选择的不好，可能无法得到有效的聚类结果。&lt;/p&gt;

&lt;p&gt;从 K-means 算法框架可以看出，该算法需要不断地进行样本分类调整，不断地计算调整后的新的聚类中心，因此当数据量非常大时，算法的时间开销是非常大的。&lt;/p&gt;

&lt;p&gt;对“噪声”数据敏感。&lt;/p&gt;

&lt;p&gt; 优点：   本算法确定的K个划分到达平方误差最小。当聚类是密集的，且类与类之间区别明显时，效果较好。对于处理大数据集，这个算法是相对可伸缩和高效的，计算的复杂度为O(NKt)，其中N是数据对象的数目，t是迭代的次数。一般来说，K&amp;lt;&amp;lt;N，t&amp;lt;&amp;lt;N 。&lt;/p&gt;

&lt;p&gt;57、K中心点算法的优缺点：&lt;/p&gt;

&lt;p&gt;优点：    对噪声不敏感，具有较强的数据鲁棒性。&lt;/p&gt;

&lt;p&gt;缺点:     聚类过程的高耗时性，计算速度慢，计算量大：通过迭代来寻找最佳的聚类中心点集时，需要反复地在非中心点对象与中心点对象之间进行最近邻搜索，从而产生大量非必需的重复计算，聚类过程缓慢，不能满足实际应用的需求。&lt;/p&gt;

&lt;p&gt;43、DBSCAN算法&lt;/p&gt;

&lt;p&gt;l   任选一对象 p；&lt;/p&gt;

&lt;p&gt;l   检索所有从p关于ε和MinPts 密度可达的对象；&lt;/p&gt;

&lt;p&gt;l   如果 p 是核心对象, 则创建一个新簇；&lt;/p&gt;

&lt;p&gt;l   如果 p 是边界点, 无任何对象是从p关于ε和MinPts 密度可达的对象，DBSCAN 访问数据库中的下一对象；&lt;/p&gt;

&lt;p&gt;l   继续此过程直到所有的点已处理。&lt;/p&gt;

&lt;p&gt; 数据挖掘在软件工程中应用：&lt;/p&gt;

&lt;blockquote&gt;&lt;h5&gt;1.软件漏洞检测用于找出软件开发过程中的错误或漏洞，以便及时进行修正，保证软件可靠性和质量。选择合适的数据挖掘模型进行训练和验证。根据项目需求选择合适的挖掘方法，为该方法生成训练集和测试集，通过比较结果选择最合适的方法；通过前面步骤中的方法对软件漏洞进行分类、定位和描述。找出未知的漏洞，根据一定规则对漏洞进行分类和描述。&lt;/h5&gt;

&lt;h5&gt;2.开源软件挖掘中最常用的方法之一是克隆代码检测，通常情况下，OSS 之间共用代码的情况是非常普遍的，有实验表明50%以上的源文件被应用到两个以上的开源项目中。因此就可以使用克隆代码检测的方法对单个软件内以及两个软件之间的代码进行检测。克隆代码就是以代码复用为目的而进行拷贝和粘贴的代码段，对克隆代码进行检测可以有效防止漏洞的拷贝性传播，另外还有利于软件在演化过程中的维护。&lt;/h5&gt;

&lt;h5&gt;3.版本控制系统（如CVS，SVN，Visual SourceSafe ，Git等）用以确保项目参与者所编辑的同一档案得到统一的，全局的更新。目前几乎所有的软件开发都会采用版本控制系统来管理软件开发活动。当前对版本控制信息的挖掘应用基本都是对软件变更历史进行挖掘的，用以发现不同程序模块及其子系统之间的相互依赖关系，从而预测程序漏洞的引入方式或者未来的变化。通过以上挖掘活动，可以有效地降低系统后期维护代价，预防一些因变更而引入的漏洞，从而为软件系统的后期维护提供警示作用，为项目的管理及相关决策提供重要的参考依据。&lt;/h5&gt;&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Flyweight Pattern with C++</title>
      <link>place_your_blog_url_here/2014/06/20/flyweight-pattern-with-c.html</link>
      <pubDate>20 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/20/flyweight-pattern-with-c</guid>
      <description>&lt;h1&gt;享元模式 C++实现&lt;/h1&gt;

&lt;p&gt;享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例数据除了几个参数外基本都是相同的。有时就能够大幅度地减少实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。&lt;/p&gt;

&lt;p&gt;这种模式可以运用共享技术有效地支持大量细粒度的对象。适合具有缓冲池的场景。&lt;/p&gt;

&lt;p&gt;首先我们要分清楚享元模式的内部状态和外部状态。&lt;/p&gt;

&lt;p&gt;内部状态：在享元对象内部并且不会随环境改变而改变的共享部分，可以称为是享元对象的内部状态，比如base class中的member&lt;/p&gt;

&lt;p&gt;外部状态：而随环境改变而改变的，取决于应用环境，或是实时数据，这些不可以共享的东西就是外部状态了。比如存在的map的key值&lt;/p&gt;

&lt;p&gt;内部状态存储于ConcreteFlyweight对象之中；而外部状态则由Client对象存储或计算。&lt;/p&gt;

&lt;h4&gt;当用户调用Flyweight对象的操作时，将该状态传递给它。&lt;/h4&gt;

&lt;h4&gt;外部状态有一个factory，负责维护外部状态，并把外部状态和class放入container中。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/flyweight.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;hash_map&gt;
using namespace std;
 
class Flyweight
{
public:
    //操作外部状态extrinsicState
    virtual void Operation(const string&amp; extrinsicState)=0;
    string GetIntrinsicState()
    {
        return this-&gt;_intrinsicState;
    }
    virtual ~Flyweight(){}
protected:
    Flyweight(string intrinsicState)
    {
        this-&gt;_intrinsicState = intrinsicState;
    }
private:
    //内部状态，也可以放在ConcreteFlyweight中
    string _intrinsicState;
};
 
class ConcreteFlyweight:public Flyweight
{
public:
    virtual void Operation(const string&amp; extrinsicState)
    {
        cout &lt;&lt; this-&gt;GetIntrinsicState() &lt;&lt; endl;
        cout &lt;&lt; extrinsicState &lt;&lt; endl;
    }
    ConcreteFlyweight(string intrinsicState):Flyweight(intrinsicState){}
    ~ConcreteFlyweight(){}
};
 
class UnsharedConcreteFlyweight:public Flyweight
{
public:
    virtual void Operation(const string&amp; extrinsicState)
    {
        cout &lt;&lt; extrinsicState &lt;&lt; endl;
    }
    UnsharedConcreteFlyweight(string intrinsicState):Flyweight(intrinsicState){}
    ~UnsharedConcreteFlyweight(){}
};
 
class FlyweightFactory
{
public:
    FlyweightFactory(){}
    ~FlyweightFactory(){}
    //获得一个请求的Flyweight对象
    Flyweight* GetFlyweight(string key)
    {
        if(m_mapFly.find(key)!=m_mapFly.end())
        {
            return m_mapFly[key];
        }
        //Flyweight* fly = new ConcreteFlyweight(key);
        Flyweight* fly = new UnsharedConcreteFlyweight(key);
        this-&gt;m_mapFly.insert(pair&lt;string,Flyweight*&gt;(key,fly));
        return fly;
    }
    //获取容器中存储的对象数量
    void GetFlyweightCount()
    {
        cout &lt;&lt; this-&gt;m_mapFly.size() &lt;&lt; endl;
    }
protected:
private:
    //保存内部状态对象的容器
    hash_map&lt;string,Flyweight*&gt; m_mapFly;
};
 
int main()
{
    //外部状态extrinsicState
    string extrinsicState = &quot;ext&quot;;
 
    //工厂对象，工厂对象
    FlyweightFactory* fc = new FlyweightFactory();
 
    Flyweight* fly = fc-&gt;GetFlyweight(&quot;hello&quot;);
    fly = fc-&gt;GetFlyweight(&quot;hello1&quot;);
 
    fly = fc-&gt;GetFlyweight(&quot;hello&quot;);
 
    //应用外部状态
    fly-&gt;Operation(&quot;hello3&quot;);
 
    fc-&gt;GetFlyweightCount();
 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;线程环境下，必须使用锁变量。结局这种问题的方式，就是使用外部类来当做key值，但是这又会出现另一个问题：维护一个container。class的效率明显比string类型低。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/lcl_data/article/details/8974679&quot;&gt;http://blog.csdn.net/lcl_data/article/details/8974679&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/library/th79x793.aspx&quot;&gt;http://msdn.microsoft.com/zh-cn/library/th79x793.aspx&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bridge Pattern with C++</title>
      <link>place_your_blog_url_here/2014/06/19/bridge-pattern-with-c.html</link>
      <pubDate>19 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/19/bridge-pattern-with-c</guid>
      <description>&lt;h1&gt;桥梁模式 C++实现&lt;/h1&gt;

&lt;p&gt;桥梁模式主要解决多层继承，比如我们可以想想，人可以分为男人女人，人又有不同的行为。如果把这个两个class继承，也就意味着是男人行为A，男人行为B。女人行为A，女人行为B。
这种方式非常难以扩展，所以桥梁模式派上用场，它将表示和实现解耦,两者可以独立的变化。&lt;/p&gt;

&lt;h5&gt;也就是抽象出人和行为，然后人调用行为，减少了继承的class。&lt;/h5&gt;

&lt;p&gt;其中这种模式又有一些像策略模式，又有一些像建造者模式。&lt;/p&gt;

&lt;h5&gt;当我们考虑一个对象的多个变化因素可以动态变化的时候，考虑使用桥接模式&lt;/h5&gt;

&lt;p&gt;优点&lt;/p&gt;

&lt;p&gt;1.将实现抽离出来，再实现抽象，使得对象的具体实现依赖于抽象，满足了依赖倒转原则。&lt;/p&gt;

&lt;p&gt;2.将可以共享的变化部分，抽离出来，减少了代码的重复信息。&lt;/p&gt;

&lt;p&gt;3.对象的具体实现可以更加灵活，可以满足多个因素变化的要求。&lt;/p&gt;

&lt;p&gt;缺点&lt;/p&gt;

&lt;p&gt;1.客户必须知道选择哪一种类型的实现。&lt;/p&gt;

&lt;p&gt;如果我们用山寨工厂和房地产工厂生产产品做例子，非常清晰易懂。&lt;/p&gt;

&lt;h4&gt;这里我们要知道class IProduct中有两个虚基类，用于动态绑定！&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/bridge.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;list&gt;
using namespace std;
 
class IProduct
{
public:
    IProduct(void)
    {
    }
    virtual ~IProduct(void)
    {
    }
    virtual void BeProducted() = 0;
    virtual void BeSelled() = 0;
};
 
class CNewCorp
{
public:
    CNewCorp(IProduct *pproduct)
    {
        this-&gt;m_pProduct = pproduct;
    }
    virtual ~CNewCorp(void){}
    void MakeMoney()
    {
        //每个公司都是一样，先生产
        this-&gt;m_pProduct-&gt;BeProducted();
        //然后销售
        this-&gt;m_pProduct-&gt;BeSelled();
    }
private:
    IProduct *m_pProduct;
};
class CHouse : public IProduct
{
public:
    CHouse(void){}
    ~CHouse(void){}
    void BeProducted(){cout &lt;&lt; &quot;生产出的房子是这个样子的...&quot; &lt;&lt; endl;}
    void BeSelled(){cout &lt;&lt; &quot;生产出的房子卖出去了...&quot; &lt;&lt; endl;}
};
 
class CClothes : public IProduct
{
public:
    CClothes(void){}
    ~CClothes(void){}
    void BeProducted(){cout &lt;&lt; &quot;生产出的衣服是这个样子的...&quot; &lt;&lt; endl;}
    void BeSelled(){cout &lt;&lt; &quot;生产出的衣服卖出去了...&quot; &lt;&lt; endl;}
};
 
class CNewHouseCorp : public CNewCorp
{
public:
    CNewHouseCorp(CHouse *pHouse):CNewCorp(pHouse){}
    ~CNewHouseCorp(void){}
    void MakeMoney()
    {
        this-&gt;CNewCorp::MakeMoney();
        cout &lt;&lt; &quot;房地产公司赚大钱了...&quot; &lt;&lt; endl;
    }
};
 
class CIPod :public IProduct
{
public:
    CIPod(void){}
    ~CIPod(void){}
    void BeProducted(){cout &lt;&lt; &quot;生产出的ipod是这个样子的...&quot; &lt;&lt; endl;}
    void BeSelled(){ cout &lt;&lt; &quot;生产出的ipod卖出去了...&quot; &lt;&lt; endl;}
};
 
class CShanZhaiCorp : public CNewCorp
{
public:
    CShanZhaiCorp(IProduct *pproduct): CNewCorp(pproduct){}
    ~CShanZhaiCorp(void){}
    void MakeMoney()
    {
        this-&gt;CNewCorp::MakeMoney();
        cout &lt;&lt; &quot;我赚钱呀...&quot; &lt;&lt; endl;
    }
};
void DoNewRun1()
{
    cout &lt;&lt; &quot;----------房地产公司是这样运行的----------&quot; &lt;&lt; endl;
    CHouse house;
    CNewHouseCorp newHouseCorp(&amp;house);
    newHouseCorp.MakeMoney();
    cout &lt;&lt; endl;
 
    cout &lt;&lt; &quot;----------山寨公司是这样运行的----------&quot; &lt;&lt; endl;
    CClothes clothes;
    CShanZhaiCorp shanZhaiCorp(&amp;clothes);
    shanZhaiCorp.MakeMoney();
    cout &lt;&lt; endl;
}
 
void DoNewRun2()
{
    cout &lt;&lt; &quot;----------房地产公司是这样运行的----------&quot; &lt;&lt; endl;
    CHouse house;
    CNewHouseCorp newHouseCorp(&amp;house);
    newHouseCorp.MakeMoney();
    cout &lt;&lt; endl;
 
    cout &lt;&lt; &quot;----------山寨公司是这样运行的----------&quot; &lt;&lt; endl;
    CIPod ipod;
    CShanZhaiCorp shanZhaiCorp(&amp;ipod);
    shanZhaiCorp.MakeMoney();
    cout &lt;&lt; endl;
}
 
int main()
{
    DoNewRun1();
 
    DoNewRun2();
    return 0;
}
 &lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;这里我们要说明的是Java中我们可以使用super.func()的方式调用基类，在C++中，我们直接this-&gt;CNewCorp::MakeMoney();来调用基类&lt;/p&gt;

&lt;p&gt;另外，我们要深刻理解动态绑定的灵活性！&lt;/p&gt;

&lt;p&gt;客户直接使用CNewHouseCorp和CShanZhaiCorp类.&lt;/p&gt;

&lt;h4&gt;在main()函数里构造产品，然后传到这两个类里。这两个类的MakeMoney()函数，先调用基类的MakeMoney()，然后分别执行各自的逻辑。各自逻辑就是子类的具体实现（concreteimplement）&lt;/h4&gt;

&lt;p&gt;参考&lt;a href=&quot;http://www.cnblogs.com/jiese/p/3164940.html&quot;&gt;http://www.cnblogs.com/jiese/p/3164940.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Visitor Pattern with C++</title>
      <link>place_your_blog_url_here/2014/06/17/visitor-pattern-with-c.html</link>
      <pubDate>17 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/17/visitor-pattern-with-c</guid>
      <description>&lt;h1&gt;访问者模式 C++实现&lt;/h1&gt;

&lt;p&gt;访问者模式，顾名思义就是使用vistor类来访问其他类的intern数据，而不改变intern的数据结构和代码。
这样可以分开数据显示和业务逻辑，使得代码更加清晰。&lt;/p&gt;

&lt;p&gt;访问者模式的优点就是：灵活度非常高，有优秀的拓展性。
缺点就是：不依赖抽象元素，违反了依赖倒置的原则，直接依赖实现类，拓展实现类比较难。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;访问者模式和迭代器模式有相同点又有不同点。
相同点都是访问具体的实现类。
不同点在于迭代器模式只能访问相同由base class引用来的class或者interface的数据，而访问者模式可以访问不同的class，不再依赖base class&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;总的来说 访问者模式适用范围大于迭代器模式的范围！&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/visitor.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面这种方式是使用不同访问者定义不同的访问方式，可以说是多个访问者。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;list&gt;
using namespace std;
 
class BaseElement;
 
class BaseVisitor
{
public:
    virtual void Visit( BaseElement *element ){};
};
 
class BaseElement
{
public:
    // Methods
    virtual void Accept( BaseVisitor *visitor ){};
};
 
 
// &quot;ConcreteElement&quot;
class Employee : public BaseElement
{
public:
    string name;
    double income;
    int vacationDays;
 
public :
    Employee( string name, double income,
        int vacationDays )
    {
        this-&gt;name = name;
        this-&gt;income = income;
        this-&gt;vacationDays = vacationDays;
    }
 
    void Accept( BaseVisitor *visitor )
    {
        visitor-&gt;Visit( this );
    }
};
 
class IncomeVisitor : public BaseVisitor
{
public: 
    void Visit( BaseElement *element )
    {
        Employee *employee = ((Employee*)element);
        employee-&gt;income *= 1.10;
        cout&lt;&lt;employee-&gt;name&lt;&lt;&quot; 's new income: &quot; &lt;&lt; employee-&gt;income&lt;&lt; endl; 
    }
};
 
class VacationVisitor : public BaseVisitor
{
public :
    void Visit( BaseElement *element )
    {
        Employee *employee = ((Employee*)element);
        employee-&gt;vacationDays += 3;     
        cout&lt;&lt; employee-&gt;name &lt;&lt;&quot; 's new vacation days: &quot; &lt;&lt; employee-&gt;vacationDays&lt;&lt; endl;
    }
};
 
class Employees
{   
private :
    list&lt; Employee*&gt; employees;
 
public :
 
    void Attach( Employee *employee )
    {       
        employees.push_back(employee);      
    }
 
    void Detach( Employee *employee )
    {
        employees.remove(employee);     
    }
 
    void Accept( BaseVisitor *visitor )
    {       
        for (std::list&lt;Employee*&gt;::iterator it=employees.begin(); it != employees.end(); ++it)
            (*it)-&gt;Accept(visitor);
    }
};
 
void main( )
{
    Employees *e = new Employees();
    e-&gt;Attach( new Employee( &quot;Jason&quot;, 25000.0, 14 ) );
    e-&gt;Attach( new Employee( &quot;Albter&quot;, 35000.0, 16 ) );
    e-&gt;Attach( new Employee( &quot;lily&quot;, 45000.0, 21 ) );
 
    IncomeVisitor *v1 = new IncomeVisitor();
    VacationVisitor *v2 = new VacationVisitor();
 
    e-&gt;Accept( v1 );
    e-&gt;Accept( v2 );
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;在vistor模式中，以及以前的design pattern中，我们都使用了动态绑定！
动态绑定就是在基类中定义virtual function 然后继承该base class，创建derive class时转到base class。当我们使用derive class中的function，我们只需要把base class指针指向该函数即可！&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;我们要分清函数重载与动态绑定在工程中的区别（重载只是函数类型不同而已！）&lt;/p&gt;

&lt;p&gt;动态绑定中，函数的执行操作决定于请求种类，与接收者类型！&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;访问者模式适合于重构！比如功能集中化，UI集中化。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Memento Pattern with C++</title>
      <link>place_your_blog_url_here/2014/06/12/memento-pattern-with-c.html</link>
      <pubDate>12 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/12/memento-pattern-with-c</guid>
      <description>&lt;h1&gt;备忘录模式C++实现&lt;/h1&gt;

&lt;p&gt;备忘录模式是一种比较重要的设计模式，如果程序执行错误，我们可以恢复restore之前的状态，就好像我们在编辑word文档，需要撤销原操作，那么我们使用ctrl+Z。
在数据库操作中，这个模式用的非常多！&lt;/p&gt;

&lt;p&gt;说白了就是在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。&lt;/p&gt;

&lt;p&gt;这个模式有三个对象：&lt;/p&gt;

&lt;p&gt;Originator（执行业务逻辑的class）：负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。Originator可根据需要决定Memento存储Originator的哪些内部状态。&lt;/p&gt;

&lt;p&gt;Memento（备份数据的class）:负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。&lt;/p&gt;

&lt;p&gt;Caretaker（说白了就是管理备份数据的class）：负责保存好备忘录Memento,不能对备忘录的内容进行操作或检查。&lt;/p&gt;

&lt;h5&gt;由于备忘录模式非常灵活，往简单说可以保存单state，多state。甚至是一个保存class，往更大的说了，就是一个备份系统，每隔一段时间备份一次数据。&lt;/h5&gt;

&lt;h5&gt;不过使用备忘录模式的时候，要考虑控制建立Memento的数量，大的object非常消耗资源，有可能产生内存泄露。&lt;/h5&gt;

&lt;p&gt;下面我先来说对于单变量的备忘录模式。
&lt;img src=&quot;/assets/pic/memento.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;
 
//保存数据的class
class Memento
{
private:
    friend class Originator;
    Memento(const string&amp; state){this-&gt;_state = state;}
    ~Memento(){}
    void SetState(const string&amp; state){this-&gt;_state = state;}
    string GetState(){return this-&gt;_state;}
    string _state;
};
 
 
//备份数据逻辑的class
class Originator
{
public:
    Originator();
    Originator(const string&amp; state){this-&gt;_state = state;}
    ~Originator(){}
    void RestoreToMemento(Memento* pMemento){this-&gt;_state = pMemento-&gt;GetState();}
    Memento* CreateMemento(){return new Memento(this-&gt;_state);}
    void SetState(const string&amp; state){this-&gt;_state = state;}
    string GetState(){return this-&gt;_state;}
    void show(){cout &lt;&lt; this-&gt;_state &lt;&lt; endl;}
protected:
private:
    string _state;
};
 
//管理备份数据的class
class Caretaker
{
public:
    Caretaker(){}
    ~Caretaker(){}
    void SetMemento(Memento *pMemento){this-&gt;_memento = pMemento;}
    Memento* GetMemento(){return this-&gt;_memento;}
private:
    Memento* _memento;
};
int main()
{
    //初始化对象，状态为“Old”
    Originator* o = new Originator(&quot;Old&quot;);
    o-&gt;show();
 
    //建立并保存Memento
    Caretaker* pTaker = new Caretaker();
    pTaker-&gt;SetMemento(o-&gt;CreateMemento());
 
    //改变状态
    o-&gt;SetState(&quot;New&quot;);
    o-&gt;show();
 
    //恢复状态
    o-&gt;RestoreToMemento(pTaker-&gt;GetMemento());
    o-&gt;show();
 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;上面我们只是保存了一个state值，如果要保存一系列的值，小于6个，个人推荐直接在构造函数里传值保存！
如果是保存一个类，在Java中我们有clone（）方法，但是在C++中，我们没有现成的cloneable接口，我们无法进行深拷贝，只能借助库或者是直接实现，这里我们可以参考之前的原型模式（protype pattern）实现方式。&lt;/p&gt;

&lt;p&gt;对于多状态备忘录模式在Java中我们可以使用BeanUtils工具类，在Java中使用BeanUtils；类以及反射的技术，进行保存，精髓就是使用hashmap来进行保存！&lt;/p&gt;

&lt;p&gt;对于多备份备忘录，我们构造一个hashmap来存放不同时刻的memento&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class MultiCaretaker
{
public:
    MultiCaretaker(){}
    ~MultiCaretaker(){}
    void SetMemento(string name,Memento *pMemento){this-&gt;memmap.insert(pair&lt;string,Memento*&gt;(name,pMemento));}
    Memento* GetMemento(string name){return this-&gt;memmap[name];}
private:
    hash_map&lt;string,Memento*&gt; memmap;
};
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;如果为了封装好一点，可以将memento放在originator中，只有originator可以调用memento！
刚才在上面做的那种单状态保存的方式，使用friend属性，其实打破了OO的开闭原则，存在一定的缺陷！&lt;/p&gt;

&lt;h5&gt;Java中有反射机制，C++中如何具体实现这种机制还要继续学习一下！&lt;/h5&gt;

&lt;p&gt;参考
&lt;a href=&quot;http://blog.csdn.net/wuzhekai1985/article/details/6672906&quot;&gt;http://blog.csdn.net/wuzhekai1985/article/details/6672906&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/ai92/article/details/454354&quot;&gt;http://blog.csdn.net/ai92/article/details/454354&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Observer Pattern with C++</title>
      <link>place_your_blog_url_here/2014/06/10/observer-pattern-with-c.html</link>
      <pubDate>10 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/10/observer-pattern-with-c</guid>
      <description>&lt;h1&gt;观察者模式C++实现&lt;/h1&gt;

&lt;p&gt;观察者模式是非常重要的一个模式，初次遇到该模式，想了很久没有想通应该怎么做。&lt;/p&gt;

&lt;p&gt;其实原理很简单：就是当被观察者（Observable）发生变化，然后就会某种数据方式通知（Notify）观察者（Observer），Notify的方式很多，比如我们将Observer 放到一个list或者set中，分别调用Observer的update（）这样实现通知。&lt;/p&gt;

&lt;p&gt;这个模式和之前的责任链模式很相似，不同的是观察者模式在消息传播的时候，消息是可变的。责任链模式在消息 传播的过程保持消息的不可变。&lt;/p&gt;

&lt;h4&gt;另外我们要说明的是ObserverPattern模式中最好只出现一个既是Observer又是Observable的对象，消息最多转发一次&lt;/h4&gt;

&lt;h4&gt;从效率上来说，如果一个Observer被阻塞，会影响其他Observer的Notify（），所以Notify（）最好采用异步的方式。不过异步的话就要考虑线程安全和队列的问题，需要查看message queue。&lt;/h4&gt;

&lt;p&gt;下面是UML类图
&lt;img src=&quot;/assets/pic/Observer.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;
 
class IObserver
{
public:
    IObserver(string _name)
    {
        this-&gt;m_name = _name;
    }
    virtual ~IObserver(void)
    {
    }
    virtual void Update(string context) = 0;
    virtual string GetName() = 0;//为c++单独增加的函数，用于删除时查找观察者。
protected:
    string m_name;
};
 
class IObservable
{
public:
    IObservable(void)
    {
    }
    virtual ~IObservable(void)
    {
    }
    virtual void AddObserver(IObserver *pObserver) = 0;
    virtual void DeleteObserver(IObserver *pObserver) = 0;
    virtual void NotifyObservers(string context) = 0;
};
 
class SuperStar : public IObservable
{
public:
    SuperStar(void){}
    ~SuperStar(void){}
    void AddObserver(IObserver *pObserver){m_observerList.push_back(pObserver);}
    void DeleteObserver(IObserver *pObserver)
    {
        ObserverList_C_iterator it = m_observerList.begin();
        for (; it != m_observerList.end(); it++)
        {
            string name = (*it)-&gt;GetName();
            if (name.compare(pObserver-&gt;GetName()) == 0)
            {
                it = m_observerList.erase(it);
            }
        }
    }
    void NotifyObservers(string context)
    {
        ObserverList_C_iterator it = m_observerList.begin();
        for (; it != m_observerList.end(); it ++)
        {
            (*it)-&gt;Update(context);
        }
    }
    void HaveBreakfast()
    {
         cout &lt;&lt; &quot;SuperStart begin to have breakfast...&quot; &lt;&lt; endl;
         this-&gt;NotifyObservers(&quot;SuperStart begin to have breakfast&quot;);
    }
    void HaveFun()
    {
         cout &lt;&lt; &quot;SuperStart begin to have fun...&quot; &lt;&lt; endl;
         this-&gt;NotifyObservers(&quot;SuperStart begin to have fun&quot;);
    }
private:
    vector&lt;IObserver*&gt; m_observerList;
    typedef vector&lt;IObserver*&gt;::const_iterator ObserverList_C_iterator;
};
class Spy1 :  public IObserver
{
public:
    Spy1(void):IObserver(&quot;SPY1&quot;){}
    ~Spy1(void){}
    void Update(string context)
    {
        cout &lt;&lt; &quot;Spy1:something happened...&quot; &lt;&lt; endl;
        this-&gt;ReportToBoss(context);
        cout &lt;&lt; &quot;Spy1:get some price&quot; &lt;&lt; endl;
    }
    string GetName(){return m_name;}
private:
    void ReportToBoss(string report)
    {
         cout &lt;&lt; &quot;Spy1:Boss-&gt;&quot; &lt;&lt; report.c_str() &lt;&lt; endl;
    }
};
class Spy2 :  public IObserver
{
public:
    Spy2(void):IObserver(&quot;SPY1&quot;){}
    ~Spy2(void){}
    void Update(string context)
    {
        cout &lt;&lt; &quot;Spy2:something happened...&quot; &lt;&lt; endl;
        this-&gt;ReportToBoss(context);
        cout &lt;&lt; &quot;Spy2:get some price&quot; &lt;&lt; endl;
    }
    string GetName(){return m_name;}
private:
    void ReportToBoss(string report)
    {
         cout &lt;&lt; &quot;Spy2:Boss-&gt;&quot; &lt;&lt; report.c_str() &lt;&lt; endl;
    }
};
 
int main()
{
    IObserver *spy1 = new Spy1();
    IObserver *spy2 = new Spy2();
 
    SuperStar *superstar = new SuperStar();
 
    superstar-&gt;AddObserver(spy1);
    superstar-&gt;AddObserver(spy2);
 
    superstar-&gt;HaveFun();
 
    cout &lt;&lt; endl;
    superstar-&gt;DeleteObserver(spy1);
    superstar-&gt;HaveBreakfast();
 
    delete spy1;
    spy1 = NULL;
    delete spy2;
    spy2 = NULL;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;因为是C++实现，没有通用的Observer Pattern framework，所以我们在class superstar中实现了&lt;/p&gt;

&lt;p&gt;void AddObserver(IObserver *pObserver)&lt;/p&gt;

&lt;p&gt;void DeleteObserver(IObserver *pObserver)&lt;/p&gt;

&lt;p&gt;void NotifyObservers(string context)&lt;/p&gt;

&lt;p&gt;如果我们把这个代码变为一种framework，类图会变化
&lt;img src=&quot;/assets/pic/Observer2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>User Excption Stack Design</title>
      <link>place_your_blog_url_here/2014/06/08/user-excption-stack-design.html</link>
      <pubDate>08 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/08/user-excption-stack-design</guid>
      <description>&lt;h1&gt;用户空间的异常栈设计&lt;/h1&gt;

&lt;p&gt;这个坑想了很久，但是一直没时间填，今天抽出一个周六，把之前的草稿完成！&lt;/p&gt;

&lt;p&gt;我们知道在linux中如果用户程序发生错误，kernel会终止程序运行，并发出segment fault错误。
这种实现其实就是在用户空间实现了异常栈的操作。&lt;/p&gt;

&lt;p&gt;下面我来说一下JOS的用户空间的异常栈设计。&lt;/p&gt;

&lt;p&gt;首先明确几个概念：&lt;/p&gt;

&lt;p&gt;在明确概念前，我们要先看明白JOS内存分布&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
 * Virtual memory map:                                Permissions
 *                                                    kernel/user
 *
 *    4 Gig --------&gt;  +------------------------------+
 *                     |                              | RW/--
 *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                     :              .               :
 *                     :              .               :
 *                     :              .               :
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
 *                     |                              | RW/--
 *                     |   Remapped Physical Memory   | RW/--
 *                     |                              | RW/--
 *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+
 *    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
 *                     +------------------------------+                   |
 *                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |
 *                     | - - - - - - - - - - - - - - -|                 PTSIZE
 *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
 *                     +------------------------------+                   |
 *                     :              .               :                   |
 *                     :              .               :                   |
 *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+
 *                     |       Memory-mapped I/O      | RW/--  PTSIZE
 * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000
 *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
 *    UVPT      ----&gt;  +------------------------------+ 0xef400000
 *                     |          RO PAGES            | R-/R-  PTSIZE
 *    UPAGES    ----&gt;  +------------------------------+ 0xef000000
 *                     |           RO ENVS            | R-/R-  PTSIZE
 * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000
 * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebff000
 *                     |       Empty Memory (*)       | --/--  PGSIZE
 *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000
 *                     |      Normal User Stack       | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebfd000
 *                     |                              |
 *                     |                              |
 *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                     .                              .
 *                     .                              .
 *                     .                              .
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
 *                     |     Program Data &amp; Heap      |
 *    UTEXT --------&gt;  +------------------------------+ 0x00800000
 *    PFTEMP -------&gt;  |       Empty Memory (*)       |        PTSIZE
 *                     |                              |
 *    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+
 *                     |       Empty Memory (*)       |                   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |  User STAB Data (optional)   |                 PTSIZE
 *    USTABDATA ----&gt;  +------------------------------+ 0x00200000        |
 *                     |       Empty Memory (*)       |                   |
 *    0 ------------&gt;  +------------------------------+                 --+
 *
 * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.
 *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages
 *     there if desired.  JOS user programs map pages temporarily at UTEMP.
&lt;/code&gt;&lt;/pre&gt;


&lt;h6&gt;内核栈：kernel代码正常执行时，包括发生中断/异常陷入kernel时，kernel运行的栈称为“内核栈(kernel stack)”，它的esp寄存器指向当前CPU的栈顶，栈的线性地址范围为[kstacktop_i - KSTKSIZE, kstacktop_i -1]. （我们要知道在多核环境下，内核栈有多少个由核心数决定）中断/异常发生时，CPU自动切换到内核栈。之前我已经设置过内核栈。&lt;/h6&gt;

&lt;h6&gt;用户运行栈：在用户程序正常执行时，它所运行的栈称为“用户运行栈(normal user stack)”，它的esp寄存器指向USTACKTOP, 栈的线性地址范围是[USTACKTOP - PGSIZE, USTACKTOP - 1].&lt;/h6&gt;

&lt;h6&gt;用户异常栈：是用户自己定义相应的中断处理程序后，相应处理程序运行时的栈。注意这个处理程序是user mode的，而不是在内核中。它的esp寄存器指向UXSTACKTOP, 栈的线性地址范围是[UXSTACKTOP - PGSIZE, UXSTACKTOP - 1]，也是一页大小。&lt;/h6&gt;

&lt;p&gt;user mode发生异常，用户空间发生了一个page fault. 如果没有用户异常栈，理论上用户程序执行不下去了，它将陷入内核栈，然后在内核中处理page fault，然后返回用户程序。但是，这里我们将采用一个新的机制！也就是不再在内核中处理page fault，而是在user mode的用户异常栈上！&lt;/p&gt;

&lt;p&gt;用户空间发生page fault后，首先陷入内核（用户运行栈-&gt;内核栈， user mode -&gt; kernel mode），进入trap()处理中断分发，进入page_fault_handler().&lt;/p&gt;

&lt;p&gt;然后内核中的page_fault_handler()在确认是用户程序而不是内核触发了page fault后（如果是内核发生page fault就直接panic了），在用户异常栈上压入一个UTrapframe作为记录保存现场的信息（注意这只是内存操作，还没有切换到用户异常栈）。&lt;/p&gt;

&lt;p&gt;kernel将用户程序切换到用户异常栈（内核栈-&gt;用户异常栈, kernel mode -&gt; user mode），然后就让用户程序重新运行了！&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;这里有两点要说明：1.现在用户程序是运行在用户异常栈（而不是用户运行栈）上，2.此时的eip被设置为page fault处理程序的起始地址curenv-&gt;env_pgfault_upcall。所以，接下来用户程序执行处理page fault的处理程序，它实际上是在用户空间中进行处理。&lt;/p&gt;

&lt;p&gt;page fault被处理完后，切换回用户运行栈（用户异常栈-&gt;用户运行栈, user mode -&gt; user mode），用户程序重新运行。
弄清楚page fault发生前后“栈的切换”、“特权级别(mode)的切换”是非常重要的。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;实际上判断用户程序是在kernel mode 还是 user mode主要是通过寄存器中 tf_cs == GD_KT来判断。&lt;/p&gt;

&lt;p&gt;如果这个寄存器记录的值不是GD_KT那么，说明pagefault来自用户空间。&lt;/p&gt;

&lt;p&gt;然后检查检查user mode pagefault handler即将调用异常处理函数的入口地址。即env_pgfault_upcall&lt;/p&gt;

&lt;p&gt;这里涉及一个问题，判断当前的esp是否已经在用户异常栈中.&lt;/p&gt;

&lt;p&gt;如果是的话，就要从esp再往下分配一个sizeof（UTrapframe）大小的空间，存放UTrapframe，否则从用户异常栈顶UXSTACKTOP分配UTrapframe。然后将寄存器里面的值eflags ，eip， esp，regs存入到UTrapframe结构体中。&lt;/p&gt;

&lt;h6&gt;UTrapframe不同在于Trapframe的是env_tf.tf_eip env_tf.tf_esp&lt;/h6&gt;

&lt;p&gt;env_tf.tf_eip指向用户自己的异常处理函数，env_tf.tf_esp指向的是UTrapframe，保存完现场，然后系统把控制权交给用户定义的异常处理函数，然后系统进行调度。&lt;/p&gt;

&lt;p&gt;理解了上述的过程，我对中断用户异常处理函数有了好的了解，下一步实现该代码即可。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Strategy Pattern with C++</title>
      <link>place_your_blog_url_here/2014/06/06/Strategy-Pattern-with-c.html</link>
      <pubDate>06 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/06/Strategy-Pattern-with-c</guid>
      <description>&lt;h1&gt;策略模式及其拓展 C++实现&lt;/h1&gt;

&lt;p&gt;策略模式形式上其实和装饰者模式，工厂模式都很像，装饰者模式是在原有核心的业务上添加新的业务，工厂模式是在构造函数中传入新类类名，然后返回新的类。而策略模式则是将策略类传入到执行类里，达到执行策略的目的！&lt;/p&gt;

&lt;p&gt;工厂模式和策略模式有很多相通的地方。都是创造类。&lt;/p&gt;

&lt;h6&gt;不同点在于：工厂模式有可能各个类的方法名和个数差别很大，注重不同对象的创建。策略模式 一般用于多个类的方法名都相同,但是实现方式不同 注重多个对象的相同行为：屏蔽方法名相同，算法实现细节不同之间的差异&lt;/h6&gt;

&lt;p&gt;策略模式的缺点是：策略类数量过多，所有策略类都必须对外暴露。&lt;/p&gt;

&lt;h5&gt;原则就是：当具体策略超过4个的时候，就要考虑使用混合模式，比如和工厂模式混用！&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/1855.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
 
class IStrategy
{
public:
    IStrategy(void){};
    virtual ~IStrategy(void){};
    virtual void Operate(void) = 0;
};
 
class context
{
public:
    context(IStrategy *isstrategy):m_strategy(isstrategy){}
    ~context(){}
    void Operate(void){m_strategy-&gt;Operate();}
private:
    IStrategy *m_strategy;
      
};
 
class BackDoor:public IStrategy
{
public:
    BackDoor(void){}
    ~BackDoor(void){}
    void Operate(void){std::cout &lt;&lt;&quot;BackDoor&quot; &lt;&lt; std::endl;}
};
 
class GreenLight:public IStrategy
{
public:
    GreenLight(void){}
    ~GreenLight(void){}
    void Operate(void){std::cout &lt;&lt; &quot;GreenLight&quot; &lt;&lt; std::endl;}
};
 
int main()
{
    context*context1 =  new context(new BackDoor());
    context1-&gt;Operate();
 
    context*context2 =  new context(new GreenLight());
    context2-&gt;Operate();
 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;因为这个模式过于简单,&lt;strong&gt;&lt;strong&gt;&lt;em&gt;所以我们要配合其他模式使用，如果我们配合工厂模式，正好可以弥补策略模式的缺点！&lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我增加了class Policeoffice 与 class Police&lt;/p&gt;

&lt;p&gt;其中class Policeoffice主要是下达具体命令的地方，这也是工厂模式的精髓！class Police封装这个工厂，并使用创造的新类执行。&lt;/p&gt;

&lt;h5&gt;这个完美的弥补了策略模式，策略类太多的弊病。策略类多正好由工厂区创建！&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/0551.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
 
class IStrategy
{
public:
    IStrategy(void){};
    virtual ~IStrategy(void){};
    virtual void Operate(void) = 0;
};
 
class Context
{
public:
    Context(IStrategy *isstrategy):m_strategy(isstrategy){}
    ~Context(){}
    void Operate(void){m_strategy-&gt;Operate();}
private:
    IStrategy *m_strategy;
      
};
 
class BackDoor:public IStrategy
{
public:
    BackDoor(void){}
    ~BackDoor(void){}
    void Operate(void){std::cout &lt;&lt;&quot;BackDoor&quot; &lt;&lt; std::endl;}
};
 
class GreenLight:public IStrategy
{
public:
    GreenLight(void){}
    ~GreenLight(void){}
    void Operate(void){std::cout &lt;&lt; &quot;GreenLight&quot; &lt;&lt; std::endl;}
};
 
class Policeoffice
{
public:
    Policeoffice(){}
    ~Policeoffice(){}
    IStrategy* getStrategy(string classname)
    {
        if(classname ==&quot;BackDoor&quot;)
            return new BackDoor();
        else if(classname ==&quot;GreenLight&quot;)
            return new GreenLight();
 
        return NULL;
    }
};
 
class Police
{
public:
    Police(){office = new Policeoffice();}
    ~Police(){delete office;}
    void PoliceDeduct(string classname)
    {       
        IStrategy *strategy = office-&gt;getStrategy(classname);
        context = new Context(strategy);
        context-&gt;Operate();
    }
private:
    Policeoffice *office;
    IStrategy *strategy;
    Context *context;
};
 
int main()
{
    Police police;
    police.PoliceDeduct(&quot;BackDoor&quot;);
 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;设计模式不止一种，所以我们要考虑混用各种设计模式，达到解耦的效果！&lt;/p&gt;

&lt;h4&gt;封装的精髓就是避免高层模块深入系统内部，这样使得系统达到高内聚，低耦合的特性。&lt;/h4&gt;
</description>
    </item>
    
  </channel>
</rss>