<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>place_your_blog_title_here</title>
    <link>place_your_blog_url_here</link>
    <atom:link href="place_your_blog_url_here/rss.xml" rel="self" type="application/rss+xml" />
    <description>place_your_blog_description_here</description>
    <language>place_your_blog_language_here</language>
    <pubDate>Fri, 13 Jun 2014 16:57:55 +0800</pubDate>
    <lastBuildDate>Fri, 13 Jun 2014 16:57:55 +0800</lastBuildDate>

    
    <item>
      <title>Memento Pattern with C++</title>
      <link>place_your_blog_url_here/2014/06/12/memento-pattern-with-c.html</link>
      <pubDate>12 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/12/memento-pattern-with-c</guid>
      <description>&lt;h1&gt;备忘录模式C++实现&lt;/h1&gt;

&lt;p&gt;备忘录模式是一种比较重要的设计模式，如果程序执行错误，我们可以恢复restore之前的状态，就好像我们在编辑word文档，需要撤销原操作，那么我们使用ctrl+Z。
在数据库操作中，这个模式用的非常多！&lt;/p&gt;

&lt;p&gt;说白了就是在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。&lt;/p&gt;

&lt;p&gt;这个模式有三个对象：&lt;/p&gt;

&lt;p&gt;Originator（执行业务逻辑的class）：负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。Originator可根据需要决定Memento存储Originator的哪些内部状态。&lt;/p&gt;

&lt;p&gt;Memento（备份数据的class）:负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。&lt;/p&gt;

&lt;p&gt;Caretaker（说白了就是管理备份数据的class）：负责保存好备忘录Memento,不能对备忘录的内容进行操作或检查。&lt;/p&gt;

&lt;h5&gt;由于备忘录模式非常灵活，往简单说可以保存单state，多state。甚至是一个保存class，往更大的说了，就是一个备份系统，每隔一段时间备份一次数据。&lt;/h5&gt;

&lt;h5&gt;不过使用备忘录模式的时候，要考虑控制建立Memento的数量，大的object非常消耗资源，有可能产生内存泄露。&lt;/h5&gt;

&lt;p&gt;下面我先来说对于单变量的备忘录模式。
&lt;img src=&quot;/assets/pic/memento.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;
 
//保存数据的class
class Memento
{
private:
    friend class Originator;
    Memento(const string&amp; state){this-&gt;_state = state;}
    ~Memento(){}
    void SetState(const string&amp; state){this-&gt;_state = state;}
    string GetState(){return this-&gt;_state;}
    string _state;
};
 
 
//备份数据逻辑的class
class Originator
{
public:
    Originator();
    Originator(const string&amp; state){this-&gt;_state = state;}
    ~Originator(){}
    void RestoreToMemento(Memento* pMemento){this-&gt;_state = pMemento-&gt;GetState();}
    Memento* CreateMemento(){return new Memento(this-&gt;_state);}
    void SetState(const string&amp; state){this-&gt;_state = state;}
    string GetState(){return this-&gt;_state;}
    void show(){cout &lt;&lt; this-&gt;_state &lt;&lt; endl;}
protected:
private:
    string _state;
};
 
//管理备份数据的class
class Caretaker
{
public:
    Caretaker(){}
    ~Caretaker(){}
    void SetMemento(Memento *pMemento){this-&gt;_memento = pMemento;}
    Memento* GetMemento(){return this-&gt;_memento;}
private:
    Memento* _memento;
};
int main()
{
    //初始化对象，状态为“Old”
    Originator* o = new Originator(&quot;Old&quot;);
    o-&gt;show();
 
    //建立并保存Memento
    Caretaker* pTaker = new Caretaker();
    pTaker-&gt;SetMemento(o-&gt;CreateMemento());
 
    //改变状态
    o-&gt;SetState(&quot;New&quot;);
    o-&gt;show();
 
    //恢复状态
    o-&gt;RestoreToMemento(pTaker-&gt;GetMemento());
    o-&gt;show();
 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;上面我们只是保存了一个state值，如果要保存一系列的值，小于6个，个人推荐直接在构造函数里传值保存！
如果是保存一个类，在Java中我们有clone（）方法，但是在C++中，我们没有现成的cloneable接口，我们无法进行深拷贝，只能借助库或者是直接实现，这里我们可以参考之前的原型模式（protype pattern）实现方式。&lt;/p&gt;

&lt;p&gt;对于多状态备忘录模式在Java中我们可以使用BeanUtils工具类，在Java中使用BeanUtils；类以及反射的技术，进行保存，精髓就是使用hashmap来进行保存！&lt;/p&gt;

&lt;p&gt;对于多备份备忘录，我们构造一个hashmap来存放不同时刻的memento&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class MultiCaretaker
{
public:
    MultiCaretaker(){}
    ~MultiCaretaker(){}
    void SetMemento(string name,Memento *pMemento){this-&gt;memmap.insert(pair&lt;string,Memento*&gt;(name,pMemento));}
    Memento* GetMemento(string name){return this-&gt;memmap[name];}
private:
    hash_map&lt;string,Memento*&gt; memmap;
};
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;如果为了封装好一点，可以将memento放在originator中，只有originator可以调用memento！
刚才在上面做的那种单状态保存的方式，使用friend属性，其实打破了OO的开闭原则，存在一定的缺陷！&lt;/p&gt;

&lt;h5&gt;Java中有反射机制，C++中如何具体实现这种机制还要继续学习一下！&lt;/h5&gt;

&lt;p&gt;参考
&lt;a href=&quot;http://blog.csdn.net/wuzhekai1985/article/details/6672906&quot;&gt;http://blog.csdn.net/wuzhekai1985/article/details/6672906&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/ai92/article/details/454354&quot;&gt;http://blog.csdn.net/ai92/article/details/454354&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Observer Pattern with C++</title>
      <link>place_your_blog_url_here/2014/06/10/observer-pattern-with-c.html</link>
      <pubDate>10 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/10/observer-pattern-with-c</guid>
      <description>&lt;h1&gt;观察者模式C++实现&lt;/h1&gt;

&lt;p&gt;观察者模式是非常重要的一个模式，初次遇到该模式，想了很久没有想通应该怎么做。&lt;/p&gt;

&lt;p&gt;其实原理很简单：就是当被观察者（Observable）发生变化，然后就会某种数据方式通知（Notify）观察者（Observer），Notify的方式很多，比如我们将Observer 放到一个list或者set中，分别调用Observer的update（）这样实现通知。&lt;/p&gt;

&lt;p&gt;这个模式和之前的责任链模式很相似，不同的是观察者模式在消息传播的时候，消息是可变的。责任链模式在消息 传播的过程保持消息的不可变。&lt;/p&gt;

&lt;h4&gt;另外我们要说明的是ObserverPattern模式中最好只出现一个既是Observer又是Observable的对象，消息最多转发一次&lt;/h4&gt;

&lt;h4&gt;从效率上来说，如果一个Observer被阻塞，会影响其他Observer的Notify（），所以Notify（）最好采用异步的方式。不过异步的话就要考虑线程安全和队列的问题，需要查看message queue。&lt;/h4&gt;

&lt;p&gt;下面是UML类图
&lt;img src=&quot;/assets/pic/Observer.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;
 
class IObserver
{
public:
    IObserver(string _name)
    {
        this-&gt;m_name = _name;
    }
    virtual ~IObserver(void)
    {
    }
    virtual void Update(string context) = 0;
    virtual string GetName() = 0;//为c++单独增加的函数，用于删除时查找观察者。
protected:
    string m_name;
};
 
class IObservable
{
public:
    IObservable(void)
    {
    }
    virtual ~IObservable(void)
    {
    }
    virtual void AddObserver(IObserver *pObserver) = 0;
    virtual void DeleteObserver(IObserver *pObserver) = 0;
    virtual void NotifyObservers(string context) = 0;
};
 
class SuperStar : public IObservable
{
public:
    SuperStar(void){}
    ~SuperStar(void){}
    void AddObserver(IObserver *pObserver){m_observerList.push_back(pObserver);}
    void DeleteObserver(IObserver *pObserver)
    {
        ObserverList_C_iterator it = m_observerList.begin();
        for (; it != m_observerList.end(); it++)
        {
            string name = (*it)-&gt;GetName();
            if (name.compare(pObserver-&gt;GetName()) == 0)
            {
                it = m_observerList.erase(it);
            }
        }
    }
    void NotifyObservers(string context)
    {
        ObserverList_C_iterator it = m_observerList.begin();
        for (; it != m_observerList.end(); it ++)
        {
            (*it)-&gt;Update(context);
        }
    }
    void HaveBreakfast()
    {
         cout &lt;&lt; &quot;SuperStart begin to have breakfast...&quot; &lt;&lt; endl;
         this-&gt;NotifyObservers(&quot;SuperStart begin to have breakfast&quot;);
    }
    void HaveFun()
    {
         cout &lt;&lt; &quot;SuperStart begin to have fun...&quot; &lt;&lt; endl;
         this-&gt;NotifyObservers(&quot;SuperStart begin to have fun&quot;);
    }
private:
    vector&lt;IObserver*&gt; m_observerList;
    typedef vector&lt;IObserver*&gt;::const_iterator ObserverList_C_iterator;
};
class Spy1 :  public IObserver
{
public:
    Spy1(void):IObserver(&quot;SPY1&quot;){}
    ~Spy1(void){}
    void Update(string context)
    {
        cout &lt;&lt; &quot;Spy1:something happened...&quot; &lt;&lt; endl;
        this-&gt;ReportToBoss(context);
        cout &lt;&lt; &quot;Spy1:get some price&quot; &lt;&lt; endl;
    }
    string GetName(){return m_name;}
private:
    void ReportToBoss(string report)
    {
         cout &lt;&lt; &quot;Spy1:Boss-&gt;&quot; &lt;&lt; report.c_str() &lt;&lt; endl;
    }
};
class Spy2 :  public IObserver
{
public:
    Spy2(void):IObserver(&quot;SPY1&quot;){}
    ~Spy2(void){}
    void Update(string context)
    {
        cout &lt;&lt; &quot;Spy2:something happened...&quot; &lt;&lt; endl;
        this-&gt;ReportToBoss(context);
        cout &lt;&lt; &quot;Spy2:get some price&quot; &lt;&lt; endl;
    }
    string GetName(){return m_name;}
private:
    void ReportToBoss(string report)
    {
         cout &lt;&lt; &quot;Spy2:Boss-&gt;&quot; &lt;&lt; report.c_str() &lt;&lt; endl;
    }
};
 
int main()
{
    IObserver *spy1 = new Spy1();
    IObserver *spy2 = new Spy2();
 
    SuperStar *superstar = new SuperStar();
 
    superstar-&gt;AddObserver(spy1);
    superstar-&gt;AddObserver(spy2);
 
    superstar-&gt;HaveFun();
 
    cout &lt;&lt; endl;
    superstar-&gt;DeleteObserver(spy1);
    superstar-&gt;HaveBreakfast();
 
    delete spy1;
    spy1 = NULL;
    delete spy2;
    spy2 = NULL;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;因为是C++实现，没有通用的Observer Pattern framework，所以我们在class superstar中实现了&lt;/p&gt;

&lt;p&gt;void AddObserver(IObserver *pObserver)&lt;/p&gt;

&lt;p&gt;void DeleteObserver(IObserver *pObserver)&lt;/p&gt;

&lt;p&gt;void NotifyObservers(string context)&lt;/p&gt;

&lt;p&gt;如果我们把这个代码变为一种framework，类图会变化
&lt;img src=&quot;/assets/pic/Observer2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>User Excption Stack Design</title>
      <link>place_your_blog_url_here/2014/06/08/user-excption-stack-design.html</link>
      <pubDate>08 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/08/user-excption-stack-design</guid>
      <description>&lt;h1&gt;用户空间的异常栈设计&lt;/h1&gt;

&lt;p&gt;这个坑想了很久，但是一直没时间填，今天抽出一个周六，把之前的草稿完成！&lt;/p&gt;

&lt;p&gt;我们知道在linux中如果用户程序发生错误，kernel会终止程序运行，并发出segment fault错误。
这种实现其实就是在用户空间实现了异常栈的操作。&lt;/p&gt;

&lt;p&gt;下面我来说一下JOS的用户空间的异常栈设计。&lt;/p&gt;

&lt;p&gt;首先明确几个概念：&lt;/p&gt;

&lt;p&gt;在明确概念前，我们要先看明白JOS内存分布&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
 * Virtual memory map:                                Permissions
 *                                                    kernel/user
 *
 *    4 Gig --------&gt;  +------------------------------+
 *                     |                              | RW/--
 *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                     :              .               :
 *                     :              .               :
 *                     :              .               :
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
 *                     |                              | RW/--
 *                     |   Remapped Physical Memory   | RW/--
 *                     |                              | RW/--
 *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+
 *    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
 *                     +------------------------------+                   |
 *                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |
 *                     | - - - - - - - - - - - - - - -|                 PTSIZE
 *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
 *                     +------------------------------+                   |
 *                     :              .               :                   |
 *                     :              .               :                   |
 *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+
 *                     |       Memory-mapped I/O      | RW/--  PTSIZE
 * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000
 *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
 *    UVPT      ----&gt;  +------------------------------+ 0xef400000
 *                     |          RO PAGES            | R-/R-  PTSIZE
 *    UPAGES    ----&gt;  +------------------------------+ 0xef000000
 *                     |           RO ENVS            | R-/R-  PTSIZE
 * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000
 * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebff000
 *                     |       Empty Memory (*)       | --/--  PGSIZE
 *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000
 *                     |      Normal User Stack       | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebfd000
 *                     |                              |
 *                     |                              |
 *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                     .                              .
 *                     .                              .
 *                     .                              .
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
 *                     |     Program Data &amp; Heap      |
 *    UTEXT --------&gt;  +------------------------------+ 0x00800000
 *    PFTEMP -------&gt;  |       Empty Memory (*)       |        PTSIZE
 *                     |                              |
 *    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+
 *                     |       Empty Memory (*)       |                   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |  User STAB Data (optional)   |                 PTSIZE
 *    USTABDATA ----&gt;  +------------------------------+ 0x00200000        |
 *                     |       Empty Memory (*)       |                   |
 *    0 ------------&gt;  +------------------------------+                 --+
 *
 * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.
 *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages
 *     there if desired.  JOS user programs map pages temporarily at UTEMP.
&lt;/code&gt;&lt;/pre&gt;


&lt;h6&gt;内核栈：kernel代码正常执行时，包括发生中断/异常陷入kernel时，kernel运行的栈称为“内核栈(kernel stack)”，它的esp寄存器指向当前CPU的栈顶，栈的线性地址范围为[kstacktop_i - KSTKSIZE, kstacktop_i -1]. （我们要知道在多核环境下，内核栈有多少个由核心数决定）中断/异常发生时，CPU自动切换到内核栈。之前我已经设置过内核栈。&lt;/h6&gt;

&lt;h6&gt;用户运行栈：在用户程序正常执行时，它所运行的栈称为“用户运行栈(normal user stack)”，它的esp寄存器指向USTACKTOP, 栈的线性地址范围是[USTACKTOP - PGSIZE, USTACKTOP - 1].&lt;/h6&gt;

&lt;h6&gt;用户异常栈：是用户自己定义相应的中断处理程序后，相应处理程序运行时的栈。注意这个处理程序是user mode的，而不是在内核中。它的esp寄存器指向UXSTACKTOP, 栈的线性地址范围是[UXSTACKTOP - PGSIZE, UXSTACKTOP - 1]，也是一页大小。&lt;/h6&gt;

&lt;p&gt;user mode发生异常，用户空间发生了一个page fault. 如果没有用户异常栈，理论上用户程序执行不下去了，它将陷入内核栈，然后在内核中处理page fault，然后返回用户程序。但是，这里我们将采用一个新的机制！也就是不再在内核中处理page fault，而是在user mode的用户异常栈上！&lt;/p&gt;

&lt;p&gt;用户空间发生page fault后，首先陷入内核（用户运行栈-&gt;内核栈， user mode -&gt; kernel mode），进入trap()处理中断分发，进入page_fault_handler().&lt;/p&gt;

&lt;p&gt;然后内核中的page_fault_handler()在确认是用户程序而不是内核触发了page fault后（如果是内核发生page fault就直接panic了），在用户异常栈上压入一个UTrapframe作为记录保存现场的信息（注意这只是内存操作，还没有切换到用户异常栈）。&lt;/p&gt;

&lt;p&gt;kernel将用户程序切换到用户异常栈（内核栈-&gt;用户异常栈, kernel mode -&gt; user mode），然后就让用户程序重新运行了！&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;这里有两点要说明：1.现在用户程序是运行在用户异常栈（而不是用户运行栈）上，2.此时的eip被设置为page fault处理程序的起始地址curenv-&gt;env_pgfault_upcall。所以，接下来用户程序执行处理page fault的处理程序，它实际上是在用户空间中进行处理。&lt;/p&gt;

&lt;p&gt;page fault被处理完后，切换回用户运行栈（用户异常栈-&gt;用户运行栈, user mode -&gt; user mode），用户程序重新运行。
弄清楚page fault发生前后“栈的切换”、“特权级别(mode)的切换”是非常重要的。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;实际上判断用户程序是在kernel mode 还是 user mode主要是通过寄存器中 tf_cs == GD_KT来判断。&lt;/p&gt;

&lt;p&gt;如果这个寄存器记录的值不是GD_KT那么，说明pagefault来自用户空间。&lt;/p&gt;

&lt;p&gt;然后检查检查user mode pagefault handler即将调用异常处理函数的入口地址。即env_pgfault_upcall&lt;/p&gt;

&lt;p&gt;这里涉及一个问题，判断当前的esp是否已经在用户异常栈中.&lt;/p&gt;

&lt;p&gt;如果是的话，就要从esp再往下分配一个sizeof（UTrapframe）大小的空间，存放UTrapframe，否则从用户异常栈顶UXSTACKTOP分配UTrapframe。然后将寄存器里面的值eflags ，eip， esp，regs存入到UTrapframe结构体中。&lt;/p&gt;

&lt;h6&gt;UTrapframe不同在于Trapframe的是env_tf.tf_eip env_tf.tf_esp&lt;/h6&gt;

&lt;p&gt;env_tf.tf_eip指向用户自己的异常处理函数，env_tf.tf_esp指向的是UTrapframe，保存完现场，然后系统把控制权交给用户定义的异常处理函数，然后系统进行调度。&lt;/p&gt;

&lt;p&gt;理解了上述的过程，我对中断用户异常处理函数有了好的了解，下一步实现该代码即可。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Strategy Pattern with C++</title>
      <link>place_your_blog_url_here/2014/06/06/Strategy-Pattern-with-c.html</link>
      <pubDate>06 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/06/Strategy-Pattern-with-c</guid>
      <description>&lt;h1&gt;策略模式及其拓展 C++实现&lt;/h1&gt;

&lt;p&gt;策略模式形式上其实和装饰者模式，工厂模式都很像，装饰者模式是在原有核心的业务上添加新的业务，工厂模式是在构造函数中传入新类类名，然后返回新的类。而策略模式则是将策略类传入到执行类里，达到执行策略的目的！&lt;/p&gt;

&lt;p&gt;工厂模式和策略模式有很多相通的地方。都是创造类。&lt;/p&gt;

&lt;h6&gt;不同点在于：工厂模式有可能各个类的方法名和个数差别很大，注重不同对象的创建。策略模式 一般用于多个类的方法名都相同,但是实现方式不同 注重多个对象的相同行为：屏蔽方法名相同，算法实现细节不同之间的差异&lt;/h6&gt;

&lt;p&gt;策略模式的缺点是：策略类数量过多，所有策略类都必须对外暴露。&lt;/p&gt;

&lt;h5&gt;原则就是：当具体策略超过4个的时候，就要考虑使用混合模式，比如和工厂模式混用！&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/1855.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
 
class IStrategy
{
public:
    IStrategy(void){};
    virtual ~IStrategy(void){};
    virtual void Operate(void) = 0;
};
 
class context
{
public:
    context(IStrategy *isstrategy):m_strategy(isstrategy){}
    ~context(){}
    void Operate(void){m_strategy-&gt;Operate();}
private:
    IStrategy *m_strategy;
      
};
 
class BackDoor:public IStrategy
{
public:
    BackDoor(void){}
    ~BackDoor(void){}
    void Operate(void){std::cout &lt;&lt;&quot;BackDoor&quot; &lt;&lt; std::endl;}
};
 
class GreenLight:public IStrategy
{
public:
    GreenLight(void){}
    ~GreenLight(void){}
    void Operate(void){std::cout &lt;&lt; &quot;GreenLight&quot; &lt;&lt; std::endl;}
};
 
int main()
{
    context*context1 =  new context(new BackDoor());
    context1-&gt;Operate();
 
    context*context2 =  new context(new GreenLight());
    context2-&gt;Operate();
 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;因为这个模式过于简单,&lt;strong&gt;&lt;strong&gt;&lt;em&gt;所以我们要配合其他模式使用，如果我们配合工厂模式，正好可以弥补策略模式的缺点！&lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我增加了class Policeoffice 与 class Police&lt;/p&gt;

&lt;p&gt;其中class Policeoffice主要是下达具体命令的地方，这也是工厂模式的精髓！class Police封装这个工厂，并使用创造的新类执行。&lt;/p&gt;

&lt;h5&gt;这个完美的弥补了策略模式，策略类太多的弊病。策略类多正好由工厂区创建！&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/0551.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
 
class IStrategy
{
public:
    IStrategy(void){};
    virtual ~IStrategy(void){};
    virtual void Operate(void) = 0;
};
 
class Context
{
public:
    Context(IStrategy *isstrategy):m_strategy(isstrategy){}
    ~Context(){}
    void Operate(void){m_strategy-&gt;Operate();}
private:
    IStrategy *m_strategy;
      
};
 
class BackDoor:public IStrategy
{
public:
    BackDoor(void){}
    ~BackDoor(void){}
    void Operate(void){std::cout &lt;&lt;&quot;BackDoor&quot; &lt;&lt; std::endl;}
};
 
class GreenLight:public IStrategy
{
public:
    GreenLight(void){}
    ~GreenLight(void){}
    void Operate(void){std::cout &lt;&lt; &quot;GreenLight&quot; &lt;&lt; std::endl;}
};
 
class Policeoffice
{
public:
    Policeoffice(){}
    ~Policeoffice(){}
    IStrategy* getStrategy(string classname)
    {
        if(classname ==&quot;BackDoor&quot;)
            return new BackDoor();
        else if(classname ==&quot;GreenLight&quot;)
            return new GreenLight();
 
        return NULL;
    }
};
 
class Police
{
public:
    Police(){office = new Policeoffice();}
    ~Police(){delete office;}
    void PoliceDeduct(string classname)
    {       
        IStrategy *strategy = office-&gt;getStrategy(classname);
        context = new Context(strategy);
        context-&gt;Operate();
    }
private:
    Policeoffice *office;
    IStrategy *strategy;
    Context *context;
};
 
int main()
{
    Police police;
    police.PoliceDeduct(&quot;BackDoor&quot;);
 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;设计模式不止一种，所以我们要考虑混用各种设计模式，达到解耦的效果！&lt;/p&gt;

&lt;h4&gt;封装的精髓就是避免高层模块深入系统内部，这样使得系统达到高内聚，低耦合的特性。&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>Decorator Pattern with C++</title>
      <link>place_your_blog_url_here/2014/06/03/decorator-pattern-with-c.html</link>
      <pubDate>03 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/03/decorator-pattern-with-c</guid>
      <description>&lt;h1&gt;装饰者模式 C++实现&lt;/h1&gt;

&lt;p&gt;装饰者模式就是在原来类的基础上添加额外的功能，这种方式主要是为了应对继承带来的的类膨胀。&lt;/p&gt;

&lt;p&gt;装饰者模式比起继承更加灵活，一般来说，基类是抽象的Component还有一个具体的concreteComponent。这个模式的核心就是继承Component的Decorator类。，然后由Decorator类统一管理拓展的业务，也就是新增加的功能。&lt;/p&gt;

&lt;h5&gt;Decorator类中必然有一个private的Component，这个Component来执行concreteComponent的核心操作，而继承Decorator的都是负责装饰这个concreteComponent的&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/decorator.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Beverage
{
protected:
     string description;
public:
     virtual string getDescription() = 0;
     virtual double cost() = 0;
};
class BeverageDecorator:public Beverage
{ 
     string getDescription()
     {
      return description;
     }
};
class Mocha:public BeverageDecorator
{
     Beverage* beverage;
public:
     Mocha(Beverage *beverage)
     {
         this-&gt;beverage = beverage;
     }
     string getDescription()
     {
         return beverage-&gt;getDescription()+&quot; Mocha&quot;;
     }
     double cost()
     {
         return beverage-&gt;cost() + 0.2;
     }
};
class Milk:public BeverageDecorator
{
     Beverage* beverage;
public:
     Milk(Beverage *beverage)
     {
         this-&gt;beverage = beverage;
     }
     string getDescription()
     {
         return beverage-&gt;getDescription()+&quot; Milk&quot;;
     }
     double cost()
     {
      return beverage-&gt;cost() + 0.1;
     }
};
class ConcreteBeverage:public Beverage
{
public:
     ConcreteBeverage()
     {
         description = &quot;Espresso&quot;;
     }
     string getDescription()
     {
         return description;
     }
     double cost()
     {
         return 1.99;
     }
};
void main()
{
     //买个Espresso
     Beverage * beverage1 = new ConcreteBeverage;
     cout &lt;&lt; beverage1-&gt;getDescription() + &quot; $ &quot; &lt;&lt; beverage1-&gt;cost()&lt;&lt; endl;
     //买个Espresso+2份Mocha+1份Milk
     Beverage * beverage2 = new ConcreteBeverage;
     beverage2 = new Mocha(beverage2);
     beverage2 = new Mocha(beverage2);
     beverage2 = new Milk(beverage2);
     cout &lt;&lt; beverage2-&gt;getDescription() + &quot; $ &quot; &lt;&lt; beverage2-&gt;cost()&lt;&lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;装饰者模式的优点就是：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1.Decorator与concreteComponent独立，不会相互耦合。&lt;/p&gt;

&lt;p&gt;2.拓展性非常好，比如我们有father son grandson ，三层继承。通过装饰者模式，我们可以抽象为两层 father son DecoratorSon.这样很好的完成了变更。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;缺点就是 多层继承容易带来复杂，维护性变差。需要适度使用，否则，很难维护！&lt;/h5&gt;

&lt;h6&gt;因为我用的是C++实现，所以我使用了string类型拼接，达到装饰的目的。&lt;/h6&gt;

&lt;h6&gt;在Java中我们可以使用@override重写抽象类执行的核心函数和在子类中配合新添加的业务逻辑和调用super（）方法从而调用父类函数，这样达到装饰的目的。&lt;/h6&gt;
</description>
    </item>
    
    <item>
      <title>Commander Pattern and Chain of Responsibility Pattern with C++</title>
      <link>place_your_blog_url_here/2014/06/03/commander-pattern-and-chain-of-responsibility-pattern-with-c.html</link>
      <pubDate>03 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/03/commander-pattern-and-chain-of-responsibility-pattern-with-c</guid>
      <description>&lt;h1&gt;命令模式 责任链模式 C++实现&lt;/h1&gt;

&lt;p&gt;命令模式是一种高内聚的设计模式，这种模式主要有三类角色：
1.Receiver ———–就是实际要具体执行的具体函数
2.Commander ———-执行命令的操作在这里
3.Invoker ———-他是一个调用者的角色，接受Commander然后调用Receiver
这样使得调用方和执行方二者分离开来，实现了解耦。&lt;/p&gt;

&lt;p&gt;有时候Receiver与Commander会合并，但在大型的项目，三者还是分离开来的。&lt;/p&gt;

&lt;h6&gt;这种模式主要是解耦类与类之间复杂的关系。&lt;/h6&gt;

&lt;p&gt;其实调用树就是 Invoker -&gt; Commander -&gt; Receiver&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/4746.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
using namespace std;
  
#define SAFE_DELETE(p) if (p) { delete p; p = NULL; }
  
class Receiver
{
public:
     void Action()
     {
          cout &lt;&lt;&quot;Receiver-&gt;Action&quot;&lt;&lt; endl;
     }
};
  
class Command
{
public:
     virtual void Execute() = 0;
};
  
class ConcreteCommand : public Command
{
public:
     ConcreteCommand(Receiver *pReceiver) : m_pReceiver(pReceiver){}
     void Execute()
     {
          m_pReceiver-&gt;Action();
     }
private:
     Receiver *m_pReceiver;
};
  
class Invoker
{
public:
     Invoker(Command *pCommand) : m_pCommand(pCommand){}
     void Invoke()
     {
          m_pCommand-&gt;Execute();
     }
private:
     Command *m_pCommand;
};
  
int main()
{
     Receiver *pReceiver = new Receiver();
     Command *pCommand = new ConcreteCommand(pReceiver);
     Invoker *pInvoker = new Invoker(pCommand);
     pInvoker-&gt;Invoke();
     SAFE_DELETE(pInvoker);
     SAFE_DELETE(pCommand);
     SAFE_DELETE(pReceiver);
     return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;blockquote&gt;&lt;h6&gt;有时候，command可以和receive合在一起。这样可以减少暴露在client中的类，使得更加解耦。我们在上面可以加入setCommand（）方法达到一样的效果。但是下面这种方式，比起通用类图，使得类之前联系减少，效果更好！&lt;/h6&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;
class Receiver
{
public:
     void Action()
     {
          cout&lt;&lt;&quot;Receiver-&gt;Action&quot;&lt;&lt; endl;
     }
};
  
class Command
{
public:
     virtual void Execute() = 0;
};
  
class ConcreteCommand : public Command
{
public:
     ConcreteCommand(){m_pReceiver = new Receiver();}
     void Execute()
     {
          m_pReceiver-&gt;Action();
     }
private:
     Receiver *m_pReceiver;
};
  
class Invoker
{
public:
     Invoker(Command *pCommand) : m_pCommand(pCommand){}
     void Invoke()
     {
          m_pCommand-&gt;Execute();
     }
private:
     Command *m_pCommand;
};
  
int main()
{
     Command *pCommand = new ConcreteCommand();
     Invoker *pInvoker = new Invoker(pCommand);
     pInvoker-&gt;Invoke();
     SAFE_DELETE(pInvoker);
     SAFE_DELETE(pCommand);
     return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;责任链模式非常高效。
他把请求和处理分开，请求者不用担心是谁处理的，处理者如果不能处理该请求，则这个处理请求会传递给下一个处理者尝试处理。这个原理主要是通过链表对象遍历做到的。
不过需要注意的是链表对象的遍历可能导致请求一直在寻找处理者，导致性能低下。&lt;/p&gt;

&lt;p&gt;总的来说都是父类实现请求传递，在子类中实现请求的·处理。&lt;/p&gt;

&lt;p&gt;但是要注意：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1.一个请求到链的最后可能也没有处理，所以一定要配置得当.&lt;/p&gt;

&lt;p&gt;2.责任链模式并不创建责任链。责任链的创建必须由系统的其它部分创建出来。&lt;/p&gt;

&lt;p&gt;3.责任链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。一个链可以是一条线，一个树，也可以是一个环。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/chain-of-responsibility.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
 
class Photo 
{
public:
    Photo(string s) : mTitle(s) 
    {
    cout &lt;&lt; &quot;Processing &quot; &lt;&lt; mTitle &lt;&lt; &quot; ...\n&quot;;
    }
 
private:
    string mTitle;
};
 
class PhotoProcessor
{
public:
    PhotoProcessor() : mNextProcessor(0){ }
 
public:
    void process(Photo &amp;p) 
    {
        processImplementation(p);
        if (mNextProcessor != 0) 
            mNextProcessor-&gt;process(p);
    }
 
    virtual ~PhotoProcessor() { }
 
    void setNextProcessor(PhotoProcessor *p) {
        mNextProcessor = p;
    }
 
protected:
    virtual void processImplementation(Photo &amp;a) = 0;
 
private:
    PhotoProcessor *mNextProcessor;
};
 
class Scale : public PhotoProcessor
{
public:
    enum SCALE { S50, S100, S200, S300, S500 };
    Scale(SCALE s) : mSCALE(s) { }
 
private:
    void processImplementation(Photo &amp;a) {
        cout &lt;&lt; &quot;Scaling photo\n&quot;;
    }
 
    SCALE mSCALE;
};
 
class RedEye : public PhotoProcessor
{
private:
    void processImplementation(Photo &amp;a) {
        cout &lt;&lt; &quot;Removing red eye\n&quot;;
    }
};
 
class Filter : public PhotoProcessor
{
private:
    void processImplementation(Photo &amp;a) {
        cout &lt;&lt; &quot;Applying filters\n&quot;;
    }
};
 
class ColorMatch : public PhotoProcessor
{
private:
    void processImplementation(Photo &amp;a)
    {
        cout &lt;&lt; &quot;Matching colors\n&quot;;
    }
};
 
void processPhoto(Photo &amp;photo)
{   
    ColorMatch match;
    RedEye eye;
    Filter filter;
    Scale scale(Scale::S200);
    scale.setNextProcessor(&amp;eye);
    eye.setNextProcessor(&amp;match);
    match.setNextProcessor(&amp;filter);
// scale -&gt; eye -&gt; match -&gt; filter
//也就是说scale eye match filter都保存着下一个class，这样就形成了chain of responsibility
    scale.process(photo);
}
 
int main()
{
    Photo *p = new Photo(&quot;lzz&quot;);
    processPhoto(*p);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

</description>
    </item>
    
    <item>
      <title>Mediator模式C++实现</title>
      <link>place_your_blog_url_here/2014/05/22/mediatorc.html</link>
      <pubDate>22 May 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/05/22/mediatorc</guid>
      <description>&lt;h1&gt;中介者模式 C++实现&lt;/h1&gt;

&lt;p&gt;中介者模式主要是为了解决类之间依赖关系的，有些类之间存在复杂的关系，这导致代码不具有可维护性。
中介者模式把这其中各类交换的函数统一放在mediator里面，每种colleague只需要和mediator交互就可以了。&lt;/p&gt;

&lt;p&gt;中介者模式中，每个Colleague 维护一个 Mediator，当要进行通信时，每个具体的 Colleague 直接向 ConcreteMediator 发信息，至于信息发到哪里，则由 ConcreteMediator 来决定。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ConcreteColleagueA 和 ConcreteColleagueB 不必维护对各自的引用，甚至它们也不知道各个的存在。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优点是，各个 Colleague 减少了耦合。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h5&gt;不过这种模式最大的缺点在于如果类之间交互特别复杂，容易造成class mediator体积巨大，这时我们要考虑多创建几个mediator来负责交互。&lt;/h5&gt;

&lt;h5&gt;设计模式很多其实都是通过class强转成父类来产生不同的效果,比如Student -&gt; Colleague的转换，然后通过Colleague来调用子类的函数。&lt;/h5&gt;

&lt;h5&gt;C++中我们要通过Monitor(string n = “”):Colleage(n){};来实现子类通过父类够召唤术初始化。&lt;/h5&gt;

&lt;h5&gt;在Java中，我们可以在构造方法中使用super（）函数，达到使用父类所有方法初始化的目的。&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/mediapattern.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include &lt;vector&gt;
using namespace std;

class Colleage
{
private:
    string name;
    string content;
public:
    Colleage(string n = &quot; &quot;):name(n){};
    void set_name(string name)
    {
        this-&gt;name = name;
    }
    string get_name()
    {
        return this-&gt;name;
    }
    void set_content(string content)
    {
        this-&gt;content = content;
    }
    string get_content()
    {
        if(content.size() != 0)
            return content;
        else return &quot;Copy that&quot;;
    }
    virtual void talk(){};

};

class Monitor : public Colleage
{
public:
    Monitor(string n = &quot;&quot;):Colleage(n){};
    virtual void talk()
    {
        cout&lt;&lt;&quot;Monitor &quot;&lt;&lt; get_name() &lt;&lt; &quot; Say&quot; &lt;&lt; get_content()&lt;&lt; endl;
    }
};

class Secretary : public Colleage
{
public:
    Secretary(string n = &quot;&quot;):Colleage(n){};
    virtual void talk()
    {
        cout&lt;&lt;&quot;Secretary &quot;&lt;&lt;get_name()&lt;&lt;&quot; Say&quot;&lt;&lt; get_content()&lt;&lt; endl;
    }
};

class StudentA : public Colleage
{
public:
    StudentA(string n = &quot;&quot;):Colleage(n){};
    virtual void talk()
    {
        cout&lt;&lt;&quot;StudentA &quot;&lt;&lt;get_name()&lt;&lt;&quot; Say&quot;&lt;&lt; get_content()&lt;&lt; endl;
    }
};

class StudentB : public Colleage
{
public:
    StudentB(string n = &quot;&quot;):Colleage(n){};
    virtual void talk()
    {
        cout&lt;&lt;&quot;StudentB &quot;&lt;&lt;get_name()&lt;&lt;&quot; Say&quot;&lt;&lt; get_content()&lt;&lt; endl;
    }
};

class Mediator
{
public:
    vector&lt;Colleage*&gt; studentList;
    virtual void add_student(Colleage *student)
    {
        studentList.push_back(student);
    };
    virtual void notify(Colleage *student){};    
};

class QQMediator : public Mediator
{
public:
    virtual void notify(Colleage *student)
    {
        student-&gt;talk();
        for(int i = 0 ; i &lt; studentList.size() ; ++i)
        {            
            if(student != studentList[i])
            {
                studentList[i]-&gt;talk();
            }
        }
    };  
};


int main()
{
    QQMediator mediator;
    Monitor *studentMonitor = new Monitor(&quot;studentMonitor&quot;);
    Secretary *studentSecretary = new Secretary(&quot;studentSecretary&quot;);
    StudentA *studentA = new StudentA(&quot;studentA&quot;);
    StudentB *studentB = new StudentB(&quot;studentB&quot;);        

    mediator.add_student(studentSecretary);
    mediator.add_student(studentA);
    mediator.add_student(studentB);     

    studentMonitor-&gt;set_content(&quot;It's time to end the class&quot;);
    mediator.notify(studentMonitor);   
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;



</description>
    </item>
    
    <item>
      <title>Proxy模式C++实现</title>
      <link>place_your_blog_url_here/2014/05/19/proxyc.html</link>
      <pubDate>19 May 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/05/19/proxyc</guid>
      <description>&lt;h1&gt;代理模式 C++实现&lt;/h1&gt;

&lt;p&gt;代理模式是一种常用的设计模式，他可以使得真实的角色就是实现业务的逻辑，不用关心非其本职责的实务，而是依靠后期代理实现。
这种方式可以实现解耦，让我们类的职责更加明确。
代理模式有很多种，有普通代理，强制代理，还有动态代理。&lt;/p&gt;

&lt;h6&gt;普通代理模式与强制代理模式的区别在于真正实现业务的逻辑由谁创建？强制代理模式表示必须由业务者创建，普通代理则认为可以由代理者创建！&lt;/h6&gt;

&lt;h6&gt;这种普通代理模式主要应用在smart_ptr中。&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/55800.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
 
class IGamePlayer
{
public:
    virtual void login(string user,string password) =0;
    virtual void killBoss()=0;
    virtual void update()=0;
};
 
class GamePlayer:public IGamePlayer
{
private :
    string name;
public:
    GamePlayer(IGamePlayer *_gameplayer,string _name)
    {
        name = _name;
        if(_gameplayer==NULL)
            cout &lt;&lt; &quot;_gameplayer failture&quot; &lt;&lt; endl;
    }
    void killBoss(){ cout &lt;&lt; &quot;killBoss&quot; &lt;&lt;endl;}
    void login(string user,string password){ cout &lt;&lt; user &lt;&lt; &quot;  &quot;&lt;&lt;password &lt;&lt;endl;}
    void update(){ cout &lt;&lt; &quot;update!&quot; &lt;&lt;endl; }
};
 
class GamePlayerProxy:public IGamePlayer
{
private:
    IGamePlayer *gameplayer;
public:
    GamePlayerProxy(string name)
    {
        gameplayer = new GamePlayer(this,name);
        if(gameplayer ==NULL)
            cout &lt;&lt; &quot;Create failture!&quot; &lt;&lt; endl;
    }
    void killBoss() {gameplayer-&gt;killBoss();}
    void login(string user,string password){gameplayer-&gt;login(user,password);}
    void update(){gameplayer-&gt;update();}
};
 
int main()
{
    IGamePlayer *proxy = new GamePlayerProxy(&quot;user1&quot;);
    proxy-&gt;login(&quot;lzz&quot;,&quot;lzz&quot;);
    proxy-&gt;killBoss();
    proxy-&gt;update();
    delete proxy;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;h3&gt;强制代理与普通代理的不同在于业务函数必须由业务类制剂创建！并由业务类返回代理者！&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
 
 
class IGamePlayer
{
public:
    virtual void login(string user,string password) =0;
    virtual void killBoss()=0;
    virtual void update()=0;
    virtual IGamePlayer* getProxy()=0;
};
 
class GamePlayerProxy:public IGamePlayer
{
private:
    IGamePlayer *gameplayer;
public:
    GamePlayerProxy(IGamePlayer *_gameplayer)
    {
        this-&gt;gameplayer = _gameplayer;
    }
    void killBoss() {this-&gt;gameplayer-&gt;killBoss();}
    void login(string user,string password){this-&gt;gameplayer-&gt;login(user,password);}
    void update(){this-&gt;gameplayer-&gt;update();}
    IGamePlayer* getProxy(){ return this;}
};
 
class GamePlayer:public IGamePlayer
{
private :
    string name;
    IGamePlayer *Proxy;
    bool isProxy()
    {
        if(Proxy==NULL)
            return false;
        else
            return true;
    }
public:
    GamePlayer(string _name)
    {
        name = _name;
    }
    IGamePlayer* getProxy()
    {
        this-&gt;Proxy = new GamePlayerProxy(this);
        return Proxy;
    }
    void killBoss(){ if(isProxy())cout &lt;&lt; &quot;killBoss&quot; &lt;&lt;endl;}
    void login(string user,string password){ if(isProxy()) cout &lt;&lt; user &lt;&lt; &quot;  &quot;&lt;&lt;password &lt;&lt;endl;}
    void update(){ if(isProxy())cout &lt;&lt; &quot;update!&quot; &lt;&lt;endl; }
 
};
 
int main()
{
    IGamePlayer *player = new GamePlayer(&quot;user1&quot;);
    IGamePlayer *proxy = player-&gt;getProxy();
    proxy-&gt;login(&quot;lzz&quot;,&quot;lzz&quot;);
    proxy-&gt;killBoss();
    proxy-&gt;update();
    delete proxy;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;还有一种动态代理的模式，主要用在Java中，动态代理在实现阶段不在乎代理谁，而主要在运行阶段才真正的代理。&lt;/p&gt;

&lt;p&gt;handler只需要继承InvocationHandler即可，然后再invoke（）中返回要调用的方法或者函数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Protype_IteratorC++实现</title>
      <link>place_your_blog_url_here/2014/05/19/protype_iteratorc.html</link>
      <pubDate>19 May 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/05/19/protype_iteratorc</guid>
      <description>&lt;h1&gt;原型模式 迭代器模式 C++实现&lt;/h1&gt;

&lt;p&gt;原型模式其实非常简单，难易程度其实就是单例模式与迭代器模式差不多。
在Java中我们可以有很多的接口使用，在这里，我们也许会用到Cloneable接口，然后在复制的类里面实现clone方法。&lt;/p&gt;

&lt;h5&gt;调用这个clone（）就等于完成了类的复制，而不是通过new来创建。Clone（）方法是在内存中进行拷贝，所以不会调用构造函数！&lt;/h5&gt;

&lt;p&gt;final与clone不共融，final使用后，就意味着无法进行重写，而调用clone（）必须重写！&lt;/p&gt;

&lt;p&gt;我们知道在OO语言中，有深拷贝与浅拷贝之分。浅拷贝只拷贝类对象，类里面的数组都共享一份，这期中就有潜在的风险。而深拷贝则是完全将对象拷贝两份，也就是说内存中含有两份一模一样的对象！&lt;/p&gt;

&lt;h5&gt;扯完Java，我来用C++实现原型模式，C++中没有什么clone接口，所以我们完全要手动来做。&lt;/h5&gt;

&lt;blockquote&gt;&lt;p&gt;这里有个小插曲：
因为我是在vs2012中编译的。目前vs2012已经把strcpy函数禁用掉，因为存在不安全性。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/70658.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;正如之前爆出的heartbleed漏洞，也是未对字符串赋值进行检查导致，所以我们这里使用strcpy_s()不过这样确实丧失了移植性。需要注意一下。
如果我们不需要这种提醒，可以在设置中把预编译检查关闭！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/71649.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
 
 
class Mail
{
public:
    Mail(){};
    virtual Mail* Clone(){return NULL;}
    virtual void show() =0;
    char *getstr(){return name;}
protected:
    char* name;
};
 
class MailA :public Mail
{
public:
    MailA(char *str)
    {
        if(str==NULL){      name = new char[10];    name[9]='\0';}
        else{name = new char[strlen(str)+1]; strcpy_s(name,10,str);}
    }
    ~MailA(){delete name;}
    MailA(Mail &amp;r){     name = new char[strlen(r.getstr())+1]; strcpy_s(name,strlen(r.getstr())+1,r.getstr());  }
    Mail* Clone(){return (Mail *)new MailA(*this);}
    void show(){cout &lt;&lt; name &lt;&lt; endl;}
};
 
class MailB :public Mail
{
public:
    MailB(char *str)
    {
        if(str==NULL){      name = new char[10];    name[9]='\0';}
        else{name = new char[strlen(str)+1]; strcpy_s(name,10,str);}
    }
    ~MailB(){delete name;}
    MailB(Mail &amp;r){     name = new char[strlen(r.getstr())+1]; strcpy_s(name,strlen(r.getstr())+1,r.getstr());  }
    Mail* Clone(){return (Mail *)new MailB(*this);}
    void show(){cout &lt;&lt; name &lt;&lt; endl;}
};
 
int main()
{
    Mail *m1 = new MailA(&quot;A&quot;);
    Mail *m2 = new MailB(&quot;B&quot;);
    Mail *m3 = m1-&gt;Clone();
    Mail *m4 = m2-&gt;Clone();
    m1-&gt;show(); m2-&gt;show(); //删除m1,m2  
    delete m1; delete m2;     
    m1 = m2 = NULL;  
 
    //深拷贝所以对m3,m4无影响  
    m3-&gt;show(); m4-&gt;show();  
    delete m3; delete m4;  
    m3 = m4 = NULL;  
}
&lt;/code&gt;&lt;/pre&gt;


&lt;h5&gt;迭代器模式如STL，通过容器来管理复杂的数据结构，类等。然后通过iteration来迭代，俗称迭代器模式。&lt;/h5&gt;

&lt;p&gt;在Java中有现成的迭代器来使用，在C++中，我们需要自己实现这种接口iterator。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/3617.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include &lt;vector&gt;
using namespace std;
 
template &lt;class T&gt;
class Iterator
{
public:
    virtual void first()=0;
    virtual void next()=0;
    virtual T* currentItem()=0;
    virtual bool isEnd()=0;
    virtual ~Iterator(){}
};
 
template &lt;class T&gt;
class RealSet;
 
template &lt;class T&gt;
class RealIterator:public Iterator &lt;T&gt;
{
private:
    RealSet&lt;T&gt; *rset;
    int cur_ptr;
public:
    RealIterator(RealSet&lt;T&gt; *a):rset(a),cur_ptr(0){}
    void first(){cur_ptr=0;}
    void next(){if(cur_ptr &lt; rset-&gt;getlen() ) cur_ptr++;}
    T* currentItem()
    {
        if(cur_ptr &lt;rset-&gt;getlen())   return &amp;(*rset)[cur_ptr];
        else return NULL;
    }
    bool isEnd()
    {
        if(cur_ptr &gt;=rset-&gt;getlen())return false;
        return true;
    }
};
 
template &lt;class T&gt;
class Set
{
public:
    virtual Iterator&lt;T&gt;* createIterator()=0;
    virtual void push(T a)=0;
    virtual ~Set(){}
};
 
template &lt;class T&gt;
class RealSet:public Set&lt;T&gt;
{
private:
    vector&lt;T&gt; data;
public:
    RealSet(){}
    ~RealSet(){}
    virtual Iterator&lt;T&gt;* createIterator(){ return new RealIterator&lt;T&gt;(this);}
    virtual T&amp; operator[](int index){return data[index];}
    int getlen(){return data.size();}
    void push(T a)
    {
        data.push_back(a);
    }
};
 
int main()
{
    Set&lt;double&gt; *set = new RealSet&lt;double&gt;();
    Iterator&lt;double&gt; *iter = set-&gt;createIterator();
    set-&gt;push(3.22);
    set-&gt;push(1.86);
    set-&gt;push(0.88);
 
    for(iter-&gt;first();iter-&gt;isEnd();iter-&gt;next())
    {
        cout &lt;&lt; *iter-&gt;currentItem() &lt;&lt; endl;
    }
    delete iter;
    delete set;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;h6&gt;确实这种template编程很难，我调试了一下好久才找到问题所在。。。。。。&lt;/h6&gt;
</description>
    </item>
    
    <item>
      <title>Template_Builder_DesignPattern</title>
      <link>place_your_blog_url_here/2014/05/13/template_builder_designpattern.html</link>
      <pubDate>13 May 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/05/13/template_builder_designpattern</guid>
      <description>&lt;h1&gt;模板方法模式 建造者模式 C++实现&lt;/h1&gt;

&lt;p&gt;今天我继续来填坑，模板方法模式就是在模板方法中按照一定的规则顺序调用基本方法。这个比较简单。&lt;/p&gt;

&lt;p&gt;比如我在父类run（）中调用类中一系列的方法。钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Java中，如果父类里面有些方法不允许覆写，那么为了防止子类改变模板方法中的算法，可以将模板方法声明为final。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/IMG_0432.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
using namespace std;
 
class CarTemplate
{
public:
    CarTemplate(void){};
    virtual ~CarTemplate(void){};
 
protected:
    virtual void Start() = 0;
    virtual void Stop() = 0;
    virtual void Alarm() = 0;
    virtual void EngineBoom() = 0;
    virtual bool IsAlarm() =0;
 
public:
        void Run()
        {
        Start();
 
        EngineBoom();
 
        if(IsAlarm())
            Alarm();
 
        Stop();
        };
};
 
class Hummer: public CarTemplate
{
public:
    Hummer(){m_isAlarm = true;}
    virtual ~Hummer(){};
 
protected:
    void Start(){   cout&lt;&lt; &quot;Hummer Start&quot; &lt;&lt; endl;   }
    void Stop(){    cout&lt;&lt; &quot;Hummer Stop&quot; &lt;&lt; endl;    }
    void Alarm(){   cout&lt;&lt; &quot;Hummer Alarm&quot; &lt;&lt; endl;}
    bool IsAlarm(){ return m_isAlarm;       }
    void EngineBoom(){  cout&lt;&lt; &quot;Hummer EngineBoom&quot; &lt;&lt; endl;  }
private:
    bool m_isAlarm;
};
 
class Benz: public CarTemplate
{
public:
    Benz(){m_isAlarm = false;}
    virtual ~Benz(){};
 
protected:
    void Start(){   cout&lt;&lt; &quot;Benz Start&quot; &lt;&lt; endl; }
    void Stop(){    cout&lt;&lt; &quot;Benz Stop&quot; &lt;&lt; endl;  }
    void Alarm(){   cout&lt;&lt; &quot;Benz Alarm&quot; &lt;&lt; endl;}
    bool IsAlarm(){ return m_isAlarm;       }
    void EngineBoom(){  cout&lt;&lt; &quot;Benz EngineBoom&quot; &lt;&lt; endl;    } 
private:     
        bool m_isAlarm; 
}; 

int main() 
{   
        CarTemplate *hummer = new Hummer();     
        hummer-&gt;Run();
    delete  hummer;
 
    CarTemplate *benz = new Benz();
    benz-&gt;Run();
    delete benz;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;优点就在于可以封装不变的部分，拓展可变的部分，也就是把共性的东西抽取出来，这样可以便于维护。&lt;/p&gt;

&lt;p&gt;但是缺点在于子类的执行，影响到父类的结果。有时候会有一些晦涩难懂。
———————————————————————————————-&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;在模板方法中，我们把相同的都封装在父类中，不同都定义在子类中。但是需求的变化是无穷无尽的。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;比如建造的顺序可能是变化的，所以将他放到builder类中，通过builder类获取真正的product！&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/6446jgG.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class Builder
{
public:
    virtual void BuildHead() {}
    virtual void BuildBody() {}
    virtual void BuildLeftArm(){}
    virtual void BuildRightArm() {}
    virtual void BuildLeftLeg() {}
    virtual void BuildRightLeg() {}
};
//构造瘦人
class ThinBuilder:public Builder
{
public:
    void BuildHead() { cout&lt;&lt; &quot;build thin body&quot; &lt;&lt; endl; }
    void BuildBody() { cout&lt;&lt; &quot;build thin head&quot; &lt;&lt; endl; }
    void BuildLeftArm() { cout&lt;&lt; &quot;build thin leftarm&quot; &lt;&lt; endl; }
    void BuildRightArm() { cout&lt;&lt; &quot;build thin rightarm&quot; &lt;&lt; endl; }
    void BuildLeftLeg() { cout&lt;&lt; &quot;build thin leftleg&quot; &lt;&lt; endl; }
    void BuildRightLeg() { cout&lt;&lt; &quot;build thin rightleg&quot; &lt;&lt; endl; }
};
//构造胖人
class FatBuilder : public Builder
{
public:
    void BuildHead() { cout&lt;&lt;&quot;build fat body&quot;&lt;&lt; endl; }
    void BuildBody() { cout&lt;&lt;&quot;build fat head&quot;&lt;&lt; endl; }
    void BuildLeftArm() { cout&lt;&lt;&quot;build fat leftarm&quot;&lt;&lt; endl; }
    void BuildRightArm() { cout&lt;&lt;&quot;build fat rightarm&quot;&lt;&lt; endl; }
    void BuildLeftLeg() { cout&lt;&lt;&quot;build fat leftleg&quot;&lt;&lt; endl; }
    void BuildRightLeg() { cout&lt;&lt;&quot;build fat rightleg&quot;&lt;&lt; endl; }   
};   //构造的指挥官   

class Director     {   
private:       
    Builder *m_pBuilder;   
public:       
    Director(Builder *builder) { m_pBuilder = builder; }       
    void Create()
    {           
        m_pBuilder-&gt;BuildHead();
        m_pBuilder-&gt;BuildBody();
        m_pBuilder-&gt;BuildLeftArm();
        m_pBuilder-&gt;BuildRightArm();
        m_pBuilder-&gt;BuildLeftLeg();
        m_pBuilder-&gt;BuildRightLeg();
    }
};
 
int main()
{
    FatBuilder fat;
    Director director(&amp;fat);
    director.Create();
---------------------------------------------------------------------------
    Builder *thin = new ThinBuilder();
    Director *dir = new Director(thin);
    dir-&gt;Create();
 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;建造者模式的优点：在于我们不用关心每个产品内部的组成细节，比如FatBuildier ThinBuilider，然后我们交给Director来构造就好了。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;建造者是独立的，我们可以拓展更多的builder完成不同的功能。并不对系统有任何影响。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_特别适合产品类特别复杂，顺序不同，效能不同。顺序是区别模板模式与建造者模式最大的不同点！&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;另外同工厂模式进行比较，工厂模式适合生产零件。不能再细分了。否则就不适合工厂模式。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;把模板方式和建造者模式组合起来可以产生很好的效果，可以按照model通过builder批量生产某种特定型号的产品。&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/IMG_0433.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
using namespace std;

class CCarModel
{
public:
    CCarModel(void) {}
    virtual ~CCarModel(void){}
    void Run()
    {
            vector::const_iterator it = m_pSequence-&gt;begin();
        for (; it &lt; m_pSequence-&gt;end(); ++it)
        {
            string actionName = *it;
            if(actionName.compare(&quot;start&quot;) == 0)
            {
                Start();
            }
            else if(actionName.compare(&quot;stop&quot;) == 0)
            {
                Stop();
            }
            else if(actionName.compare(&quot;alarm&quot;) == 0)
            {
                Alarm();
            }
            else if(actionName.compare(&quot;engine boom&quot;) == 0)
            {
                EngineBoom();
            }
        }
    }
    void SetSequence(vector *pSeq)
    {
            m_pSequence = pSeq;
    }
protected:
    virtual void Start() = 0;
    virtual void Stop() = 0;
    virtual void Alarm() = 0;
    virtual void EngineBoom() = 0;
private:
    vector * m_pSequence;
};

class CBenzModel : public CCarModel
{
public:
    CBenzModel(void){}
    ~CBenzModel(void){}
protected:
    void Start(){cout &lt;&lt; &quot;Benz Start...&quot; &lt;&lt; endl;}
    void Stop(){cout &lt;&lt; &quot;Benz Stop...&quot; &lt;&lt; endl;}
    void Alarm(){cout &lt;&lt; &quot;Benz Alarm&quot; &lt;&lt; endl;}
    void EngineBoom(){cout &lt;&lt; &quot;Benz EngineBoom....&quot; &lt;&lt; endl;}
};

class CBMWModel : public CCarModel
{
public:
    CBMWModel(void){}
    ~CBMWModel(void){}
protected:
    void Start(){cout &lt;&lt; &quot;BMW Start...&quot; &lt;&lt; endl;}
    void Stop(){cout &lt;&lt; &quot;BMW Stop...&quot; &lt;&lt; endl;}
    void Alarm(){cout &lt;&lt; &quot;BMW Alarm&quot; &lt;&lt; endl;}
    void EngineBoom(){cout &lt;&lt; &quot;BMW EngineBoom....&quot; &lt;&lt; endl;}
};

class ICarBuilder
{
public:
    ICarBuilder(void)   { }
    virtual ~ICarBuilder(void)  { }
    virtual void SetSequence(vector *pseq) = 0;
    virtual CCarModel * GetCarModel() = 0;
};

class CBenzBuilder : public ICarBuilder
{
public:
    CBenzBuilder(void);
    ~CBenzBuilder(void);
    void SetSequence(vector *pSeq);
    CCarModel * GetCarModel();
private:
    CCarModel *m_pBenz;
};
CBenzBuilder::CBenzBuilder(void)
{
    m_pBenz = new CBenzModel();
}
CBenzBuilder::~CBenzBuilder(void)
{
    delete m_pBenz;
}
void CBenzBuilder::SetSequence(vector *pSeq)
{
    m_pBenz-&gt;SetSequence(pSeq);
}
CCarModel * CBenzBuilder::GetCarModel()
{
    return m_pBenz;
}

class CBMWBuilder :public ICarBuilder
{
public:
    CBMWBuilder(void);
    ~CBMWBuilder(void);
    void SetSequence(vector *pSeq);
    CCarModel * GetCarModel();
private:
    CCarModel *m_pBMW;
};

CBMWBuilder::CBMWBuilder(void)
{
    m_pBMW = new CBMWModel();
}
CBMWBuilder::~CBMWBuilder(void)
{
    delete m_pBMW;
}
void CBMWBuilder::SetSequence( vector *pSeq )
{
    m_pBMW-&gt;SetSequence(pSeq);
}
CCarModel * CBMWBuilder::GetCarModel()
{
    return m_pBMW;
}

class CDirector
{
public:
    CDirector(void);
    ~CDirector(void);
    CBenzModel * GetABenzModel();
    CBenzModel * GetBBenzModel();
    CBMWModel * GetCBMWModel();
    CBMWModel * GetDBMWModel();
private:
    vector * m_pSeqence;
    CBenzBuilder * m_pBenzBuilder;
    CBMWBuilder * m_pBMWBuilder;
};

CDirector::CDirector(void)
{
    m_pBenzBuilder = new CBenzBuilder();
    m_pBMWBuilder = new CBMWBuilder();
    m_pSeqence = new vector();
}
CDirector::~CDirector(void)
{
    delete m_pBenzBuilder;
    delete m_pBMWBuilder;
    delete m_pSeqence;
}
CBenzModel * CDirector::GetABenzModel()
{
    m_pSeqence-&gt;clear();
    m_pSeqence-&gt;push_back(&quot;start&quot;);
    m_pSeqence-&gt;push_back(&quot;stop&quot;);
    m_pBenzBuilder-&gt;SetSequence(m_pSeqence);
    return dynamic_cast&lt;CBenzModel*&gt;(m_pBenzBuilder-&gt;GetCarModel());
}
CBenzModel * CDirector::GetBBenzModel()
{
    m_pSeqence-&gt;clear();
    m_pSeqence-&gt;push_back(&quot;engine boom&quot;);
    m_pSeqence-&gt;push_back(&quot;start&quot;);
    m_pSeqence-&gt;push_back(&quot;stop&quot;);
    m_pBenzBuilder-&gt;SetSequence(m_pSeqence);
    return dynamic_cast&lt;CBenzModel*&gt;(m_pBenzBuilder-&gt;GetCarModel());
}
CBMWModel * CDirector::GetCBMWModel()
{
    m_pSeqence-&gt;clear();
    m_pSeqence-&gt;push_back(&quot;alarm&quot;);
    m_pSeqence-&gt;push_back(&quot;start&quot;);
    m_pSeqence-&gt;push_back(&quot;stop&quot;);
    m_pBMWBuilder-&gt;SetSequence(m_pSeqence);
    return static_cast&lt;CBMWModel*&gt;(m_pBMWBuilder-&gt;GetCarModel());
}
CBMWModel * CDirector::GetDBMWModel()
{
    m_pSeqence-&gt;clear();
    m_pSeqence-&gt;push_back(&quot;start&quot;);
    m_pBenzBuilder-&gt;SetSequence(m_pSeqence);
    return dynamic_cast&lt;CBMWModel*&gt;(m_pBMWBuilder-&gt;GetCarModel());
}
int main(int argc, char const *argv[])
{
    CDirector *dir = new CDirector();

    dir-&gt;GetBBenzModel()-&gt;Run();
    return 0;
}


&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;通过上面可以看出两个模式的配合得到了很好的运用！&lt;/p&gt;

&lt;p&gt;引用 http://blog.csdn.net/wuzhekai1985/article/details/6667467&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>