<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>place_your_blog_title_here</title>
    <link>place_your_blog_url_here</link>
    <atom:link href="place_your_blog_url_here/rss.xml" rel="self" type="application/rss+xml" />
    <description>place_your_blog_description_here</description>
    <language>place_your_blog_language_here</language>
    <pubDate>Fri, 25 Jul 2014 15:42:45 +0800</pubDate>
    <lastBuildDate>Fri, 25 Jul 2014 15:42:45 +0800</lastBuildDate>

    
    <item>
      <title>Behavior DesignPattern Comparison</title>
      <link>place_your_blog_url_here/2014/07/25/behavior-designpattern-comparison.html</link>
      <pubDate>25 Jul 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/07/25/behavior-designpattern-comparison</guid>
      <description>&lt;h1&gt;行为类模式比较&lt;/h1&gt;

&lt;p&gt;行为类模式包括责任链模式，命令模式，解释器模式，迭代器模式，中介者模式，备忘录模式，观察者模式，状态模式，策略模式，模板方法模式，访问者模式。这些模式都是经常要使用的。&lt;/p&gt;

&lt;h3&gt;1.命令模式和策略模式&lt;/h3&gt;

&lt;p&gt;二者都是很重要的，只是命令模式多了一个Receiver的角色。&lt;/p&gt;

&lt;h4&gt;策略模式主要是封装，封装一个完整的，不可拆分的原则业务，然后让这些业务独立，并可以相互替换，让行为的变化独立于拥有行为的客户，其实就是一种算法替换问题，策略模式的粒度要比命令模式的粒度大一些，也就是说对算法的更改就是全部都要更改。&lt;/h4&gt;

&lt;h4&gt;比策略模式更加抽象的就是命令模式了，但是同时业务粒度变小，可以进行更加细致的调整！&lt;/h4&gt;

&lt;p&gt;比如我们在一个demo中最初使用策略模式实现，如果进行重构，我们就要启用命令模式了！&lt;/p&gt;

&lt;p&gt;看类图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/1855.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;核心代码就是下面这一块，通过动态绑定，执行我们传入类的具体函数Operate（）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class context
{
public:
    context(IStrategy *isstrategy):m_strategy(isstrategy){}
    ~context(){}
    void Operate(void){m_strategy-&gt;Operate();}
private:
    IStrategy *m_strategy;
 
};
&lt;/code&gt;&lt;/pre&gt;


&lt;h4&gt;命令模式关注的是解耦，如何让请求者和执行者解耦是这个模式的要求，也就是说把请求的内容封装成一个一个的命令，由接收者执行，并且可以对命令进行多种处理，例如撤销记录什么的。多用于多命令多撤销的场合。&lt;/h4&gt;

&lt;p&gt;下面来看看命令模式的UML diagram:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/4746.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;调用关系就是 Invoker -&gt; Commander -&gt; Receiver&lt;/h4&gt;

&lt;h4&gt;Receiver是具体的执行者，在Receiver中是具体的业务执行者。对于mian（），我们只需要调用Invoker（）执行就可以了，剩下的由Commander传递到Receiver中。&lt;/h4&gt;

&lt;h3&gt;2.策略模式和状态模式&lt;/h3&gt;

&lt;h4&gt;二者都是通过Context来进行委托！委托就是通过动态绑定实现的。比如下面的Request()方法。Request（）方法调用Handle（）&lt;/h4&gt;

&lt;h4&gt;首先我们要明确策略模式是无状态的，我们通过传入不同策略来达到不同的行为！&lt;/h4&gt;

&lt;h4&gt;状态模式是有状态的，通过状态来改变行为，我们调用的时候传入状态即可，这里我们要阐述一下，状态模式可以有单状态多状态，状态的改变可以是单向的，也可以是双向的。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/StatePattern.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不同点在于应用场景不同，策略模式是平行的，可相互替换的。状态模式要求的是有状态有行为的场景，也就是一个对象必须有状态和行为，状态和行为是一一对应的。而且明显状态模式的复杂度要比策略模式高很多。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class Context
{
public:
    Context(State* pState){this-&gt;_state = pState;}
    ~Context(){}
    void Request()
    {
        if(NULL != this-&gt;_state)
        {
            this-&gt;_state-&gt;Handle(this);
        }
    }
    void ChangeState(State* pState)
    {
        this-&gt;_state = pState;
    }
protected:
private:
    State* _state;
};
&lt;/code&gt;&lt;/pre&gt;


&lt;h3&gt;3.观察者模式与责任者模式&lt;/h3&gt;

&lt;p&gt;观察者模式很多都是将几个Observer插入到容器中，然后在需要的时候update，达到通知的目的。&lt;/p&gt;

&lt;h4&gt;也就是说上下级没有关系，都是接收同样的对象，所有传递的对象都是从链首传递过来的，上一节点是没有关系的，具体怎么传播是模式内部的事，可以是线性的传播，也可以是广播，也就是说按照自己的逻辑处理就好了。&lt;/h4&gt;

&lt;h4&gt;责任链模式就有上下级关系，比如DNS解析就是这种模式，顶级DNS服务器并不与用户直接解析，而是返回给下级的DNS，层层传送给用户，也就是说与用户交互的永远是LocalDNS！&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>Construction DesignPattern Comparison</title>
      <link>place_your_blog_url_here/2014/07/23/construction-designpattern-comparison.html</link>
      <pubDate>23 Jul 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/07/23/construction-designpattern-comparison</guid>
      <description>&lt;h1&gt;结构类模式比较&lt;/h1&gt;

&lt;p&gt;结构类模式包括适配器模式，桥梁模式，组合模式，装饰模式，门面模式，享元模式和代理模式。&lt;/p&gt;

&lt;p&gt;首先我们来比较一下代理模式和装饰模式。&lt;/p&gt;

&lt;h4&gt;代理模式和装饰模式其实很类似，装饰模式就是一种特殊的代理模式，两者都有相同的接口，不同点在于代理模式对于代理过程的控制，而装饰模式则是对类的功能加强和减弱。&lt;/h4&gt;

&lt;p&gt;咱们先来看代理模式的类图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/55800.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先实际的class与proxy class都要继承同一个interface 这里就是IGamePlayer&lt;/p&gt;

&lt;p&gt;GamePlayer是真正的执行者，而GamePlayerProxy是控制GamePlayer执行的。&lt;/p&gt;

&lt;p&gt;相比代理模式，装饰者模式则是在这个代理类中的方法添加新的功能，到达装饰的目的，也就是添加删除类的功能！&lt;/p&gt;

&lt;p&gt;看看装饰者模式的类图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/decorator.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们在getDescription（）方法中进行对类功能的增加删减达到装饰的目的，对于修饰者，我们就是继承BeverageDecorator class达到修饰的目的。&lt;/p&gt;

&lt;p&gt;装饰模式与适配器模式从外面看差别很大，但是也有相似的地方。&lt;/p&gt;

&lt;h5&gt;装饰模式包装的是自己的兄弟类，隶属于一个家族，适配器模式则装修非血缘关系类，把一个非本家族的对象伪装成本家族的对象，注意是伪装。&lt;/h5&gt;

&lt;p&gt;看看适配器模式的类图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/adapterPattern.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
public class UglyDuckling extends WhiteSwan implements Duck
{
     .......
     public void desBehavior()
     {
          system.out.println(&quot;swimming&quot;);
          super.fly();
     }
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;我们可以看出在deBehavior（）中我们定义了与Duckling不同的函数，实现了不同的功能！&lt;/p&gt;

&lt;p&gt;现在来说说这两种模式的不同之处：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   1、意图不同，装饰模式关注的是加强对象的功能，而适配器模式关注的是转换

   2、施与对象不同：装饰模式装饰的对象必须是自己的同宗，而适配器模式则必须是两个不同的对象

   3、场景不同：装饰模式在任何情况下都可以用，而适配器模式是一种补救措施

   4、扩充性不同：装饰模式容易扩充，而适配器模式建立容易，拆除难
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>StatePattern with C++</title>
      <link>place_your_blog_url_here/2014/07/15/statepattern-with-c.html</link>
      <pubDate>15 Jul 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/07/15/statepattern-with-c</guid>
      <description>&lt;h1&gt;状态模式 C++实现&lt;/h1&gt;

&lt;p&gt;状态模式是一种封装模式，也就是说当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。&lt;/p&gt;

&lt;h3&gt;它有两种使用情况：（1）一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。（2）一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。如果if-else过于庞大，那么状态模式将是很好的选择。&lt;/h3&gt;

&lt;h3&gt;之前我的文章都见过这种方式，将具体的实现class都委托给一个封装类来执行，这种方式非常普遍！比如在访问者模式中，通过&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
void Accept( BaseVisitor *visitor )
{
   visitor-&gt;Visit( this );
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;来委托给visitor 执行concrete class！
这种模式适合在权限设计，条件分子判断设计中使用，当然了，也容易造成concrete class 膨胀！&lt;/p&gt;

&lt;p&gt;首先，我们要先说单状态的状态模式，这种模式，我们不需要使用if – else语句就可以通过状态切换，达到行为切换！&lt;/p&gt;

&lt;p&gt;状态模式的优点在于遵循了很好的开闭原则和单一职责原则，只要修改状态，我们修改一个子类就好了。&lt;/p&gt;

&lt;p&gt;但是存在的问题在于如果状态过多，那就会导致子类过多，发生类膨胀，所以在使用这个模式的时候要权衡好状态模式的利弊！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/StatePattern.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
 
class Context;
class State
{
public:
    virtual void Handle(Context* pContext)=0;
    ~State(){}
protected:
    State(){}
private:
};
class Context
{
public:
    Context(State* pState){this-&gt;_state = pState;}
    ~Context(){}
    void Request()
    {
        if(NULL != this-&gt;_state)
        {
            this-&gt;_state-&gt;Handle(this);
        }
    }
    void ChangeState(State* pState)
    {
        this-&gt;_state = pState;
    }
protected:
private:
    State* _state;
};
class ConcreteStateA;
class ConcreteStateC : public State
{
public:
    ConcreteStateC(){}
    ~ConcreteStateC(){}
    virtual void Handle(Context* pContext)
    {
        cout &lt;&lt; &quot;ConcreteStateC&quot; &lt;&lt; endl;
        pContext-&gt;ChangeState(new ConcreteStateA());
    }
protected:
private:
};
class ConcreteStateB : public State
{
public:
    ConcreteStateB(){}
    ~ConcreteStateB(){}
    virtual void Handle(Context* pContext)
    {
        cout &lt;&lt; &quot;ConcreteStateB&quot; &lt;&lt; endl;
        pContext-&gt;ChangeState(new ConcreteStateC());
    }
protected:
private:
};
class ConcreteStateA : public State
{
public:
    ConcreteStateA(){}
    ~ConcreteStateA(){}
    virtual void Handle(Context* pContext)
    {
        cout &lt;&lt; &quot;ConcreteStateA&quot; &lt;&lt; endl;
        pContext-&gt;ChangeState(new ConcreteStateB());
        //execute and change status
    }
protected:
private:
};
 
int main()
{
    State* pState = new ConcreteStateA();
    Context* pContext = new Context(pState);
    pContext-&gt;Request();
    pContext-&gt;Request();
    pContext-&gt;Request();
    pContext-&gt;Request();
    pContext-&gt;Request();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;接下来，多状态切换，我们使用switch case来判断。&lt;/p&gt;

&lt;h5&gt;另外如果业务需求某项业务有多个状态，通常都是一些枚举常量，状态的变化都是依靠大量的多分支判断语句来实现，此时应该考虑将每一种业务状态定义为一个State的子类。这样这些对象就可以不依赖于其他对象儿独立变化了。&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/multiState.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
 
class CContext;
class COpenningState;
class CCloseingState;
class CRunningState;
class CStoppingState;
 
COpenningState* CContext::pOpenningState = NULL;
CCloseingState* CContext::pCloseingState = NULL;
CRunningState* CContext::pRunningState = NULL;
CStoppingState* CContext::pStoppingState = NULL;
 
class CLiftState
{
public:
    CLiftState(void){}
    virtual ~CLiftState(void){}
    void SetContext(CContext *pContext){this-&gt;m_pContext = pContext;}
    virtual void Open() = 0;
    virtual void Close() = 0;
    virtual void Run() = 0;
    virtual void Stop() = 0;
protected:
    CContext *m_pContext;
};
 
 
 
class CCloseingState :  public CLiftState
{
public:
    CCloseingState(void){}
    ~CCloseingState(void){}
    void Open()
    {
        this-&gt;CLiftState::m_pContext-&gt;SetLiftState(CContext::pOpenningState);
        this-&gt;CLiftState::m_pContext-&gt;GetLiftState()-&gt;Open();
    }
    void Close(){cout &lt;&lt; &quot;Close....&quot; &lt;&lt; endl;}
    void Run()
    {
        this-&gt;CLiftState::m_pContext-&gt;SetLiftState(CContext::pRunningState);
        this-&gt;CLiftState::m_pContext-&gt;GetLiftState()-&gt;Run();
    }
    void Stop()
    {
        this-&gt;CLiftState::m_pContext-&gt;SetLiftState(CContext::pStoppingState);
        this-&gt;CLiftState::m_pContext-&gt;GetLiftState()-&gt;Stop();
    }
};
class COpenningState : public CLiftState
{
public:
    COpenningState(void){}
    ~COpenningState(void){}
    void Open(){cout &lt;&lt; &quot;Open....&quot; &lt;&lt; endl;}
    void Close()
    {
        this-&gt;CLiftState::m_pContext-&gt;SetLiftState(CContext::pCloseingState);
        this-&gt;CLiftState::m_pContext-&gt;GetLiftState()-&gt;Close();
    }
    void Run(){ }
    void Stop(){}
};
class CRunningState : public CLiftState
{
public:
    CRunningState(void){}
    ~CRunningState(void){}
    void Open(){}
    void Close(){}
    void Run(){cout&lt;&lt;&quot;Run....&quot;&lt;&lt; endl;}
    void Stop()
    {
        this-&gt;CLiftState::m_pContext-&gt;SetLiftState(CContext::pStoppingState);
        this-&gt;CLiftState::m_pContext-&gt;GetLiftState()-&gt;Stop();
    }
};
class CStoppingState : public CLiftState
{
public:
    CStoppingState(void){}
    ~CStoppingState(void){}
    void Open()
    {
        this-&gt;CLiftState::m_pContext-&gt;SetLiftState(CContext::pOpenningState);
        this-&gt;CLiftState::m_pContext-&gt;GetLiftState()-&gt;Open();
    }
    void Close(){}
    void Run()
    {
        this-&gt;CLiftState::m_pContext-&gt;SetLiftState(CContext::pRunningState);
        this-&gt;CLiftState::m_pContext-&gt;GetLiftState()-&gt;Run();
    }
    void Stop(){cout &lt;&lt; &quot;Stop....&quot; &lt;&lt; endl;}
};
class CContext
{
public:
    CContext(void)
    {
        m_pLiftState = NULL;
        pOpenningState = new COpenningState();
        pCloseingState = new CCloseingState();
        pRunningState = new CRunningState();
        pStoppingState = new CStoppingState();
    }
    ~CContext(void)
    {
        delete pOpenningState;
        pOpenningState = NULL;
        delete pCloseingState;
        pCloseingState = NULL;
        delete pRunningState;
        pRunningState = NULL;
        delete pStoppingState;
        pStoppingState = NULL;
    }
 
    CLiftState * GetLiftState(){return m_pLiftState;}
    void SetLiftState(CLiftState *pLiftState)
    {
        this-&gt;m_pLiftState = pLiftState;
        this-&gt;m_pLiftState-&gt;SetContext(this);
    }
    void Open(){this-&gt;m_pLiftState-&gt;Open();}
    void Close(){this-&gt;m_pLiftState-&gt;Close();}
    void Run(){this-&gt;m_pLiftState-&gt;Run();}
    void Stop(){this-&gt;m_pLiftState-&gt;Stop();}
 
    static COpenningState *pOpenningState;
    static CCloseingState *pCloseingState;
    static CRunningState *pRunningState;
    static CStoppingState *pStoppingState;
 
private:
    CLiftState *m_pLiftState;
};
int main()
{
    CContext context;
    CCloseingState closeingState;
    context.SetLiftState(&amp;closeingState);
    context.Close();
    context.Open();
    context.Run();
    context.Stop();
}

&lt;/code&gt;&lt;/pre&gt;


&lt;h4&gt;状态模式实现了非常好的封装，对外屏蔽了状态切换，状态的切换就是类的切换！&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>Create Design Pattern Comparison</title>
      <link>place_your_blog_url_here/2014/07/14/create-design-pattern-comparison.html</link>
      <pubDate>14 Jul 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/07/14/create-design-pattern-comparison</guid>
      <description>&lt;h1&gt;创建类模式比较&lt;/h1&gt;

&lt;p&gt;创建类模式包括工厂方法模式，建造者模式，抽象工厂模式，单例模式，原型模式，这些都是创建类的design pattern，可以创建class的创建。&lt;/p&gt;

&lt;p&gt;单例模式和原型模式比较简单，单例模式主要是在内存中保持一个对象，原型模式是指通过复制的方式产生新的对象。&lt;/p&gt;

&lt;p&gt;比较容易混淆的是工厂模式，抽象工厂模式和建造者模式。&lt;/p&gt;

&lt;p&gt;1.工厂模式和抽象工厂模式其实就是一个工厂生产一种product与一个工厂生产多种product的区别。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/Factory.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/AbstractFactory.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面主要来说一下工厂模式与建造者模式的区别。&lt;/p&gt;

&lt;p&gt;工厂模式如上面所说的，创造一个整体的class，至于class内部是无法定制的。比如class内部的attribute，如果需要定制的话，就要用到建造者模式。&lt;/p&gt;

&lt;p&gt;两种模式的class复杂度是不同的，工厂模式创建的产品是单一性质的产品，无法更改。而建造者模式创建的是一种复合的class，粒度不同，建造者模式制造的类更加精细。&lt;/p&gt;

&lt;p&gt;抽象工厂模式与建造者模式区别其实与上面所说的差不多，&lt;/p&gt;

&lt;p&gt;抽象工厂屏蔽了建造的过程，建造者模式更加容易建造崭新的产品。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/IMG_0433.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5&gt;总的来说从建造类的粒度来看：工厂模式&gt;抽象工厂模式&gt;建造者模式&lt;/h5&gt;

&lt;p&gt;我们要根据实际项目，来选择不同的粒度。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Keynote of Data Mining by myself</title>
      <link>place_your_blog_url_here/2014/07/11/the-keynote-of-data-mining-by-myself.html</link>
      <pubDate>11 Jul 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/07/11/the-keynote-of-data-mining-by-myself</guid>
      <description>&lt;h1&gt;数据挖掘—–自己整理的笔记&lt;/h1&gt;

&lt;p&gt;将近一个月没有更新博客，主要这期间有太多的考试，数据挖掘就是其中的一门比较难的课程，由于一直不敢怎么掉以轻心，总结了好长的笔记来复习。其实在读研期间也曾考虑学习Data Mining方向，虽说不是很擅长，但是通过这门课也算是data mining入了门。&lt;/p&gt;

&lt;p&gt;本科时候也学过这门课，那时候主要以计算为主，其中的原理有很多是云里雾里的感觉。这次的学习，使得我从数据的预处理，到关联规则，分类，聚类的算法，有了清晰的了解，并可以通过分析各个算法的优缺点，改进现有某个算法的存在的问题。&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;h5&gt;支持向量机（ SVM）是 一种具有高准确率的分类方法。但是SVM 处理大型数据元组集时，速度很慢试开发一种可伸缩的算法克服以上困难。&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;先使用层次聚类的CF-tree构造出微小的聚类簇&lt;/li&gt;
&lt;li&gt;找出聚类簇的质心代表该聚类，然后使用SVM进行训练,这样可以大大减少数据元组的数量。&lt;/li&gt;
&lt;li&gt;找出超平面来划分这些微型聚类簇。&lt;/li&gt;
&lt;li&gt;加入新的聚类簇来进行SVM训练&lt;/li&gt;
&lt;li&gt;直到没有新的聚类簇加入，分类完毕&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;又比如：&lt;/p&gt;

&lt;h5&gt;提升的基本思想:假设你是一位患者,有某某些症状.你选择咨询多位医生,假设你根据医生先前的诊断准确率,对每位医生的诊断赋予一个权重.然后这些加权诊断的组合最为最终的诊断,这就是提升的基本思想.&lt;/h5&gt;

&lt;p&gt;提高决策归纳准确性的原因:在提升方法中,权重赋予每个训练元组.迭代的学习K个分类器序列,学习得到分类器Mi之后,更新权重,使得其后的分类器Mi+1”更关注” Mi误分类的训练元组，最终提升的分类器M*组合每个个体分类器，其中每个分类器投票的权重是其准确率的函数。可以扩充提升算法，预测连续值。&lt;/p&gt;

&lt;p&gt;这个就是分类与聚类的结合，通过这种方式，我们克服了SVM的缺点，为我们所用！&lt;/p&gt;

&lt;p&gt;下面贴出我从数据预处理，OLAP，到数据各种分类算法的笔记：&lt;/p&gt;

&lt;p&gt;——————————————————————————————————–&lt;/p&gt;

&lt;p&gt;1.数据仓库的概念：      数据仓库是一种为信息分析提供了良好的基础并支持管理决策活动的分析环境，是面向主题的，集成的，稳定的，不可更新的,随时间变化的，分层次的,多维的集成数据集合。&lt;/p&gt;

&lt;p&gt;特点：     1主题与面向主题；2数据的集成性；3数据的不可更新性；4数据的时态性。为什么要建立数据仓库：为了使数据能够发挥其最佳效用，更好的为用户服务，才要建立数据仓库。它可以从各信息源提取决策需要的数据，加工后，存储到数据仓库中；并且可以提供用户的查询和决策分析的依据。&lt;/p&gt;

&lt;p&gt;为什么建立数据仓库&lt;/p&gt;

&lt;p&gt;}   提高两个系统的性能&lt;/p&gt;

&lt;p&gt;◦       DBMS是为OLTP而设计的：存储方式,索引, 并发控制, 恢复&lt;/p&gt;

&lt;p&gt;◦       数据仓库是为OLAP而设计：复杂的 OLAP查询, 多维视图，汇总&lt;/p&gt;

&lt;p&gt;}   不同的功能和不同的数据:&lt;/p&gt;

&lt;p&gt;◦       历史数据: 决策支持需要历史数据，而这些数据在操作数据库中一般不会去维护&lt;/p&gt;

&lt;p&gt;◦       数据汇总：决策支持需要将来自异种源的数据统一（如聚集和汇总）&lt;/p&gt;

&lt;p&gt;◦       数据质量: 不同的源使用不一致的数据表示、编码和格式，对这些数据进行有效的分析需要将他们转化后进行集成&lt;/p&gt;

&lt;p&gt;建立数据仓库过程：&lt;/p&gt;

&lt;p&gt;1.自顶向下法：由总体设计和规划开始，在技术成熟、商业理解透彻的情况下使用。   &lt;br/&gt;
2.自底向上法：以实验和原型开始，常用在模型和技术开发的初期，可以有效的对使用的技术和模型进行评估，降低风险。
3.混合方法：上述两者的结合&lt;/p&gt;

&lt;p&gt;从软件过程的观点&lt;/p&gt;

&lt;p&gt;1.瀑布式方法：在进行下一步前，每一步都进行结构化和系统的分析&lt;/p&gt;

&lt;p&gt;2.螺旋式方法：功能渐增的系统的快速产生，相继版本之间间隔很短&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数据预处理：&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;}   不完整数据的成因：&lt;/p&gt;

&lt;p&gt;◦       数据收集的时候就缺乏合适的值&lt;/p&gt;

&lt;p&gt;◦       数据收集时和数据分析时的不同考虑因素&lt;/p&gt;

&lt;p&gt;◦       人为/硬件/软件 问题&lt;/p&gt;

&lt;p&gt;}   噪声数据（不正确的值）的成因&lt;/p&gt;

&lt;p&gt;◦       数据收集工具的问题&lt;/p&gt;

&lt;p&gt;◦       数据输入时的 人为/计算机 错误&lt;/p&gt;

&lt;p&gt;◦       数据传输中产生的错误&lt;/p&gt;

&lt;p&gt;}   数据不一致性的成因&lt;/p&gt;

&lt;p&gt;◦       不同的数据源&lt;/p&gt;

&lt;p&gt;◦       违反了函数依赖性&lt;/p&gt;

&lt;p&gt;}   没有高质量的数据，就没有高质量的挖掘结果&lt;/p&gt;

&lt;p&gt;◦       高质量的决策必须依赖高质量的数据&lt;/p&gt;

&lt;p&gt;◦       数据仓库需要对高质量的数据进行一致地集成&lt;/p&gt;

&lt;p&gt;◦       数据预处理将是构建数据仓库或者进行数据挖掘的工作中占工作量最大的一个步骤&lt;/p&gt;

&lt;p&gt;}   数据清理&lt;/p&gt;

&lt;p&gt;◦       填写空缺的值，平滑噪声数据，识别、删除孤立点，解决不一致性&lt;/p&gt;

&lt;p&gt;}   数据集成&lt;/p&gt;

&lt;p&gt;◦       集成多个数据库、数据立方体或文件&lt;/p&gt;

&lt;p&gt;}   数据变换&lt;/p&gt;

&lt;p&gt;◦       规范化和聚集&lt;/p&gt;

&lt;p&gt;}   数据归约&lt;/p&gt;

&lt;p&gt;◦       得到数据集的压缩表示，它小得多，但可以得到相同或相近的结果&lt;/p&gt;

&lt;p&gt;}   数据离散化&lt;/p&gt;

&lt;p&gt;◦       数据归约的一部分，通过概念分层和数据的离散化来规约数据，对数字型数据特别重要&lt;/p&gt;

&lt;p&gt;3.数据仓库的数据模型有哪些？&lt;/p&gt;

&lt;p&gt;数据仓库的数据模型包括：星型数据模型、雪花型数据模型、星群型数据模型。&lt;/p&gt;

&lt;p&gt;其中星型模型包括一个中央表（事实表）和一系列的附表（维度表），附表环绕中央表，并产生关系，但不关联。雪花型数据模型设计其附表（维度表）被进一步规范化，分割出额外的表，产生的图形像雪花状。这种形式易于维护并节省存储空间。但表之间的关联多，影响系统的性能，其使用没有星型构架广泛。星群型架构的数据模型设计是多个主表（事实表）共享附表（维度表），其是星型的集合。对于数据集市使用星群数据模型，雪花模型。&lt;/p&gt;

&lt;h5&gt;4.OLAP操作主要优点&lt;/h5&gt;

&lt;p&gt;}   数据视图经过演化的、集成的数据&lt;/p&gt;

&lt;p&gt;}   OLAP面向市场（分析）历史的、汇总的数据&lt;/p&gt;

&lt;p&gt;}   访问模式只读查询（但很多是复杂的查询）&lt;/p&gt;

&lt;p&gt;}   访问数据量数百万个&lt;/p&gt;

&lt;p&gt;}   用户数数百个&lt;/p&gt;

&lt;p&gt;}   数据库规模100GB-数TB&lt;/p&gt;

&lt;p&gt;}   设计优先性高灵活性、端点用户自治&lt;/p&gt;

&lt;p&gt;◦       度量查询吞吐量、响应时间，复杂的 OLAP查询, 多维视图，汇总&lt;/p&gt;

&lt;p&gt;}   不同的功能和不同的数据:&lt;/p&gt;

&lt;p&gt;◦       历史数据: 决策支持需要历史数据，而这些数据在操作数据库中一般不会去维护&lt;/p&gt;

&lt;p&gt;◦       数据汇总：决策支持需要将来自异种源的数据统一（如聚集和汇总）&lt;/p&gt;

&lt;p&gt;◦       数据质量: 不同的源使用不一致的数据表示、编码和格式，对这些数据进行有效的分析需要将他们转化后进行集成&lt;/p&gt;

&lt;p&gt;5.OLAP操作方法&lt;/p&gt;

&lt;p&gt;}   上卷(roll-up):汇总数据&lt;/p&gt;

&lt;p&gt;◦       通过一个维的概念分层向上攀升或者通过维规约&lt;/p&gt;

&lt;p&gt;◦       当用维归约进行上卷时，一个或多个维由给定的数据立方体删除&lt;/p&gt;

&lt;p&gt;}   下钻(drill-down)：上卷的逆操作&lt;/p&gt;

&lt;p&gt;◦       由不太详细的数据到更详细的数据，可以通过沿维的概念分层向下或引入新的维来实现 (为给定数据添加更多细节)&lt;/p&gt;

&lt;p&gt;}   切片和切块(slice and dice)&lt;/p&gt;

&lt;p&gt;◦       切片操作在给定的数据立方体的一个维上进行选择，导致一个子方&lt;/p&gt;

&lt;p&gt;◦       切块操作通过对两个或多个维进行选择，定义子方&lt;/p&gt;

&lt;p&gt;}   转轴(pivot)&lt;/p&gt;

&lt;p&gt;◦       立方体的重定位，可视化，或将一个3维立方体转化为一个2维平面序列&lt;/p&gt;

&lt;p&gt;◦       转轴是一种可视化操作，通过转动当前数据的视图来提供一个数据的替代表示&lt;/p&gt;

&lt;p&gt;}   其他OLAP操作&lt;/p&gt;

&lt;p&gt;◦       钻过(drill_across)：执行涉及多个事实表的查询&lt;/p&gt;

&lt;p&gt;◦       钻透(drill_through)：使用关系SQL机制，钻到数据立方体的底层，到后端关系表&lt;/p&gt;

&lt;p&gt;◦       其他OLAP操作可能包括列出表中最高或最低的N项，以及计算移动平均值、增长率、利润、统计函数等等&lt;/p&gt;

&lt;p&gt;6.Apriori过程，不足&lt;/p&gt;

&lt;p&gt;Apriori算法利用频繁项集性质的先验知识（prior knowledge），通过逐层搜索的迭代方法，即将k-项集用于探察(k+1)-项集，来穷尽数据集中的所有频繁项集。Apriori算法利用的是Apriori性质：频繁项集的所有非空子集也必须是频繁的。&lt;/p&gt;

&lt;p&gt;Apriori算法由连接和剪枝两个步骤组成。&lt;/p&gt;

&lt;p&gt;连接：为了找Lk，通过Lk-1与自己连接产生候选k-项集的集合，该候选k项集记为Ck。&lt;/p&gt;

&lt;p&gt;Ck是Lk的超集，即它的成员可能不是频繁的，但是所有频繁的k-项集都在Ck中。因此可以通过扫描数据库，通过计算每个k-项集的支持度来得到Lk 。为了减少计算量，可以使用Apriori性质，即如果一个k-项集的(k-1)-子集不在Lk-1中，则该候选不可能是频繁的，可以直接从Ck删除。&lt;/p&gt;

&lt;p&gt;不足：1.要对数据进行多次扫描；2.会产生大量的候选项集；3.对候选项集的支持度计算非常繁琐；&lt;/p&gt;

&lt;p&gt;7.简述决策树归纳算法，分析优缺点&lt;/p&gt;

&lt;p&gt;常见的算法有ID3，C4.5，CART算法，他们都是采用贪心（非回溯）的方法。&lt;/p&gt;

&lt;p&gt;树以代表训练样本的单个节点（N）开始
如果样本都在同一个类，则该节点成为树叶，并用该类标记
否则，算法调用Attribute_selection_method，选择能够最好的将样本分类的属性；确定“分裂准则”，指出“分裂点”或“分裂子集”。
对测试属性每个已知的值，创建一个分支，并以此划分元组
算法使用同样的过程，递归的形成每个划分上的元组决策树。一旦一个属性出现在一个节点上，就不在该节点的任何子节点上出现
递归划分步骤停止的条件：划分D（在N节点提供）的所有元组属于同一类，没有剩余属性可以用来进一步划分元组——使用多数表决，没有剩余的样本，给定分支没有元组，则以D中多数类创建一个树叶
优点(1) 速度快：计算量相对较小，且容易转化成分类规则。只要沿着树根向下一直走到叶，沿途的分裂条件就能够唯一确定一条分类的谓词。&lt;/p&gt;

&lt;p&gt;(2) 准确性高：挖掘出的分类规则准确性高，便于理解，决策树可以清晰的显示哪些字段比较重要。&lt;/p&gt;

&lt;p&gt;缺点(1) 缺乏伸缩性：由于进行深度优先搜索，所以算法受内存大小限制，难于处理大训练集。(2) 要多次扫描数据集，导致低效。决策树技术也可能产生子树复制和碎片问题。&lt;/p&gt;

&lt;p&gt;8.简述人工神经网络分类方法及其优缺点&lt;/p&gt;

&lt;p&gt;人工神经网络分类方法主要包括，贝叶斯信念网络，向后传播分类，SVM，频繁模式分类，遗传算法。（人工神经网络分类方法很多都是监督学习，模型的学习在被告知每个训练样本属于哪个类的“指导”下进行，新数据使用训练数据集中得到的规则进行分类）贝叶斯信念网络通过计算元素的相关度，将元素进行划分。后向传播是一种神经网络学习算法；神经网络是一组连接的输入/输出单元，每个连接都与一个权相连。在学习阶段，通过调整神经网络的权，使得能够预测输入样本的正确标号来学习。SVM使用一种非线性的映射，将原训练数据映射到较高的维，使用一个适当的对足够高维的非线性映射，两类的数据总可以被超平面分开。遗传算法对于一个规模为N的种群S,按每个染色体si∈S的选择计算适应度，进行复制操作。&lt;/p&gt;

&lt;p&gt;}   优点：预测精度总的来说较高，健壮性好，训练样本中包含错误时也可正常工作&lt;/p&gt;

&lt;p&gt;，输出可能是离散值、连续值或者是离散或量化属性的向量值，对目标进行分类较快&lt;/p&gt;

&lt;p&gt;}   缺点：训练（学习）时间长，蕴涵在学习的权中的符号含义很难理解，很难和专业领域知识相整合&lt;/p&gt;

&lt;p&gt;提高分类准确率的技术：装袋，提升，adaboost。&lt;/p&gt;

&lt;p&gt;}   Bagging技术和boosting技术都通过将T个学习得到的分类法C1,C2…CT组合起来，从而创造一个改进的分类法C*&lt;/p&gt;

&lt;p&gt;}   Boosting技术，每个训练样本赋予一个权值Ct的权值取决于其错误率&lt;/p&gt;

&lt;p&gt;48、简述决策树归纳算法，分析优缺点&lt;/p&gt;

&lt;p&gt;常见的算法有ID3，C4.5，CART算法，他们都是采用贪心（非回溯）的方法。&lt;/p&gt;

&lt;p&gt;树以代表训练样本的单个节点（N）开始
如果样本都在同一个类，则该节点成为树叶，并用该类标记
否则，算法调用Attribute_selection_method，选择能够最好的将样本分类的属性；确定“分裂准则”，指出“分裂点”或“分裂子集”。
对测试属性每个已知的值，创建一个分支，并以此划分元组
算法使用同样的过程，递归的形成每个划分上的元组决策树。一旦一个属性出现在一个节点上，就不在该节点的任何子节点上出现
递归划分步骤停止的条件：划分D（在N节点提供）的所有元组属于同一类，没有剩余属性可以用来进一步划分元组——使用多数表决，没有剩余的样本，给定分支没有元组，则以D中多数类创建一个树叶
优点(1) 速度快：计算量相对较小，且容易转化成分类规则。只要沿着树根向下一直走到叶，沿途的分裂条件就能够唯一确定一条分类的谓词。&lt;/p&gt;

&lt;p&gt;(2) 准确性高：挖掘出的分类规则准确性高，便于理解，决策树可以清晰的显示哪些字段比较重要。&lt;/p&gt;

&lt;p&gt;缺点(1) 缺乏伸缩性：由于进行深度优先搜索，所以算法受内存大小限制，难于处理大训练集。(2) 要多次扫描数据集，导致低效。决策树技术也可能产生子树复制和碎片问题。&lt;/p&gt;

&lt;p&gt;61、贝叶斯网络的特点：&lt;/p&gt;

&lt;p&gt;（1）贝叶斯分类提供了一种用图形模型来捕获特定领域的先验知识的方法，网络还可以用来对变量间的因果依赖关系进行编码。（2）构造网格可能既费时又费力，但一旦网格结构确定下来，添加新变量就十分容易。（3）贝叶斯网络很适合处理不完整的数据。（4）因为数据和先验知识以概率方式结合起来了，所以该方法对模型的过分拟合问题是非常鲁棒的。&lt;/p&gt;

&lt;p&gt;62、神经网络的特点&lt;/p&gt;

&lt;p&gt;（1）对于噪声数据的承受能力高，对未经训练的数据的模式分类能力强。（2）神经网络可以处理冗余特征，对训练数据中的噪声非常敏感。（3）不像大部分的决策数算法，它非常适合连续值得输入和输出。(4)神经网络算法是固有并行的，可以使用并行技术来加快计算过程。(5)神经网络权值学习使用的梯度下降方法经常会收敛到局部极小值。训练神经网络是一个很耗时的过程，而测试样例分类时非常快。&lt;/p&gt;

&lt;p&gt;51、分类的过程包括获取数据、预处理、分类器设计和分类决策。&lt;/p&gt;

&lt;p&gt;2、分类器设计阶段包含三个过程：划分数据集、分类器构造和分类器测试。&lt;/p&gt;

&lt;p&gt;3、分类问题中常用的评价准则有精确度、查全率和查准率和集合均值。&lt;/p&gt;

&lt;p&gt;52、聚类分析包括连续型、二值离散型、多值离散型和混合类型4种类型描述属性的相似度计算方法。&lt;/p&gt;

&lt;p&gt;63、K 最邻近分类特点：&lt;/p&gt;

&lt;p&gt;（1）由于KNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，KNN方法较其他方法更为适合。(2) 当样本不平衡时，如一个类的样本容量很大，而其他类样本容量很小时，有可能导致当输入一个新样本时，该样本的K个邻居中大容量类的样本占多数。数量影响运行结果。(可以采用权值的方法来改进)。(3)该方法的另一个不足之处是计算量较大。(4)准确率受噪声影响。&lt;/p&gt;

&lt;h4&gt;9,。简述主要的聚类方法，分析聚类算法以及各自特点。&lt;/h4&gt;

&lt;p&gt;划分方法：K-均值，K-中心点，CLARA&lt;/p&gt;

&lt;p&gt;给定一个n个对象或元组的数据库，一个划分方法构建数据的k个划分，每个划分表示一个簇，并且k&amp;lt;=n。每个组至少包含一个对象，每个对象属于且仅属于一个组。&lt;/p&gt;

&lt;p&gt;k-平均算法由簇的平均值来代表整个簇。噪声，离群点产生较大影响，不适用于非凸形状的簇，需要指定k。&lt;/p&gt;

&lt;p&gt;k中心点算法，由处于簇的中心区域的某个值代表整个簇。每次迭代复杂度比较大，需要指定k。&lt;/p&gt;

&lt;p&gt;CLARA ，先抽样，然后用样本进行k中心点算法。&lt;/p&gt;

&lt;p&gt;基于距离的聚类方法的缺点：只能发现球状的簇，难以发现任意形状的簇。&lt;/p&gt;

&lt;p&gt;层次的方法：对给定数据对象集合进行层次分解&lt;/p&gt;

&lt;p&gt;自底向上方法（凝聚AGNES）：开始将每个对象作为单独的一个组，然后相继的合并相近的对象或组，直到所有的组合并为一个，或者达到一个终止条件。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;输入:包含n个对象的数据库，终止条件簇的数目k&lt;/p&gt;

&lt;p&gt;输出:k个簇，达到终止条件规定簇数目&lt;/p&gt;

&lt;p&gt;(1)将每个对象当成一个初始簇；&lt;/p&gt;

&lt;p&gt;(2)Repeat&lt;/p&gt;

&lt;p&gt;(3) 根据两个簇中最近的数据点（单链接）找到最近的两个簇；&lt;/p&gt;

&lt;p&gt;(4) 合并两个簇，生成新的簇的集合；&lt;/p&gt;

&lt;p&gt;(5)Until 达到定义的簇的数目&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;AGNES算法比较简单，但经常会遇到合并点选择的困难。如果在某一步没有很好地选择出合并点，很可能导致低质量的聚类结果。而且此算法没有良好的可伸缩性，算法复杂度较高。&lt;/p&gt;

&lt;p&gt;自顶向下方法（分裂DIANA）：开始将所有的对象置于一个簇中，在迭代的每一步，一个簇被分裂为多个更小的簇，直到最终每个对象在一个单独的簇中，或达到一个终止条件&lt;/p&gt;

&lt;p&gt;输入：包含n个对象的数据库，终止条件簇的数目k&lt;/p&gt;

&lt;p&gt;输出：k个簇，达到终止条件规定簇数目&lt;/p&gt;

&lt;p&gt;（1）将所有对象整个当成一个初始簇&lt;/p&gt;

&lt;p&gt;（2） For ( i=1;i!=k; i++)&lt;/p&gt;

&lt;p&gt;（3） 在所有簇中挑选出具有最大直径的簇c；&lt;/p&gt;

&lt;p&gt;（4） 找出簇c里与其他点平均相异度最大的一个点放入splinter group，剩余的放入old party中。&lt;/p&gt;

&lt;p&gt;（5） Repeat&lt;/p&gt;

&lt;p&gt;（6） 在old party里找出到splinter group中点的最近距离不大于old party中点的最近距离的点，并将该点加入splinter group&lt;/p&gt;

&lt;p&gt;（7）  Until 没有新的old party的点被分配给splinter group；&lt;/p&gt;

&lt;p&gt;（8）  Splinter group 和old party为被选中的簇分裂成的两个簇，与其他簇一起组成新的簇集合&lt;/p&gt;

&lt;p&gt;（9）  end for&lt;/p&gt;

&lt;p&gt;（9）  END&lt;/p&gt;

&lt;p&gt;缺点：合并或分裂的步骤不能被撤销。类之间不能交换对象。如果在某步没有选择好分裂点，可能会导致低质量的聚类结果。大数据集不太适用。&lt;/p&gt;

&lt;p&gt;BIRCH(聚类特征树): 首先使用层次聚类算法将对象分组成微簇，然后用另一个聚类方法对这些微簇进行宏聚类。&lt;/p&gt;

&lt;p&gt;算法第一阶段：构造CF树（两个参数：分枝因子B和阈值T）第二阶段：用选定的聚类算法对叶结点进行聚类&lt;/p&gt;

&lt;p&gt;分枝因子B：定义节点的分支最大个数  阈值T：定义叶结点中子簇的最大直径&lt;/p&gt;

&lt;p&gt;CF 树的构造过程实际上是一个数据点的插入过程&lt;/p&gt;

&lt;p&gt;(1) 从根节点root 开始递归往下，计算当前条目与要插入数据点之间的距离，寻找距离最小的那个路径，直到找到与该数据点最接近的叶节点中的条目。&lt;/p&gt;

&lt;p&gt;(2) 比较计算出的距离是否小于阈值T，如果小于则当前条目吸收该数据点；反之，则继续第三步。&lt;/p&gt;

&lt;p&gt;(3) 判断当前条目所在叶节点的条目个数是否小于L，如果是，则直接将数据点插入作 为该数据点的新条目，否则需要分裂该叶节点。分裂的原则是寻找该叶节点中距离最远的两 个条目并以这两个条目作为分裂后新的两个叶节点的起始条目，其他剩下的条目根据距离最 小原则分配到这两个新的叶节点中，删除原叶节点并更新整个CF 树。&lt;/p&gt;

&lt;p&gt;基于密度的方法：DBSCAN，OPTICS，DENCLUE&lt;/p&gt;

&lt;p&gt;DBSCAN，OPTICS， DENCLUE：基于连接和密度函数：只要临近区域的密度（对象或数据点的数目）超过某个临界值，就继续聚类。优点：可以过滤掉“噪声”和“离群点”，发现任意形状的簇。需要定义密度参数作为终结条件&lt;/p&gt;

&lt;p&gt;基于网格的方法: 基于多层粒度结构，把对象空间量化为有限数目的单元，形成一个网格结构。所有的聚类都在这个网格结构上进行。&lt;/p&gt;

&lt;p&gt;STING，CLIQUE，优点：处理数度快，缺点：簇边界都是竖直的，降低簇的质量和精确性。&lt;/p&gt;

&lt;p&gt;基于模型的方法：为每个簇假定一个模型，寻找数据对给定模型的最佳拟合。&lt;/p&gt;

&lt;p&gt;42、K-均值 划分方法&lt;/p&gt;

&lt;p&gt;给定k 值, k -均值算法 通过以下4个步骤实现:&lt;/p&gt;

&lt;p&gt;随机选择k个对象，每个对象初始地代表一个簇的平均值或中心；&lt;/p&gt;

&lt;p&gt;其余每个对象，根据其与各个簇中心的距离，将它赋给最近的簇；&lt;/p&gt;

&lt;p&gt;重新计算每个簇的平均值 ；&lt;/p&gt;

&lt;p&gt;重复此过程，直至准则函数收敛。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;K-均值聚类法的优缺点：&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;缺点:  在 K-means 算法中 K 是事先给定的，这个 K 值的选定是非常难以估计的。&lt;/p&gt;

&lt;p&gt;在K-means 算法中，首先需要根据初始聚类中心来确定一个初始划分，然后对初始划分进行优化。这个初始聚类中心的选择对聚类结果有较大的影响，一旦初始值选择的不好，可能无法得到有效的聚类结果。&lt;/p&gt;

&lt;p&gt;从 K-means 算法框架可以看出，该算法需要不断地进行样本分类调整，不断地计算调整后的新的聚类中心，因此当数据量非常大时，算法的时间开销是非常大的。&lt;/p&gt;

&lt;p&gt;对“噪声”数据敏感。&lt;/p&gt;

&lt;p&gt; 优点：   本算法确定的K个划分到达平方误差最小。当聚类是密集的，且类与类之间区别明显时，效果较好。对于处理大数据集，这个算法是相对可伸缩和高效的，计算的复杂度为O(NKt)，其中N是数据对象的数目，t是迭代的次数。一般来说，K&amp;lt;&amp;lt;N，t&amp;lt;&amp;lt;N 。&lt;/p&gt;

&lt;p&gt;57、K中心点算法的优缺点：&lt;/p&gt;

&lt;p&gt;优点：    对噪声不敏感，具有较强的数据鲁棒性。&lt;/p&gt;

&lt;p&gt;缺点:     聚类过程的高耗时性，计算速度慢，计算量大：通过迭代来寻找最佳的聚类中心点集时，需要反复地在非中心点对象与中心点对象之间进行最近邻搜索，从而产生大量非必需的重复计算，聚类过程缓慢，不能满足实际应用的需求。&lt;/p&gt;

&lt;p&gt;43、DBSCAN算法&lt;/p&gt;

&lt;p&gt;l   任选一对象 p；&lt;/p&gt;

&lt;p&gt;l   检索所有从p关于ε和MinPts 密度可达的对象；&lt;/p&gt;

&lt;p&gt;l   如果 p 是核心对象, 则创建一个新簇；&lt;/p&gt;

&lt;p&gt;l   如果 p 是边界点, 无任何对象是从p关于ε和MinPts 密度可达的对象，DBSCAN 访问数据库中的下一对象；&lt;/p&gt;

&lt;p&gt;l   继续此过程直到所有的点已处理。&lt;/p&gt;

&lt;p&gt; 数据挖掘在软件工程中应用：&lt;/p&gt;

&lt;blockquote&gt;&lt;h5&gt;1.软件漏洞检测用于找出软件开发过程中的错误或漏洞，以便及时进行修正，保证软件可靠性和质量。选择合适的数据挖掘模型进行训练和验证。根据项目需求选择合适的挖掘方法，为该方法生成训练集和测试集，通过比较结果选择最合适的方法；通过前面步骤中的方法对软件漏洞进行分类、定位和描述。找出未知的漏洞，根据一定规则对漏洞进行分类和描述。&lt;/h5&gt;

&lt;h5&gt;2.开源软件挖掘中最常用的方法之一是克隆代码检测，通常情况下，OSS 之间共用代码的情况是非常普遍的，有实验表明50%以上的源文件被应用到两个以上的开源项目中。因此就可以使用克隆代码检测的方法对单个软件内以及两个软件之间的代码进行检测。克隆代码就是以代码复用为目的而进行拷贝和粘贴的代码段，对克隆代码进行检测可以有效防止漏洞的拷贝性传播，另外还有利于软件在演化过程中的维护。&lt;/h5&gt;

&lt;h5&gt;3.版本控制系统（如CVS，SVN，Visual SourceSafe ，Git等）用以确保项目参与者所编辑的同一档案得到统一的，全局的更新。目前几乎所有的软件开发都会采用版本控制系统来管理软件开发活动。当前对版本控制信息的挖掘应用基本都是对软件变更历史进行挖掘的，用以发现不同程序模块及其子系统之间的相互依赖关系，从而预测程序漏洞的引入方式或者未来的变化。通过以上挖掘活动，可以有效地降低系统后期维护代价，预防一些因变更而引入的漏洞，从而为软件系统的后期维护提供警示作用，为项目的管理及相关决策提供重要的参考依据。&lt;/h5&gt;&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Flyweight Pattern with C++</title>
      <link>place_your_blog_url_here/2014/06/20/flyweight-pattern-with-c.html</link>
      <pubDate>20 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/20/flyweight-pattern-with-c</guid>
      <description>&lt;h1&gt;享元模式 C++实现&lt;/h1&gt;

&lt;p&gt;享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例数据除了几个参数外基本都是相同的。有时就能够大幅度地减少实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。&lt;/p&gt;

&lt;p&gt;这种模式可以运用共享技术有效地支持大量细粒度的对象。适合具有缓冲池的场景。&lt;/p&gt;

&lt;p&gt;首先我们要分清楚享元模式的内部状态和外部状态。&lt;/p&gt;

&lt;p&gt;内部状态：在享元对象内部并且不会随环境改变而改变的共享部分，可以称为是享元对象的内部状态，比如base class中的member&lt;/p&gt;

&lt;p&gt;外部状态：而随环境改变而改变的，取决于应用环境，或是实时数据，这些不可以共享的东西就是外部状态了。比如存在的map的key值&lt;/p&gt;

&lt;p&gt;内部状态存储于ConcreteFlyweight对象之中；而外部状态则由Client对象存储或计算。&lt;/p&gt;

&lt;h4&gt;当用户调用Flyweight对象的操作时，将该状态传递给它。&lt;/h4&gt;

&lt;h4&gt;外部状态有一个factory，负责维护外部状态，并把外部状态和class放入container中。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/flyweight.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;hash_map&gt;
using namespace std;
 
class Flyweight
{
public:
    //操作外部状态extrinsicState
    virtual void Operation(const string&amp; extrinsicState)=0;
    string GetIntrinsicState()
    {
        return this-&gt;_intrinsicState;
    }
    virtual ~Flyweight(){}
protected:
    Flyweight(string intrinsicState)
    {
        this-&gt;_intrinsicState = intrinsicState;
    }
private:
    //内部状态，也可以放在ConcreteFlyweight中
    string _intrinsicState;
};
 
class ConcreteFlyweight:public Flyweight
{
public:
    virtual void Operation(const string&amp; extrinsicState)
    {
        cout &lt;&lt; this-&gt;GetIntrinsicState() &lt;&lt; endl;
        cout &lt;&lt; extrinsicState &lt;&lt; endl;
    }
    ConcreteFlyweight(string intrinsicState):Flyweight(intrinsicState){}
    ~ConcreteFlyweight(){}
};
 
class UnsharedConcreteFlyweight:public Flyweight
{
public:
    virtual void Operation(const string&amp; extrinsicState)
    {
        cout &lt;&lt; extrinsicState &lt;&lt; endl;
    }
    UnsharedConcreteFlyweight(string intrinsicState):Flyweight(intrinsicState){}
    ~UnsharedConcreteFlyweight(){}
};
 
class FlyweightFactory
{
public:
    FlyweightFactory(){}
    ~FlyweightFactory(){}
    //获得一个请求的Flyweight对象
    Flyweight* GetFlyweight(string key)
    {
        if(m_mapFly.find(key)!=m_mapFly.end())
        {
            return m_mapFly[key];
        }
        //Flyweight* fly = new ConcreteFlyweight(key);
        Flyweight* fly = new UnsharedConcreteFlyweight(key);
        this-&gt;m_mapFly.insert(pair&lt;string,Flyweight*&gt;(key,fly));
        return fly;
    }
    //获取容器中存储的对象数量
    void GetFlyweightCount()
    {
        cout &lt;&lt; this-&gt;m_mapFly.size() &lt;&lt; endl;
    }
protected:
private:
    //保存内部状态对象的容器
    hash_map&lt;string,Flyweight*&gt; m_mapFly;
};
 
int main()
{
    //外部状态extrinsicState
    string extrinsicState = &quot;ext&quot;;
 
    //工厂对象，工厂对象
    FlyweightFactory* fc = new FlyweightFactory();
 
    Flyweight* fly = fc-&gt;GetFlyweight(&quot;hello&quot;);
    fly = fc-&gt;GetFlyweight(&quot;hello1&quot;);
 
    fly = fc-&gt;GetFlyweight(&quot;hello&quot;);
 
    //应用外部状态
    fly-&gt;Operation(&quot;hello3&quot;);
 
    fc-&gt;GetFlyweightCount();
 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;线程环境下，必须使用锁变量。结局这种问题的方式，就是使用外部类来当做key值，但是这又会出现另一个问题：维护一个container。class的效率明显比string类型低。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/lcl_data/article/details/8974679&quot;&gt;http://blog.csdn.net/lcl_data/article/details/8974679&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/library/th79x793.aspx&quot;&gt;http://msdn.microsoft.com/zh-cn/library/th79x793.aspx&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bridge Pattern with C++</title>
      <link>place_your_blog_url_here/2014/06/19/bridge-pattern-with-c.html</link>
      <pubDate>19 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/19/bridge-pattern-with-c</guid>
      <description>&lt;h1&gt;桥梁模式 C++实现&lt;/h1&gt;

&lt;p&gt;桥梁模式主要解决多层继承，比如我们可以想想，人可以分为男人女人，人又有不同的行为。如果把这个两个class继承，也就意味着是男人行为A，男人行为B。女人行为A，女人行为B。
这种方式非常难以扩展，所以桥梁模式派上用场，它将表示和实现解耦,两者可以独立的变化。&lt;/p&gt;

&lt;h5&gt;也就是抽象出人和行为，然后人调用行为，减少了继承的class。&lt;/h5&gt;

&lt;p&gt;其中这种模式又有一些像策略模式，又有一些像建造者模式。&lt;/p&gt;

&lt;h5&gt;当我们考虑一个对象的多个变化因素可以动态变化的时候，考虑使用桥接模式&lt;/h5&gt;

&lt;p&gt;优点&lt;/p&gt;

&lt;p&gt;1.将实现抽离出来，再实现抽象，使得对象的具体实现依赖于抽象，满足了依赖倒转原则。&lt;/p&gt;

&lt;p&gt;2.将可以共享的变化部分，抽离出来，减少了代码的重复信息。&lt;/p&gt;

&lt;p&gt;3.对象的具体实现可以更加灵活，可以满足多个因素变化的要求。&lt;/p&gt;

&lt;p&gt;缺点&lt;/p&gt;

&lt;p&gt;1.客户必须知道选择哪一种类型的实现。&lt;/p&gt;

&lt;p&gt;如果我们用山寨工厂和房地产工厂生产产品做例子，非常清晰易懂。&lt;/p&gt;

&lt;h4&gt;这里我们要知道class IProduct中有两个虚基类，用于动态绑定！&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/bridge.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;list&gt;
using namespace std;
 
class IProduct
{
public:
    IProduct(void)
    {
    }
    virtual ~IProduct(void)
    {
    }
    virtual void BeProducted() = 0;
    virtual void BeSelled() = 0;
};
 
class CNewCorp
{
public:
    CNewCorp(IProduct *pproduct)
    {
        this-&gt;m_pProduct = pproduct;
    }
    virtual ~CNewCorp(void){}
    void MakeMoney()
    {
        //每个公司都是一样，先生产
        this-&gt;m_pProduct-&gt;BeProducted();
        //然后销售
        this-&gt;m_pProduct-&gt;BeSelled();
    }
private:
    IProduct *m_pProduct;
};
class CHouse : public IProduct
{
public:
    CHouse(void){}
    ~CHouse(void){}
    void BeProducted(){cout &lt;&lt; &quot;生产出的房子是这个样子的...&quot; &lt;&lt; endl;}
    void BeSelled(){cout &lt;&lt; &quot;生产出的房子卖出去了...&quot; &lt;&lt; endl;}
};
 
class CClothes : public IProduct
{
public:
    CClothes(void){}
    ~CClothes(void){}
    void BeProducted(){cout &lt;&lt; &quot;生产出的衣服是这个样子的...&quot; &lt;&lt; endl;}
    void BeSelled(){cout &lt;&lt; &quot;生产出的衣服卖出去了...&quot; &lt;&lt; endl;}
};
 
class CNewHouseCorp : public CNewCorp
{
public:
    CNewHouseCorp(CHouse *pHouse):CNewCorp(pHouse){}
    ~CNewHouseCorp(void){}
    void MakeMoney()
    {
        this-&gt;CNewCorp::MakeMoney();
        cout &lt;&lt; &quot;房地产公司赚大钱了...&quot; &lt;&lt; endl;
    }
};
 
class CIPod :public IProduct
{
public:
    CIPod(void){}
    ~CIPod(void){}
    void BeProducted(){cout &lt;&lt; &quot;生产出的ipod是这个样子的...&quot; &lt;&lt; endl;}
    void BeSelled(){ cout &lt;&lt; &quot;生产出的ipod卖出去了...&quot; &lt;&lt; endl;}
};
 
class CShanZhaiCorp : public CNewCorp
{
public:
    CShanZhaiCorp(IProduct *pproduct): CNewCorp(pproduct){}
    ~CShanZhaiCorp(void){}
    void MakeMoney()
    {
        this-&gt;CNewCorp::MakeMoney();
        cout &lt;&lt; &quot;我赚钱呀...&quot; &lt;&lt; endl;
    }
};
void DoNewRun1()
{
    cout &lt;&lt; &quot;----------房地产公司是这样运行的----------&quot; &lt;&lt; endl;
    CHouse house;
    CNewHouseCorp newHouseCorp(&amp;house);
    newHouseCorp.MakeMoney();
    cout &lt;&lt; endl;
 
    cout &lt;&lt; &quot;----------山寨公司是这样运行的----------&quot; &lt;&lt; endl;
    CClothes clothes;
    CShanZhaiCorp shanZhaiCorp(&amp;clothes);
    shanZhaiCorp.MakeMoney();
    cout &lt;&lt; endl;
}
 
void DoNewRun2()
{
    cout &lt;&lt; &quot;----------房地产公司是这样运行的----------&quot; &lt;&lt; endl;
    CHouse house;
    CNewHouseCorp newHouseCorp(&amp;house);
    newHouseCorp.MakeMoney();
    cout &lt;&lt; endl;
 
    cout &lt;&lt; &quot;----------山寨公司是这样运行的----------&quot; &lt;&lt; endl;
    CIPod ipod;
    CShanZhaiCorp shanZhaiCorp(&amp;ipod);
    shanZhaiCorp.MakeMoney();
    cout &lt;&lt; endl;
}
 
int main()
{
    DoNewRun1();
 
    DoNewRun2();
    return 0;
}
 &lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;这里我们要说明的是Java中我们可以使用super.func()的方式调用基类，在C++中，我们直接this-&gt;CNewCorp::MakeMoney();来调用基类&lt;/p&gt;

&lt;p&gt;另外，我们要深刻理解动态绑定的灵活性！&lt;/p&gt;

&lt;p&gt;客户直接使用CNewHouseCorp和CShanZhaiCorp类.&lt;/p&gt;

&lt;h4&gt;在main()函数里构造产品，然后传到这两个类里。这两个类的MakeMoney()函数，先调用基类的MakeMoney()，然后分别执行各自的逻辑。各自逻辑就是子类的具体实现（concreteimplement）&lt;/h4&gt;

&lt;p&gt;参考&lt;a href=&quot;http://www.cnblogs.com/jiese/p/3164940.html&quot;&gt;http://www.cnblogs.com/jiese/p/3164940.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Visitor Pattern with C++</title>
      <link>place_your_blog_url_here/2014/06/17/visitor-pattern-with-c.html</link>
      <pubDate>17 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/17/visitor-pattern-with-c</guid>
      <description>&lt;h1&gt;访问者模式 C++实现&lt;/h1&gt;

&lt;p&gt;访问者模式，顾名思义就是使用vistor类来访问其他类的intern数据，而不改变intern的数据结构和代码。
这样可以分开数据显示和业务逻辑，使得代码更加清晰。&lt;/p&gt;

&lt;p&gt;访问者模式的优点就是：灵活度非常高，有优秀的拓展性。
缺点就是：不依赖抽象元素，违反了依赖倒置的原则，直接依赖实现类，拓展实现类比较难。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;访问者模式和迭代器模式有相同点又有不同点。
相同点都是访问具体的实现类。
不同点在于迭代器模式只能访问相同由base class引用来的class或者interface的数据，而访问者模式可以访问不同的class，不再依赖base class&lt;/p&gt;&lt;/blockquote&gt;

&lt;h5&gt;总的来说 访问者模式适用范围大于迭代器模式的范围！&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/visitor.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面这种方式是使用不同访问者定义不同的访问方式，可以说是多个访问者。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;list&gt;
using namespace std;
 
class BaseElement;
 
class BaseVisitor
{
public:
    virtual void Visit( BaseElement *element ){};
};
 
class BaseElement
{
public:
    // Methods
    virtual void Accept( BaseVisitor *visitor ){};
};
 
 
// &quot;ConcreteElement&quot;
class Employee : public BaseElement
{
public:
    string name;
    double income;
    int vacationDays;
 
public :
    Employee( string name, double income,
        int vacationDays )
    {
        this-&gt;name = name;
        this-&gt;income = income;
        this-&gt;vacationDays = vacationDays;
    }
 
    void Accept( BaseVisitor *visitor )
    {
        visitor-&gt;Visit( this );
    }
};
 
class IncomeVisitor : public BaseVisitor
{
public: 
    void Visit( BaseElement *element )
    {
        Employee *employee = ((Employee*)element);
        employee-&gt;income *= 1.10;
        cout&lt;&lt;employee-&gt;name&lt;&lt;&quot; 's new income: &quot; &lt;&lt; employee-&gt;income&lt;&lt; endl; 
    }
};
 
class VacationVisitor : public BaseVisitor
{
public :
    void Visit( BaseElement *element )
    {
        Employee *employee = ((Employee*)element);
        employee-&gt;vacationDays += 3;     
        cout&lt;&lt; employee-&gt;name &lt;&lt;&quot; 's new vacation days: &quot; &lt;&lt; employee-&gt;vacationDays&lt;&lt; endl;
    }
};
 
class Employees
{   
private :
    list&lt; Employee*&gt; employees;
 
public :
 
    void Attach( Employee *employee )
    {       
        employees.push_back(employee);      
    }
 
    void Detach( Employee *employee )
    {
        employees.remove(employee);     
    }
 
    void Accept( BaseVisitor *visitor )
    {       
        for (std::list&lt;Employee*&gt;::iterator it=employees.begin(); it != employees.end(); ++it)
            (*it)-&gt;Accept(visitor);
    }
};
 
void main( )
{
    Employees *e = new Employees();
    e-&gt;Attach( new Employee( &quot;Jason&quot;, 25000.0, 14 ) );
    e-&gt;Attach( new Employee( &quot;Albter&quot;, 35000.0, 16 ) );
    e-&gt;Attach( new Employee( &quot;lily&quot;, 45000.0, 21 ) );
 
    IncomeVisitor *v1 = new IncomeVisitor();
    VacationVisitor *v2 = new VacationVisitor();
 
    e-&gt;Accept( v1 );
    e-&gt;Accept( v2 );
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;在vistor模式中，以及以前的design pattern中，我们都使用了动态绑定！
动态绑定就是在基类中定义virtual function 然后继承该base class，创建derive class时转到base class。当我们使用derive class中的function，我们只需要把base class指针指向该函数即可！&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;我们要分清函数重载与动态绑定在工程中的区别（重载只是函数类型不同而已！）&lt;/p&gt;

&lt;p&gt;动态绑定中，函数的执行操作决定于请求种类，与接收者类型！&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;访问者模式适合于重构！比如功能集中化，UI集中化。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Memento Pattern with C++</title>
      <link>place_your_blog_url_here/2014/06/12/memento-pattern-with-c.html</link>
      <pubDate>12 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/12/memento-pattern-with-c</guid>
      <description>&lt;h1&gt;备忘录模式C++实现&lt;/h1&gt;

&lt;p&gt;备忘录模式是一种比较重要的设计模式，如果程序执行错误，我们可以恢复restore之前的状态，就好像我们在编辑word文档，需要撤销原操作，那么我们使用ctrl+Z。
在数据库操作中，这个模式用的非常多！&lt;/p&gt;

&lt;p&gt;说白了就是在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。&lt;/p&gt;

&lt;p&gt;这个模式有三个对象：&lt;/p&gt;

&lt;p&gt;Originator（执行业务逻辑的class）：负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。Originator可根据需要决定Memento存储Originator的哪些内部状态。&lt;/p&gt;

&lt;p&gt;Memento（备份数据的class）:负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。&lt;/p&gt;

&lt;p&gt;Caretaker（说白了就是管理备份数据的class）：负责保存好备忘录Memento,不能对备忘录的内容进行操作或检查。&lt;/p&gt;

&lt;h5&gt;由于备忘录模式非常灵活，往简单说可以保存单state，多state。甚至是一个保存class，往更大的说了，就是一个备份系统，每隔一段时间备份一次数据。&lt;/h5&gt;

&lt;h5&gt;不过使用备忘录模式的时候，要考虑控制建立Memento的数量，大的object非常消耗资源，有可能产生内存泄露。&lt;/h5&gt;

&lt;p&gt;下面我先来说对于单变量的备忘录模式。
&lt;img src=&quot;/assets/pic/memento.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;
 
//保存数据的class
class Memento
{
private:
    friend class Originator;
    Memento(const string&amp; state){this-&gt;_state = state;}
    ~Memento(){}
    void SetState(const string&amp; state){this-&gt;_state = state;}
    string GetState(){return this-&gt;_state;}
    string _state;
};
 
 
//备份数据逻辑的class
class Originator
{
public:
    Originator();
    Originator(const string&amp; state){this-&gt;_state = state;}
    ~Originator(){}
    void RestoreToMemento(Memento* pMemento){this-&gt;_state = pMemento-&gt;GetState();}
    Memento* CreateMemento(){return new Memento(this-&gt;_state);}
    void SetState(const string&amp; state){this-&gt;_state = state;}
    string GetState(){return this-&gt;_state;}
    void show(){cout &lt;&lt; this-&gt;_state &lt;&lt; endl;}
protected:
private:
    string _state;
};
 
//管理备份数据的class
class Caretaker
{
public:
    Caretaker(){}
    ~Caretaker(){}
    void SetMemento(Memento *pMemento){this-&gt;_memento = pMemento;}
    Memento* GetMemento(){return this-&gt;_memento;}
private:
    Memento* _memento;
};
int main()
{
    //初始化对象，状态为“Old”
    Originator* o = new Originator(&quot;Old&quot;);
    o-&gt;show();
 
    //建立并保存Memento
    Caretaker* pTaker = new Caretaker();
    pTaker-&gt;SetMemento(o-&gt;CreateMemento());
 
    //改变状态
    o-&gt;SetState(&quot;New&quot;);
    o-&gt;show();
 
    //恢复状态
    o-&gt;RestoreToMemento(pTaker-&gt;GetMemento());
    o-&gt;show();
 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;上面我们只是保存了一个state值，如果要保存一系列的值，小于6个，个人推荐直接在构造函数里传值保存！
如果是保存一个类，在Java中我们有clone（）方法，但是在C++中，我们没有现成的cloneable接口，我们无法进行深拷贝，只能借助库或者是直接实现，这里我们可以参考之前的原型模式（protype pattern）实现方式。&lt;/p&gt;

&lt;p&gt;对于多状态备忘录模式在Java中我们可以使用BeanUtils工具类，在Java中使用BeanUtils；类以及反射的技术，进行保存，精髓就是使用hashmap来进行保存！&lt;/p&gt;

&lt;p&gt;对于多备份备忘录，我们构造一个hashmap来存放不同时刻的memento&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class MultiCaretaker
{
public:
    MultiCaretaker(){}
    ~MultiCaretaker(){}
    void SetMemento(string name,Memento *pMemento){this-&gt;memmap.insert(pair&lt;string,Memento*&gt;(name,pMemento));}
    Memento* GetMemento(string name){return this-&gt;memmap[name];}
private:
    hash_map&lt;string,Memento*&gt; memmap;
};
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;如果为了封装好一点，可以将memento放在originator中，只有originator可以调用memento！
刚才在上面做的那种单状态保存的方式，使用friend属性，其实打破了OO的开闭原则，存在一定的缺陷！&lt;/p&gt;

&lt;h5&gt;Java中有反射机制，C++中如何具体实现这种机制还要继续学习一下！&lt;/h5&gt;

&lt;p&gt;参考
&lt;a href=&quot;http://blog.csdn.net/wuzhekai1985/article/details/6672906&quot;&gt;http://blog.csdn.net/wuzhekai1985/article/details/6672906&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/ai92/article/details/454354&quot;&gt;http://blog.csdn.net/ai92/article/details/454354&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Observer Pattern with C++</title>
      <link>place_your_blog_url_here/2014/06/10/observer-pattern-with-c.html</link>
      <pubDate>10 Jun 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/06/10/observer-pattern-with-c</guid>
      <description>&lt;h1&gt;观察者模式C++实现&lt;/h1&gt;

&lt;p&gt;观察者模式是非常重要的一个模式，初次遇到该模式，想了很久没有想通应该怎么做。&lt;/p&gt;

&lt;p&gt;其实原理很简单：就是当被观察者（Observable）发生变化，然后就会某种数据方式通知（Notify）观察者（Observer），Notify的方式很多，比如我们将Observer 放到一个list或者set中，分别调用Observer的update（）这样实现通知。&lt;/p&gt;

&lt;p&gt;这个模式和之前的责任链模式很相似，不同的是观察者模式在消息传播的时候，消息是可变的。责任链模式在消息 传播的过程保持消息的不可变。&lt;/p&gt;

&lt;h4&gt;另外我们要说明的是ObserverPattern模式中最好只出现一个既是Observer又是Observable的对象，消息最多转发一次&lt;/h4&gt;

&lt;h4&gt;从效率上来说，如果一个Observer被阻塞，会影响其他Observer的Notify（），所以Notify（）最好采用异步的方式。不过异步的话就要考虑线程安全和队列的问题，需要查看message queue。&lt;/h4&gt;

&lt;p&gt;下面是UML类图
&lt;img src=&quot;/assets/pic/Observer.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;
 
class IObserver
{
public:
    IObserver(string _name)
    {
        this-&gt;m_name = _name;
    }
    virtual ~IObserver(void)
    {
    }
    virtual void Update(string context) = 0;
    virtual string GetName() = 0;//为c++单独增加的函数，用于删除时查找观察者。
protected:
    string m_name;
};
 
class IObservable
{
public:
    IObservable(void)
    {
    }
    virtual ~IObservable(void)
    {
    }
    virtual void AddObserver(IObserver *pObserver) = 0;
    virtual void DeleteObserver(IObserver *pObserver) = 0;
    virtual void NotifyObservers(string context) = 0;
};
 
class SuperStar : public IObservable
{
public:
    SuperStar(void){}
    ~SuperStar(void){}
    void AddObserver(IObserver *pObserver){m_observerList.push_back(pObserver);}
    void DeleteObserver(IObserver *pObserver)
    {
        ObserverList_C_iterator it = m_observerList.begin();
        for (; it != m_observerList.end(); it++)
        {
            string name = (*it)-&gt;GetName();
            if (name.compare(pObserver-&gt;GetName()) == 0)
            {
                it = m_observerList.erase(it);
            }
        }
    }
    void NotifyObservers(string context)
    {
        ObserverList_C_iterator it = m_observerList.begin();
        for (; it != m_observerList.end(); it ++)
        {
            (*it)-&gt;Update(context);
        }
    }
    void HaveBreakfast()
    {
         cout &lt;&lt; &quot;SuperStart begin to have breakfast...&quot; &lt;&lt; endl;
         this-&gt;NotifyObservers(&quot;SuperStart begin to have breakfast&quot;);
    }
    void HaveFun()
    {
         cout &lt;&lt; &quot;SuperStart begin to have fun...&quot; &lt;&lt; endl;
         this-&gt;NotifyObservers(&quot;SuperStart begin to have fun&quot;);
    }
private:
    vector&lt;IObserver*&gt; m_observerList;
    typedef vector&lt;IObserver*&gt;::const_iterator ObserverList_C_iterator;
};
class Spy1 :  public IObserver
{
public:
    Spy1(void):IObserver(&quot;SPY1&quot;){}
    ~Spy1(void){}
    void Update(string context)
    {
        cout &lt;&lt; &quot;Spy1:something happened...&quot; &lt;&lt; endl;
        this-&gt;ReportToBoss(context);
        cout &lt;&lt; &quot;Spy1:get some price&quot; &lt;&lt; endl;
    }
    string GetName(){return m_name;}
private:
    void ReportToBoss(string report)
    {
         cout &lt;&lt; &quot;Spy1:Boss-&gt;&quot; &lt;&lt; report.c_str() &lt;&lt; endl;
    }
};
class Spy2 :  public IObserver
{
public:
    Spy2(void):IObserver(&quot;SPY1&quot;){}
    ~Spy2(void){}
    void Update(string context)
    {
        cout &lt;&lt; &quot;Spy2:something happened...&quot; &lt;&lt; endl;
        this-&gt;ReportToBoss(context);
        cout &lt;&lt; &quot;Spy2:get some price&quot; &lt;&lt; endl;
    }
    string GetName(){return m_name;}
private:
    void ReportToBoss(string report)
    {
         cout &lt;&lt; &quot;Spy2:Boss-&gt;&quot; &lt;&lt; report.c_str() &lt;&lt; endl;
    }
};
 
int main()
{
    IObserver *spy1 = new Spy1();
    IObserver *spy2 = new Spy2();
 
    SuperStar *superstar = new SuperStar();
 
    superstar-&gt;AddObserver(spy1);
    superstar-&gt;AddObserver(spy2);
 
    superstar-&gt;HaveFun();
 
    cout &lt;&lt; endl;
    superstar-&gt;DeleteObserver(spy1);
    superstar-&gt;HaveBreakfast();
 
    delete spy1;
    spy1 = NULL;
    delete spy2;
    spy2 = NULL;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;因为是C++实现，没有通用的Observer Pattern framework，所以我们在class superstar中实现了&lt;/p&gt;

&lt;p&gt;void AddObserver(IObserver *pObserver)&lt;/p&gt;

&lt;p&gt;void DeleteObserver(IObserver *pObserver)&lt;/p&gt;

&lt;p&gt;void NotifyObservers(string context)&lt;/p&gt;

&lt;p&gt;如果我们把这个代码变为一种framework，类图会变化
&lt;img src=&quot;/assets/pic/Observer2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>