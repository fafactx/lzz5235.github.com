---
layout: post
title: "RAM_Management3个层次的关系"
categories: [linux]

tags: [RAM,Kernel] 


---
内存管理3个层次的关系
=======================
![](/assets/pic/1561.jpg)

下面以扩展用户堆栈为例，解释3个层次的关系。

调用函数时，会涉及堆栈的操作，当访问地址超过堆栈的边界时，便引起page fault，内核处理页面失效的过程中，涉及到内存管理的3个层次。

Ø 调用expand_stack()修改vm_area_struct结构，即扩展堆栈区的虚拟地址空间；

Ø 创建空白页表项，这一过程会利用mm_struct中的pgd(页全局目录表基址)得到页目录表项(pgd_offset())，然后计算得到相应的页表项(pte_alloc())地址；

Ø 调用alloc_page()分配物理页面，它会从指定内存管理区的buddy system中查找一块合适的free_area，进而得到一个物理页面；

Ø 创建映射关系，先调用mk_pte()产生页表项内容，然后调用set_pte()写入页表项。

Ø 至此，扩展堆栈基本完成，用户进程重新访问堆栈便可以成功。

可以认为，结构体pgd和vm_area_struct，函数alloc_page()和mk_pte()是连接三者的桥梁。

> 让内核能够支持4K页到某一值之间的任意2的幂数值的大小的页面。注意，这里的页面指的是连续的物理页。
这个有点像伙伴系统。如果我们选择支持4K~4M页，那么我们就要能够分配4K~4M之间的任意2的幂数值的大小的连续物理页框：如果没有合适大小的页框，要对更大的页框进行剪裁；如果页框被归还回来，要主动将两个连续的页框块合并为一个较大的页框块。
